<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-07-02 Sat 14:54 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Beginning_Python(3)</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="kamisama" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="./index.html"> UP </a>
 |
 <a accesskey="H" href="../index.html"> HOME </a>
</div><div id="content">
<h1 class="title">Beginning_Python(3)</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgef608ae">第一章 快速上手:基础知识</a>
<ul>
<li><a href="#org6808338">交互式解释器</a></li>
<li><a href="#org3a5c030">算法是什么</a></li>
<li><a href="#orgf5e4f7a">数和表达式</a></li>
<li><a href="#org8829390">变量</a></li>
<li><a href="#org66b4261">语句</a></li>
<li><a href="#org5d2983a">获取用户输入</a></li>
<li><a href="#orge3b21ee">函数</a></li>
<li><a href="#orgc768c64">模块</a>
<ul>
<li><a href="#orgdc92002">cmath 和复数</a></li>
<li><a href="#orgd223379">回到未来</a></li>
</ul>
</li>
<li><a href="#org360ac63">保存并执行程序</a>
<ul>
<li><a href="#orga32ed81">从命令提示符运行Python脚本</a></li>
<li><a href="#org3fa600a">让脚本像普通程序一样</a></li>
<li><a href="#org54e40ed">注释</a></li>
</ul>
</li>
<li><a href="#orgc13c969">字符串</a>
<ul>
<li><a href="#orgc574d89">单引号字符串以及对引号转义</a></li>
<li><a href="#org96d6f36">拼接字符串</a></li>
<li><a href="#org779bc51">字符串表示 str 和 repr</a></li>
<li><a href="#orgf0236f4">长字符串,原始字符串和字节</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgef608ae" class="outline-2">
<h2 id="orgef608ae">第一章 快速上手:基础知识</h2>
<div class="outline-text-2" id="text-orgef608ae">
</div>
<div id="outline-container-org6808338" class="outline-3">
<h3 id="org6808338">交互式解释器</h3>
<div class="outline-text-3" id="text-org6808338">
<p>
编程就是让计算机按照人类的意愿去执行一些人力成本较高的工作,而计算机能识别(读
懂)的语言只有机器语言(01010101010&#x2026;.),早期程序员用打孔的纸带来表示0和
1,这就是直接使用机器语言对计算机编程.但机器语言对于人类来说是可读性非常差的,
而且这种方式编写的程序代码不容易找错(没人想在一连串的01中找到可能出错的某一
个),于是前辈们发明了高级编程语言,用一种人类更容易理解和阅读的语言来对计算机
进行编程,而实际上计算机仍然使用的是01的机器语言,只不过高级编程语言会将代码转
换成机器语言.所以高级编程语言就是人类和计算机之间的翻译器.翻译的方式有两种,
一种是编译型,就是将高级语言编写的程序编译成二进制程序(机器语言程序).另一种就
是解释型,解释型是先运行一个解释器程序,而这个程序的作用是执行高级语言程序指令,
这里解释器的作用就是一个中间人,负责沟通人和机器双方,人只需要和解释器沟通,剩下
的执行就交给解释器和机器沟通了,这个过程中人不必在意解释器和机器沟通的过程,这
些都交给解释器处理了,这里和编译型的就有很大不同了,在linux和windows上都写过C
程序的可能有印象,对于某些库的使用标准在两个系统上是不一样的.
</p>

<p>
编译器相当于翻译工作中的笔译，将高级编程语言的源程序翻译成二进制程序，这个程
序再由计算机执行；
解释器相当于同声传译(大概吧),解释器直接执行高级编程语言的指令,解释器会根据这
些指令告诉计算机需要执行什么操作.
</p>

<p>
用翻译的例子就能知道编程语言的语法是很重要的，因为你说的话连译者都不懂，那译
者就不可能把你的意思转达给计算机.
</p>
</div>
</div>
<div id="outline-container-org3a5c030" class="outline-3">
<h3 id="org3a5c030">算法是什么</h3>
<div class="outline-text-3" id="text-org3a5c030">
<p>
计算机多才多艺,但不能思考.计算机的工作本质就是计算,我们能看到的电脑展现出来的
图形图像,音乐影像,我们能使用的各种电子产品都是计算机与各个学科,各个行业结合的
产物.各种学科领域都是人类对世界某一角的认知,当人们认知某一未知事物时,除了需要
给其一定的概念定义,还需要能对其进行衡量,概念定义取决于人们当时的认知水平,从神
鬼妖魔到抽象总结;对事物衡量的方法从人类开始进行生产生活就一直在发展演变,最终
形成的一门叫数学的学科,在我看来,数学是人类对自然规律的总结和发展的产物.所以小
时侯数学课上老师说的生活中处处都有数学这句话我到现在还记得. 数学在计算机里较
为间接的体现就是算法了(直接体现就是编程语言里对应的算术运算).算法这个词是翻译
过来的(应该说大部分编程术语都是翻译过来的),计算+方法,反正第一次听说这个词我是
这么理解的,记得老师解释说算法是解决问题的流程.维基百科的定义:
</p>
<blockquote>
<p>
In mathematics and computer science, an algorithm (<i>ˈælɡərɪðəm</i> ) is a finite
sequence of well-defined instructions, typically used to solve a class of
specific problems or to perform a computation.
自翻:在数学和计算机科学领域,算法是有明确定义的指令组成的有限序列,通常用来解决
一类特定的问题或进行计算.
</p>
</blockquote>
<p>
而我们学习算法总是会和数据结构结合起来,这是为啥?上面的定义里说了,算法是一连串
的指令,是用来解决问题或进行计算的,数学在生活中可以帮助我们算算那个该死的
一边加水一边放水的池子能不放空,能不能加满,或需要多少时间加满/放空,解决这个问
题时我们会用两个数表示单位时间内进水和放水的量,比较这两个数就可以知道能不能加
满/放空的问题,再用上两个数表示原池子里的水量和池子的容量计算,就可以得出加满/
放空的时间.这里使用的四个数,就是数学对这个蛋疼的池子问题的抽象,其中进行的计算
就是对加水放水的模拟.类比到计算机里,数据结构就是对问题抽象,更准确的说是对客观
事物的抽象,毕竟只要你是客观事物,你必定有可以衡量其存在的质量,外形等等可以抽象
的特质;算法,就是对解决客观事物(问题)的模拟了.
还是原书里的例子好,菜谱是某个菜的做法,想要做菜,需要原料和做法,原料就是菜,做法
就是对菜的一系列操作,有的操作必须按顺序:得先过水,再加调料;有的操作要重复多次:
每分钟翻炒N下.在Python里,原料就是对象,做法就是一系列操作(语句).
</p>

<p>
一句话: Python里的算法体现就是为了解决实际问题而对Python对象执行的一系列语句.
</p>
</div>
</div>
<div id="outline-container-orgf5e4f7a" class="outline-3">
<h3 id="orgf5e4f7a">数和表达式</h3>
<div class="outline-text-3" id="text-orgf5e4f7a">
<p>
交互式Python解释器可以当作一个功能强大的计算器.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">运算符</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>+</code></td>
<td class="org-left">加法(求和)</td>
</tr>

<tr>
<td class="org-left"><code>-</code></td>
<td class="org-left">减法(求负)</td>
</tr>

<tr>
<td class="org-left"><code>*</code></td>
<td class="org-left">乘法</td>
</tr>

<tr>
<td class="org-left"><code>/</code></td>
<td class="org-left">除法</td>
</tr>

<tr>
<td class="org-left"><code>//</code></td>
<td class="org-left">整除</td>
</tr>

<tr>
<td class="org-left"><code>%</code></td>
<td class="org-left">求余</td>
</tr>

<tr>
<td class="org-left"><code>**</code></td>
<td class="org-left">乘方(求幂)</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>Python 的整除操作是除法的结果向下取整(floor(1.1)=1,floor(-1.1)=-2).</li>
<li>求余操作是整除时余下的部分: <code>x % y</code> 等价于 <code>x - ((x // y) * y)</code></li>
<li>乘方(<code>**</code>) 的优先级要比求负要高,因此 <code>-3**2</code> 等价于 <code>-(3**2)</code>,要计算 <code>-3</code> 的平方,应
写作 <code>(-3)**2</code>.</li>
</ul>


<p>
Python 里数的进制表示.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">十进制</th>
<th scope="col" class="org-right">十六进制</th>
<th scope="col" class="org-right">八进制</th>
<th scope="col" class="org-left">二进制</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">175</td>
<td class="org-right">0xAF</td>
<td class="org-right">0257</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">8</td>
<td class="org-right">0x8</td>
<td class="org-right">010</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">722</td>
<td class="org-right">0x2D2</td>
<td class="org-right">01322</td>
<td class="org-left">0b1011010010</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org8829390" class="outline-3">
<h3 id="org8829390">变量</h3>
<div class="outline-text-3" id="text-org8829390">
<p>
Python 里变量是表示或指向特定值的名称.例如想用 x 表示 3,执行代码: <code>x = 3</code>,这称
为赋值(assignment), 这个语句把值3赋给了变量x, 赋值就是将值(对象)与变量名关联
起来的操作.给变量赋值后,就可以在表达式里使用它 <code>x * 2</code>, Python 里使用变量前必须
给它赋值,因为Python 变量没有默认值. Python 变量的名称只能由字母([a-zA-Z]), 数
字([0-9]) 和下划线(_) 构成,且不能由数字开头.因此, <code>Plan9</code> 是合法变量名, <code>9Plan</code>
不是.
</p>
</div>
</div>
<div id="outline-container-org66b4261" class="outline-3">
<h3 id="org66b4261">语句</h3>
<div class="outline-text-3" id="text-org66b4261">
<p>
前面用了很多和数学表达式类似的表达式,相当于菜谱中的原料,语句就是菜谱里的操作.
上面的只是一种不准确的便于理解的说法.语句和表达式的行为很像,因此他们的界限可
能不是十分明确.表达式是一些东西,语句是做一些事情.
</p>

<p>
交互式解释器总是会将表达式的值打印出来(打印 repr 表示的内容),因此 <code>2 * 2</code> 和
<code>print(2 * 2)</code> 在解释器里的结果没有差别.
</p>

<p>
不使用解释器运行的程序里, <code>2 * 2</code> 不会有任何作用(这个表达式确实会执行一些操作,
计算2和2的乘积,但既不会保存结果,也不会打印结果显示给用户,所以除了执行计算之
外,没有任何作用)
</p>

<p>
注意: <code>print</code> 实际上是一个函数,因此 print 语句实际上是函数调用,在Python2.x
里,print 是一条语句,因此,无需将打印的内容作为参数放在圆括号里.
</p>

<p>
在涉及赋值时,语句和表达式的界限更明显,因为赋值语句不是表达式,因此,交互式解释
器不会打印它的值.
</p>

<p>
可以说,一个语句的根本特征是:执行修改操作.例如,赋值语句改变变量,print 语句改变
屏幕外观.
</p>
</div>
</div>
<div id="outline-container-org5d2983a" class="outline-3">
<h3 id="org5d2983a">获取用户输入</h3>
<div class="outline-text-3" id="text-org5d2983a">
<p>
<code>input</code> 函数能获取标准输入,并将用户输入的信息以字符串的方式返回.
</p>
<pre class="example">
&gt;&gt;&gt; x = input("x: ")
x: 1
&gt;&gt;&gt; y = input("y: ")
y: 3
&gt;&gt;&gt; print(int(x) * int(y))
3
&gt;&gt;&gt;
</pre>

<p>
注意: 将程序存储在独立文件中,让其他用户能够执行时,这种获取输入的方式将有用很
多.<a href="#orgc768c64">模块</a> 一节将介绍如何这样做.
</p>
</div>
</div>
<div id="outline-container-orge3b21ee" class="outline-3">
<h3 id="orge3b21ee">函数</h3>
<div class="outline-text-3" id="text-orge3b21ee">
<p>
<a href="#orgf5e4f7a">数和表达式</a> 一节里介绍了乘方运算符(<code>**</code>)来执行幂运算.实际上,可以不适用这个运算
符,而使用函数 <code>pow</code>.
</p>
<pre class="example">
&gt;&gt;&gt; 2 ** 3
8
&gt;&gt;&gt; pow(2, 3)
8
&gt;&gt;&gt;
</pre>
<p>
函数就像小型程序,可以用来执行特定的操作. Python 提供了很多函数,来完成很多神奇
的任务,事实上,你可以自己编写函数,因此,我们将 <code>pow</code> 等标准函数称为 <code>内置函数</code>.
上面的示例一样使用函数叫 <code>函数调用</code> :给函数提供参数,函数返回一个值. 因为函数会
返回一个值,因此他们也是表达式,函数的调用也可以作为语句,但是这种情况时会忽略函
数的返回值.
</p>
<pre class="example">
&gt;&gt;&gt; 10 + pow(2, 3 * 5) / 3.0
10932.666666666666
</pre>
<p>
有多个内置的函数可以用于编写数值表达式.
<code>abs</code> 计算绝对值, <code>round</code> 将浮点数圆整到与之最为接近的整数.
</p>
<pre class="example">
&gt;&gt;&gt; abs(-1)
1
&gt;&gt;&gt; 2 // 3
0
&gt;&gt;&gt; round(2/3)
1
</pre>
<p>
注意最后两个表达式,整除总是向下圆整,而 <code>round</code> 圆整到最近的整数,在两个整数一样
近时圆整到偶数.注意,这里说的是圆整到整数(integer)
事实上,对浮点数,也就是我们常说的小数进行 <code>round</code> 操作,结果可能出乎意料,例如
<code>round(2.675, 2)</code> 的结果是 <code>2.67</code> 而不是 <code>2.68</code> , 这一结果是因为大多数十进制小数实
际上都不能以浮点数精确表示.想要精确执行四舍五入操作可以参考 <a href="https://docs.python.org/zh-cn/3.8/library/decimal.html#module-decimal">decimal 模块</a>.
如果想让某个数向下圆整,可以怎么做呢? 受上面例子的启发,我们可以使用整除1来将该
数向下圆整: <code>32.9 // 1</code>,但只要表达式里有浮点数,结果也会自动转换为浮点数,所以结
果为 <code>32.0</code>,因此我们可以使用 <code>int</code> 函数将浮点数强制转换为整数 <code>int(32.9 // 1)</code>,结果
为 <code>32</code>. 事实上,python 提供了完成这样操作的函数 <code>floor</code> ,但你不能直接使用他,因为
它和其他很多有用的函数一样,它被包含在模块中.
</p>
</div>
</div>
<div id="outline-container-orgc768c64" class="outline-3">
<h3 id="orgc768c64">模块</h3>
<div class="outline-text-3" id="text-orgc768c64">
<p>
模块可视为插件或扩展,通过将其导入可以扩展Python 的功能.
要导入模块,需要使用 <code>import</code> 命令.前一节提到的 <code>floor</code> 函数包含在模块 <code>math</code> 中.
</p>
<pre class="example">
&gt;&gt;&gt; import math
&gt;&gt;&gt; math.floor(32.9)
32
</pre>
<p>
使用 import 导入模块,再使用 module.function 的方式使用(调用)模块中的函数.这里
的例子可以像前面处理 input 的返回值那样,将数字直接转换为整数:
</p>
<pre class="example">
&gt;&gt;&gt; int(32.9)
32
</pre>
<blockquote>
<p>
还有一些类似的函数,也用于转换类型,如 str 和 float. 实际上,他们并不是函数,而是
类.
</p>
</blockquote>
<p>
math 模块还包含几个有用的函数.ceil 和 floor 相反,返回大于或等于给定数的最小整
数.
</p>
<pre class="example">
&gt;&gt;&gt; math.ceil(32.1)
33
&gt;&gt;&gt; math.ceil(32)
32
</pre>
<p>
如果确定不会从不同模块中导入同名函数,可以使用 import 的变种:
</p>
<pre class="example">
&gt;&gt;&gt; from math import sqrt
&gt;&gt;&gt; sqrt(9)
3.0
</pre>
<p>
import 的变种: from module import function 可以在调用函数时不指定模块前缀.
事实上,可以使用变量来引用函数(以及其他大部分Python元素). 执行赋值语句: <code>foo =
   math.sqrt</code> 之后,就可以使用 <code>foo</code> 来计算平方根.
</p>
<pre class="example">
&gt;&gt;&gt; foo = math.sqrt
&gt;&gt;&gt; foo(9)
3.0
&gt;&gt;&gt; foo(4)
2.0
</pre>
</div>

<div id="outline-container-orgdc92002" class="outline-4">
<h4 id="orgdc92002">cmath 和复数</h4>
<div class="outline-text-4" id="text-orgdc92002">
<p>
当处理的数不再局限于实数时,sqrt 能继续处理吗?
</p>
<pre class="example">
&gt;&gt;&gt; sqrt(-1)
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: math domain error
</pre>
<p>
我的 Manjaro-i3 上报错了,有的系统可能会是
</p>
<pre class="example">
&gt;&gt;&gt; sqrt(-1)
nan
</pre>
<p>
<code>nan</code> 有特殊意义,表示非数值(not a number)
Python 的标准库提供了一个专门处理复数的模块:
</p>
<pre class="example">
&gt;&gt;&gt; import cmath
&gt;&gt;&gt; cmath.sqrt(-1)
1j
</pre>
<p>
这里使用了 module.function 的常规import 用法,因为前面已经使用变种用法导入了
math.sqrt, 再使用变种就会导致cmath 和 math 的 sqrt 冲突,只有最后一个导入的
sqrt 能正常使用.
1j 是个虚数,虚数都是以 j(J) 结尾.看下面的例子
</p>
<pre class="example">
&gt;&gt;&gt; (1+3j)*(9 + 4j)
(-3+31j)
</pre>
<p>
由结果可以得知,Python 本身提供了对复数的支持
</p>
<blockquote>
<p>
Python 没有专门表示虚数的类型,而将虚数视为实部为零的复数
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orgd223379" class="outline-4">
<h4 id="orgd223379">回到未来</h4>
<div class="outline-text-4" id="text-orgd223379">
<p>
据说Python 之父 Guido van Rossum 有一台时光机,对于Python 当前不支持,但未来将
成为标准组成部分的功能,可以使用神奇的 <code>__future__</code> 模块导入.如果是使用
Python2.x, 可能会经常遇到,但3.x 目前没有遇到太多这种问题,等遇到了再回来看看.
</p>
</div>
</div>
</div>

<div id="outline-container-org360ac63" class="outline-3">
<h3 id="org360ac63">保存并执行程序</h3>
<div class="outline-text-3" id="text-org360ac63">
<p>
新建一个文本文件,将后缀名(文件扩展名)改为 <code>py</code>, 文件里一行放置一条代码.如果使用
的是IDE 编辑文件,会有许多提示或按钮方便你编辑和运行程序.
</p>

<ul class="org-ul">
<li>海龟绘图法</li>
</ul>
<p>
在文本文件里键入下面内容,保存后运行该文件,就可以演示如何绘制一个三角形:
</p>
<pre class="example">
from turtle import *
forward(100)
left(120)
forward(100)
left(120)
forward(100)

</pre>
<p>
运行代码后,会出现一个新的窗口,其中有个箭头不断移动,并留下移动轨迹.
</p>
</div>

<div id="outline-container-orga32ed81" class="outline-4">
<h4 id="orga32ed81">从命令提示符运行Python脚本</h4>
<div class="outline-text-4" id="text-orga32ed81">
<p>
实际上,运行程序的方式有很多种.打开windows DOS 窗口或者 UNIX shell, 运行
<code>python hello.py</code> 命名为 hello.py 的python 程序就会运行.
</p>
</div>
</div>

<div id="outline-container-org3fa600a" class="outline-4">
<h4 id="org3fa600a">让脚本像普通程序一样</h4>
<div class="outline-text-4" id="text-org3fa600a">
<p>
在有些情况下,你想要像执行其他程序一样执行Python脚本,而无需显示使用Python 解
释器.UNIX 提供实现这种方式的标准方式:让脚本的地一行以字符序列 <code>#!</code> (pound bang
或 shebang) 开始,并在它后面指定用于对脚本进行执行/解释的程序(这里指Python)的
绝对路径. 如果不理解这一点,只需要知道将下列代码加入到脚本文件的第一行,就可以
在UNIX 中运行脚本:
</p>
<pre class="example">
#!/usr/bin/env python
</pre>
<p>
linux 系统可以使用 <code>whereis</code> 命令查看Python 的绝对路径:
</p>
<div class="org-src-container">
<pre class="src src-sh">whereis python
</pre>
</div>

<pre class="example">
python: /usr/bin/python /home/kamisama/.pyenv/shims/python /usr/share/man/man1/python.1.gz

</pre>
<p>
结果告诉我们 <code>/usr/bin/python</code> 为Python 的绝对路径,我们将 <code>#!/usr/bin/python</code> 添
加到文件第一行,也能和上面的例子达到一样的效果.当然,在UNIX 系统里,权限是很重
要的,想要像普通程序一样运行Python 脚本,需要给脚本文件可执行权限:
</p>
<pre class="example">
$chmod a+x hello.py
</pre>
<p>
现在就可以使用 <code>hello.py</code> 来执行 hello.py 脚本文件(如果当前目录在执行路径中).如
果直接键入文件名不起作用,可以使用 <code>./hello.py</code> 来执行文件(这在当前目录不在执行
目录中也管用).执行路径的问题涉及到操作系统的知识,这里先不讨论.留下一个 TODO
以后涉及到这里了再来补个链接.
</p>

<p>
Windows 系统里如果正确安装了Python, 双击编写好的Python文件, 就可以执行了.
</p>
</div>
</div>

<div id="outline-container-org54e40ed" class="outline-4">
<h4 id="org54e40ed">注释</h4>
<div class="outline-text-4" id="text-org54e40ed">
<p>
Python中, 井号(<code>#</code>) 比较特殊,在代码中,井号后面一直到行尾的所有内容都会被忽略.注
释让程序更容易理解,不管是对于自己还是他人都是如此.编写程序首要的戒律就是 <code>汝
    应注释</code> ,但也有一些程序员的座右铭是 "如果写起来难,理解起来必然也难."
注释必须言而有物,不要重复去讲通过代码就很容易获取的信息,无用且重复的注释不如
没有.例如下面的注释就是多余的:
</p>
<pre class="example">
# 获取用户的名字
user_name = input("What is your name?")
</pre>
<p>
此外,在任何情况下,都应该确保代码即便没有注释也易于理解,所幸Python 是一种卓越
的语言,很容易写出自注释的程序.
</p>
</div>
</div>
</div>

<div id="outline-container-orgc13c969" class="outline-3">
<h3 id="orgc13c969">字符串</h3>
<div class="outline-text-3" id="text-orgc13c969">
<p>
几乎所有的编程教程都以类似的程序开篇: <code>print("Hello, World!")</code>.
这里的 <code>"Hello, World!"</code> 就是一个 <code>字符串</code> (string). 几乎所有的Python程序里都有字
符串的身影, 字符串的用处众多,但主要用途就是表示一段文本.
</p>
<blockquote>
<p>
当我们说字符串的时候,其实指的是字符串字面值,它是值,因此我们在交互式解释器里可
以直接打印字符串.
</p>
</blockquote>
</div>

<div id="outline-container-orgc574d89" class="outline-4">
<h4 id="orgc574d89">单引号字符串以及对引号转义</h4>
<div class="outline-text-4" id="text-orgc574d89">
<p>
与数字一样,字符串也是值.上面说过,交互式解释器会打印表达式的值:
</p>
<pre class="example">
&gt;&gt;&gt; "Hello, World!"
'Hello, World!'
</pre>
<p>
这里使用双引号括起来的字符串,在打印时却是使用单引号括起来的.这两者有区别吗?
其实没有任何区别!
</p>
<pre class="example">
&gt;&gt;&gt; 'Hello, World!'
'Hello, World!'
</pre>
<p>
这里使用单引号,打印结果也是单引号.既然没区别,那为什么要同时支持单引号和双引
号呢? 这是因为在有些情况下,支持两种引号会很有用.
</p>
<pre class="example">
&gt;&gt;&gt; "Let's go!"
"Let's go!"
&gt;&gt;&gt; '"Hello, World!" she said'
'"Hello, World!" she said'
</pre>
<p>
上面的例子里,第一个字符串本身就包含单引号,因此就不能使用单引号将整个字符串括
起来,否则解释器会报错:
</p>
<pre class="example">
&gt;&gt;&gt; 'Let's go!'
File "&lt;stdin&gt;", line 1
'Let's go!'
^
SyntaxError: invalid syntax
</pre>
<p>
第二个字符串里有双引号,因此使用单引号将字符串括起来.实际上,这样做只是处于方
便考虑.因为可以使用反斜杠(<code>\</code>)对引号进行转义:
</p>
<pre class="example">
&gt;&gt;&gt; 'Let\'s go!'
"Let's go!"
</pre>
<p>
这样,python 会明白中间的引号是字符串的一部分,而不是字符串结束的标志.同理,双
引号也可以使用相同的处理手法.
对引号的转义在字符串里同时包含单双引号时是必须的.
</p>
<blockquote>
<p>
如果不想使用反斜杠进行转义,后面还有长字符串和原始字符串(这两种可以结合使用)
两种方式来避免使用反斜杠.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org96d6f36" class="outline-4">
<h4 id="org96d6f36">拼接字符串</h4>
<div class="outline-text-4" id="text-org96d6f36">
<p>
为了处理同时包含单双引号的字符串,可以使用字符串的另一种表示方式:
</p>
<pre class="example">
&gt;&gt;&gt; "Let's say " '"Hello, worlf!"'
'Let\'s say "Hello, worlf!"'
&gt;&gt;&gt; x = "Let's say " '"Hello, world!"'
&gt;&gt;&gt; x
'Let\'s say "Hello, world!"'
&gt;&gt;&gt; print(x)
Let's say "Hello, world!"
</pre>
<p>
在交互式解释器里依次输入了两个字符串,并使用空格隔开了(没有空格也一样),而
Python 自动将他们拼接成了一个字符串.这种机制用的不多,而且只有当同时依次输入
两个字符串时这种机制才管用.
</p>
<pre class="example">
&gt;&gt;&gt; x = "Hello, "
&gt;&gt;&gt; y = "world!"
&gt;&gt;&gt; x y
File "&lt;stdin&gt;", line 1
x y
^
SyntaxError: invalid syntax
</pre>
<p>
上面只是一种输入字符串的特殊方式,而非通用的字符串拼接方式.
通用的字符串拼接方式就是将字符串和数字一样相加:
</p>
<pre class="example">
&gt;&gt;&gt; "Hello, " + "world!"
'Hello, world!'
&gt;&gt;&gt; x = "Hello, "
&gt;&gt;&gt; y = "world!"
&gt;&gt;&gt; x + y
'Hello, world!'
</pre>
</div>
</div>
<div id="outline-container-org779bc51" class="outline-4">
<h4 id="org779bc51">字符串表示 str 和 repr</h4>
<div class="outline-text-4" id="text-org779bc51">
<p>
Python 打印所有字符串时,都用引号将其括起来.上面的许多例子都是这样的,这是因为
Python 打印值时会保留其在代码中的样子,而不是你希望输出(展示给用户)的样子.但
是如果使用print函数,结果就会不同:
</p>
<pre class="example">
&gt;&gt;&gt; "hello, World!"
'hello, World!'
&gt;&gt;&gt; print("hello, World!")
hello, World!
</pre>
<p>
因为Python有两种将值转换成字符串的方式: <code>str</code> 和 <code>repr</code>.
str 是和 int 一样的类, repr 是一个函数.
str 能以合理的方式将值转换成用户能够看懂的字符串, repr 通常会返回值的合法
Python 表达式表示.
</p>
<pre class="example">
&gt;&gt;&gt; print(repr("hello\n"))
'hello\n'
&gt;&gt;&gt; print(str("hello\n"))
hello

&gt;&gt;&gt;
</pre>
</div>
</div>

<div id="outline-container-orgf0236f4" class="outline-4">
<h4 id="orgf0236f4">长字符串,原始字符串和字节</h4>
<div class="outline-text-4" id="text-orgf0236f4">
<p>
有一些独特而且有用的字符串表示方式.例如,有一种独特的语法可以用于表示包含韩航
符或反斜杠的字符串(长字符串和原始字符串). 对于包含特殊字符的字符串,Python2
提供一种专用的表示语法,结果为Unicode字符串.这种语法仍然管用,但是在Python3 里
面是多余的了,因为Python3里所有的字符串都是Unicode字符串.Python3 还引入了一种
新的语法,用于大致表示老式的字符串的字节对象.
</p>
</div>

<ul class="org-ul">
<li><a id="org2b6296f"></a>长字符串<br />
<div class="outline-text-5" id="text-org2b6296f">
<p>
要表示很长的字符串(跨越多行的字符串),可以使用三引号('''like this''')或者三
个双引号("""like this"""). 这让解释器能够识别表示字符串开始和结束的引号,因
此字符串本身可以包含单双引号,无需使用反斜杠进行转义.
</p>
<pre class="example">
&gt;&gt;&gt; print('''This is a very
... long string . It continues here.
... And it's not over yet . "hello,
... world!"
... still here.''')
This is a very
long string . It continues here.
And it's not over yet . "hello,
world!"
still here.
&gt;&gt;&gt;
</pre>
<p>
常规字符串也可以横跨多行.只要在行尾加上反斜杠,反斜杠和换行符将会被转义,即被
忽略.例如:
</p>
<pre class="example">
&gt;&gt;&gt; print("hello\
... ,world!")
hello,world!
&gt;&gt;&gt;
</pre>
<p>
这种写法也适用于表达式和语句.
这种写法的具体文档在 <a href="https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#explicit-line-joining">显式拼接行</a>
</p>
</div>
</li>

<li><a id="org5c0da6f"></a>原始字符串<br />
<div class="outline-text-5" id="text-org5c0da6f">
<p>
原始字符串不以特殊的方式处理反斜杠,因此,在有些情况下很有用(比如正则表达式).在
常规字符串中,反斜杠扮演着对字符进行转义的作用,能够让字符串包含原本无法包含
的字符.例如,前面使用过的 <code>\n</code> 换行符.
</p>
<pre class="example">
&gt;&gt;&gt; print('Hello,\nworld!')
Hello,
world!
</pre>
<p>
这通常挺好用,但是在某些情况下,字符串中包含 <code>\n</code> 呢,例如 DOS 路径C:\nowhere.
</p>
<pre class="example">
&gt;&gt;&gt; path = 'C:\nowhere'
&gt;&gt;&gt; path
'C:\nowhere'
&gt;&gt;&gt; print(path)
C:
owhere
&gt;&gt;&gt;
</pre>
<p>
打印的结果会出问题,这并不是我们想要的结果.这时可以使用上面讲过的反斜杠来对
反斜杠本身进行转义.
</p>
<pre class="example">
&gt;&gt;&gt; print('C:\\nowhere')
C:\nowhere
&gt;&gt;&gt;
</pre>
<p>
这样可以得到想要的结果,但如过路径很长,就会需要使用大量的反斜杠.这种情况下,
原始字符串就可以派上用场了.原始字符串能让字符串保持原样.
</p>
<pre class="example">
&gt;&gt;&gt; print(r'C:\nowhere')
C:\nowhere
&gt;&gt;&gt;
</pre>
<p>
原始字符串使用前缀 <code>r</code> 来表示.
</p>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: kamisama</p>
<p class="date">Created: 2022-07-02 Sat 14:54</p>
<p class="validation"></p>
</div>
</body>
</html>
