<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-06-25 Sat 17:19 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org mode" />
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org1f4b455">1. Language</a></li>
<li><a href="#org52d3404">2. 多线程(multithread, MT) 编程</a>
<ul>
<li><a href="#org14e85a4">2.1. 简介/动机</a></li>
<li><a href="#org4754d52">2.2. 线程和进程</a>
<ul>
<li><a href="#org11b33a4">2.2.1. 进程</a></li>
<li><a href="#org668ea64">2.2.2. 线程</a></li>
</ul>
</li>
<li><a href="#org34e91a4">2.3. 线程和Python</a>
<ul>
<li><a href="#org82d280d">2.3.1. 全局解释器锁</a></li>
<li><a href="#org46c98e4">2.3.2. 退出线程</a></li>
<li><a href="#org5b3e8e7">2.3.3. 在Python中使用线程</a></li>
<li><a href="#org2a7ad3b">2.3.4. 不使用线程的情况</a></li>
<li><a href="#org1db6643">2.3.5. Python的threading模块</a></li>
</ul>
</li>
<li><a href="#orgbe2c9e8">2.4. thread 模块</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org1f4b455" class="outline-2">
<h2 id="org1f4b455"><span class="section-number-2">1</span> Language</h2>
</div>
<div id="outline-container-org52d3404" class="outline-2">
<h2 id="org52d3404"><span class="section-number-2">2</span> 多线程(multithread, MT) 编程</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org14e85a4" class="outline-3">
<h3 id="org14e85a4"><span class="section-number-3">2.1</span> 简介/动机</h3>
<div class="outline-text-3" id="text-2-1">
<p>
多线程编程出现之前,计算机程序的执行是由单个步骤序列组成的,该序列在主机的 CPU 中
按照同步顺序执行.无论是任务本身需要按照步骤顺序执行,还是整个程序实际上包含多个子
任务,都需要按照这种顺序方式执行.
这种做法是不是不符合逻辑?如果让这些独立的任务同时运行,是不是可以显著提高整个任务
的性能呢?这就是多线程编程.
</p>

<p>
多线程编程对于有一下特点的编程任务而言是非常理想的:
</p>
<ul class="org-ul">
<li>本质上是异步的.</li>
<li>需要多个并发活动.</li>
<li>每个活动的处理顺序可能是不确定的,或者说是随机的,不可预测的.</li>
</ul>


<p>
这种编程任务可以被组织或划分成多个执行流,其中每个执行流都有一个要完成的任务.根据
应用的不同,这些子任务可能需要计算出中间结果,然后合并为最终的输出结果.
</p>

<p>
计算密集型的任务比较容易划分为多个子任务.然后按顺序执行或按多线程方式执行.
</p>

<p>
那种使用单线程处理多个外部输入源的任务就不容易了,如果不使用多线程,要实现这种编程
任务,就要为串行程序使用一个或多个计时器,并实现一个多路复用方案.
一个串行程序需要从每个 I/O 终端通道来检查用户输入;重要的一点是,程序读取 I/O 通道
时是不能阻塞的,因为用户输入到达的时间是不确定的,并且阻塞会妨碍其他 I/O 通道的处
理.因此,串行程序必须使用非阻塞 I/O 或者拥有计时器的阻塞 I/O (保证阻塞只是暂时的).
</p>

<p>
由于串行程序只有唯一的执行线程,因此,它必须兼顾要执行的多个任务,确保其中某个任务
不会占用太多时间,并对用户的响应时间进行合理分配.这种类型的串行程序的使用,往往会
造成非常复杂的控制流,难以维护和理解.
</p>

<p>
使用多线程编程,以及类似 Queue 的共享数据结构,这个编程任务可以规划成几个执行特定
函数的线程:
</p>
<ul class="org-ul">
<li>UserRequestThread: 负责读取客户端输入,该输入可能来自 I/O 通道.程序会创建多个线
程,每个客户端一个,客户端的请求会被放入到队列中.</li>
<li>RequestProcessor: 该线程负责从队列中获取请求并进行处理,为第三个线程提供输出.</li>
<li>RequestThread: 负责向用户输出,将结果传回给用户或者把数据写到本地文件系统或数据
库中.</li>
</ul>


<p>
使用多线程来规划这种编程任务可以降低程序的复杂性,使其更加清晰,高效,简洁.每个线程
的逻辑都不复杂,因为它只有一个要完成的特定作业.比如,UserRequestThread 只需要读取
用户输入,然后把输入数据放到队列里,供后续其他线程处理.每个线程都有其明确的作业,你
只需要设计每类线程做一件事,并把这件事做好就可以了(Unix 哲学?).
</p>
</div>
</div>

<div id="outline-container-org4754d52" class="outline-3">
<h3 id="org4754d52"><span class="section-number-3">2.2</span> 线程和进程</h3>
<div class="outline-text-3" id="text-2-2">
</div>
<div id="outline-container-org11b33a4" class="outline-4">
<h4 id="org11b33a4"><span class="section-number-4">2.2.1</span> 进程</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
程序是存储在磁盘上的可执行文件.只有将其加载到内存中并被操作系统调用,才拥有其生命
期.
进程就是一个执行中的程序.每个进程都有 <span class="underline">自己</span> 的 <span class="underline">地址空间</span>, <span class="underline">内存</span>, <span class="underline">数据栈</span> 以及其他用
于跟踪执行的辅助数据.
</p>

<p>
操作系统管理其上所有进程的执行,并为这些进程合理分配时间.
</p>

<p>
进程也可以通过派生(fork 或 spawn) 新的进程来执行其他任务,不过因为每个新进程也拥
有自己的内存和数据栈等,所以只能采用进程间通信(IPC)的方式共享信息.
</p>
</div>
</div>

<div id="outline-container-org668ea64" class="outline-4">
<h4 id="org668ea64"><span class="section-number-4">2.2.2</span> 线程</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
线程与进程类似,不过他们是在同一进程下执行的,并共享相同的上下文.
可以将线程认为是在一个主进程或"主线程"中并行运行的一些"迷你进程".
</p>

<p>
线程包括开始,执行顺序和结束三部分.他有一个指令指针,用于记录当前运行的上下文.当其
他线程运行时,它可以被抢占(中断)和临时挂起(sleep 睡眠)&#x2013;这种做法叫让步(yielding).
</p>

<p>
一个进程中的各个线程和主线程共享一片数据空间.因此,相比于独立的进程而言,线程间的
信息共享和通信更加容易.线程一般以并发方式执行,而正是由于这种并行和数据共享机制,
使得多任务间的协作成为可能.当然,在单核 CPU 系统中,真正的并发是不可能的,所以线程
的执行实际上是这样规划的:每个线程运行一小会儿,然后让步给其他线程(再次排队等待更
多的 CPU 时间).在整个进程的执行过程中,每个线程执行它自己特定的任务,在必要时和其
他线程进行结果通信.
</p>

<p>
这种共享也是有风险的,如果多个线程访问同一片数据,由于数据访问顺序不同,可能导致结
果不一致.这种情况通常称为 <span class="underline">竞态条件</span> (race condition). 幸运的是,大多数线程库都有一
些同步原语,以允许线程管理器控制执行和访问.
</p>

<p>
另一个需要注意的是,线程无法给予公平的执行时间,因为一些函数会在完成前保持阻塞状态,如
果没有专门为多线程情况进行修改,会导致 CPU 的时间分配向这些贪婪的函数倾斜.
</p>
</div>
</div>
</div>

<div id="outline-container-org34e91a4" class="outline-3">
<h3 id="org34e91a4"><span class="section-number-3">2.3</span> 线程和Python</h3>
<div class="outline-text-3" id="text-2-3">
<p>
这部分讨论如何在Python中使用线程,其中包括全局解释器锁对线程的限制和一个快速的演
示脚本.
</p>
</div>

<div id="outline-container-org82d280d" class="outline-4">
<h4 id="org82d280d"><span class="section-number-4">2.3.1</span> 全局解释器锁</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
Python 代码的执行是由Python 虚拟机(又名解释器主循环)进行控制的.
Python 在设计时是这样考虑的:主循环中只能有一个控制线程在执行,就像单核 CPU 系统中
的多进程一样.内存中可以有许多程序,但是在任意给定的时刻只能有一个程序在运行.同理,
尽管Python 解释器中可以运行多个线程,但是在任意给定时刻只有一个线程会被解释器执行.
</p>

<p>
对于 Python 虚拟机的访问是由 <span class="underline">全局解释器锁</span> (GIL) 控制的. 这个锁就是用来保证同时只
能有一个线程运行的. 在多线程环境中, Python 虚拟机将安按照下面描述的方式执行:
</p>
<ol class="org-ol">
<li>设置GIL</li>
<li>切换进一个线程去执行</li>
<li>执行下面操作之一:
a. 指定数量的字节码指令
b. 线程主动让出控制权(可以调用 time.sleep(0) 来完成.)</li>
<li>把线程设置回睡眠状态(切出线程).</li>
<li>解锁GIL.</li>
<li>重复上述步骤.</li>
</ol>


<p>
当调用外部代码(即, 任意 C/C++ 扩展的内置函数)时,GIL 会保持锁定, 直到函数执行结束
(因为这期间没有Python字节码计数). 编写扩展函数的程序员有能力解锁 GIL, 然而,作为
Python 卡爱抚这,你并不需要担心 Python 代码在这些情况下被锁住.
</p>

<p>
例如,在对于任意面向 I/O 的 Python 程序中(调用了内置的操作系统C代码的程序), GIL
会在 I/O 调用前被释放,以允许其他线程在 I/O 执行时运行. 而对于没有太多 I/O 操作的
代码而言,更倾向于在该线程的整个时间片内始终占用处理器和 GIL.
也就是说, I/O 密集型的 Python 程序要比计算密集型的代码能够更好地利用多线程环境.
</p>

<p>
对源代码,解释器主循环和 GIL 感兴趣,可以看看 <a href="https://github.com/python/cpython/blob/main/Python/ceval.c">Python/ceval.c</a> 文件.
</p>
</div>
</div>

<div id="outline-container-org46c98e4" class="outline-4">
<h4 id="org46c98e4"><span class="section-number-4">2.3.2</span> 退出线程</h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
当一个线程完成函数的执行时,它就会退出.另外,还可以通过调用例如 thread.exit() 之类
的退出函数,或者 sys.exit() 之类的退出Python进程的标准方法,亦或是抛出 SystemExit
异常,来使线程退出. 不过,你不能直接 "终止" 一个线程.
</p>

<p>
下一节会讨论两个线程相关的 Python 模块,不过这两个模块中,不建议使用 thread 模块.
这个建议有很多原因,其中一个最明显的原因是在主线程退出之后,所有其他线程都会在没有
清理的情况下直接退出,而另一个 threading 模块会确保在所有 "重要的" 子线程退出前,
保持整个进程的存活(对于 "重要的" 这个含义的说明,请阅读下面的
<a href="#orge681a96">2.3.5</a> .)
</p>

<p>
主线程应该做一个好的管理者,负责了解每个单独的线程需要执行什么,每个派生的线程需要
哪些数据和参数,这些线程执行完成后会提供什么结果.这样,主线程就可以收集每个线程的
结果,然后汇总成一个有意义的最终结果.
</p>
</div>
</div>

<div id="outline-container-org5b3e8e7" class="outline-4">
<h4 id="org5b3e8e7"><span class="section-number-4">2.3.3</span> 在Python中使用线程</h4>
<div class="outline-text-4" id="text-2-3-3">
<p>
避免使用thread模块
Python 虽然支持多线程编程,但是还需要取决于它运行的操作系统.如下操作系统是支持多
线程的: 绝大多数类 UNIX 平台(Linux, Solris, MacOSX,*BSD 等),以及 Windows 平
台.Python 使用兼容 POSIX 的线程,也就是众所周知的 pthread.
</p>

<p>
默认情况下,从源码构建的 Python(2.0+) 或者 win32 二进制安装的 Python, 线程支持是
已经启用的. 要确定解释器是否支持线程,只需要在交互式解释器中尝试导入 thread 模块
即可,如果线程是可用的,则不会产生错误:
</p>
<pre class="example">
&gt;&gt;&gt; import _thread
&gt;&gt;&gt;
</pre>
<p>
我用的是 Python3 所以导入 _thread 模块,更多信息参考 <a href="#orge681a96">2.3.5</a>
如果你的 Python 解释器没有将线程支持编译进去,模块导入将会失败:
</p>
<pre class="example">
&gt;&gt;&gt; import thread
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ModuleNotFoundError: No module named 'thread'
&gt;&gt;&gt;
</pre>

<p>
如果是解释器不支持,那么你可能需要重新编译你的 Python 解释器才能够使用线程. 一般
可以在调用 configure 脚本的时候使用 &#x2013;with-thread 选项.查阅你所用发行版本的
README 文件,来获取如何在系统中编译线程支持的 Python 的指定指令.
</p>
</div>
</div>

<div id="outline-container-org2a7ad3b" class="outline-4">
<h4 id="org2a7ad3b"><span class="section-number-4">2.3.4</span> 不使用线程的情况</h4>
<div class="outline-text-4" id="text-2-3-4">
<p>
在第一个例子里,我们使用 time.sleep() 函数来演示线程是如何工作的. time.sleep() 函
数需要一个浮点型的参数,然后以这个给定的秒数进行"睡眠",也就是说,程序的执行会暂停
指定的时间.
</p>

<p>
创建两个时间循环:一个睡眠4秒(loop0()); 另一个睡眠2秒(loop1())(这里使用
"loop0","loop1" 作为函数名,暗示我们最终会有一个循环序列).
</p>

<p>
如果在一个单进程或单线程的程序中顺序执行 loop0() 和 loop1(), 就会像下面的
onethr.py 一样,整个执行时间至少会达到6秒钟.而在启动 loop0() 和 loop1() 以及执行
其他代码时,也可能存在1秒的开销,使整个时间达到7秒.
</p>

<ul class="org-ul">
<li><p>
onethr.py:
该脚本在一个单线程程序里连续执行两个循环.一个循环必须在另一个开始前完成,总共消
耗的时间是每个循环所用的时间之和.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">from</span> time <span style="font-weight: bold;">import</span> sleep, ctime

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">loop0</span>():
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'start loop 0 at:'</span>, ctime())
    sleep(4)
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'loop 0 done at:'</span>, ctime())


<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">loop1</span>():
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'start loop 1 at:'</span>, ctime())
    sleep(2)
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'loop 1 done at:'</span>, ctime())


<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">main</span>():
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'starting at:'</span>, ctime())
    loop0()
    loop1()
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'all Done at:'</span>, ctime())


<span style="font-weight: bold;">if</span> <span style="font-weight: bold;">__name__</span> == <span style="font-style: italic;">'__main__'</span>:
    main()
</pre>
</div>

<p>
现在假设 loop0() 和 loop1() 中的操作不是睡眠,而是执行独立计算操作的函数,所有结
果汇总成一个最终结果,那么,让他们并行执行来减少总的执行时间是不是有用的呢? 这就
是现在要介绍的多线程编程的前提.
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org1db6643" class="outline-4">
<h4 id="org1db6643"><span class="section-number-4">2.3.5</span> Python的threading模块</h4>
<div class="outline-text-4" id="text-2-3-5">
<p>
<a id="orge681a96"></a>
推荐使用更高级别的 threading 模块,而不是使用 thread 模块有很多原因.
threading 模块更加先进,有更好的线程支持,并且 thread 模块中的一些属性会和
threading 模块有冲突. 另一个原因就是低级别的 thread 模块拥有的同步原语很少(实际
上只有一个), 而 threading 模块则有很多.
</p>

<p>
避免使用 thread 模块的另一个原因是它对于进程何时退出没有控制. 当主线程结束时,所
有其他线程也都强制结束, 不会发出警告或者进行适当的清理.如前所述,至少 threading
模块能确保重要的子线程在进程退出前结束.
</p>

<p>
我们只建议那些想访问线程的更底层级别的专家使用 thread 模块.为了强调这一点,
Python3 中该模块被重命名为 _thread. 你创建的任何多线程应用都应该使用 threading
模块或者其他更高级别的模块.
</p>
</div>
</div>
</div>

<div id="outline-container-orgbe2c9e8" class="outline-3">
<h3 id="orgbe2c9e8"><span class="section-number-3">2.4</span> thread 模块</h3>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2022-06-25 Sat 17:19</p>
<p class="validation"></p>
</div>
</body>
</html>
