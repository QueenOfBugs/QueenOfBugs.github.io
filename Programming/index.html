<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-06-05 Mon 08:33 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org mode" />
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org3ee545d">1. Language</a></li>
<li><a href="#org45605b6">2. 多线程(multithread, MT) 编程</a>
<ul>
<li><a href="#orgc15b9e2">2.1. 简介/动机</a></li>
<li><a href="#orgcd08bb8">2.2. 线程和进程</a>
<ul>
<li><a href="#orge746e9e">2.2.1. 进程</a></li>
<li><a href="#orgf6d9625">2.2.2. 线程</a></li>
</ul>
</li>
<li><a href="#org80e4bb7">2.3. 线程和Python</a>
<ul>
<li><a href="#org12725bc">2.3.1. 全局解释器锁</a></li>
<li><a href="#orgffdd655">2.3.2. 退出线程</a></li>
<li><a href="#org923d6cc">2.3.3. 在Python中使用线程</a></li>
<li><a href="#org4f7c51d">2.3.4. 不使用线程的情况</a></li>
<li><a href="#orgbf3346a">2.3.5. Python的threading模块</a></li>
</ul>
</li>
<li><a href="#org46e748e">2.4. thread 模块</a></li>
<li><a href="#orgd416a8b">2.5. threading 模块</a>
<ul>
<li><a href="#org8c407f3">2.5.1. Thread 类</a></li>
<li><a href="#orge542c93">2.5.2. threading 模块的其他函数</a></li>
</ul>
</li>
<li><a href="#orga69531d">2.6. 单线程或多线程执行对比</a></li>
<li><a href="#org9116e0b">2.7. 多线程实践</a>
<ul>
<li><a href="#orge8d7f20">2.7.1. 图书排名示例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org968d539">3. 相关概念</a></li>
</ul>
</div>
</div>
<div id="outline-container-org3ee545d" class="outline-2">
<h2 id="org3ee545d"><span class="section-number-2">1</span> Language</h2>
</div>
<div id="outline-container-org45605b6" class="outline-2">
<h2 id="org45605b6"><span class="section-number-2">2</span> 多线程(multithread, MT) 编程</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgc15b9e2" class="outline-3">
<h3 id="orgc15b9e2"><span class="section-number-3">2.1</span> 简介/动机</h3>
<div class="outline-text-3" id="text-2-1">
<p>
多线程编程出现之前,计算机程序的执行是由单个步骤序列组成的,该序列在主机的 CPU 中
按照同步顺序执行.无论是任务本身需要按照步骤顺序执行,还是整个程序实际上包含多个子
任务,都需要按照这种顺序方式执行.
这种做法是不是不符合逻辑?如果让这些独立的任务同时运行,是不是可以显著提高整个任务
的性能呢?这就是多线程编程.
</p>

<p>
多线程编程对于有一下特点的编程任务而言是非常理想的:
</p>
<ul class="org-ul">
<li>本质上是异步的.</li>
<li>需要多个并发活动.</li>
<li>每个活动的处理顺序可能是不确定的,或者说是随机的,不可预测的.</li>
</ul>


<p>
这种编程任务可以被组织或划分成多个执行流,其中每个执行流都有一个要完成的任务.根据
应用的不同,这些子任务可能需要计算出中间结果,然后合并为最终的输出结果.
</p>

<p>
计算密集型的任务比较容易划分为多个子任务.然后按顺序执行或按多线程方式执行.
</p>

<p>
那种使用单线程处理多个外部输入源的任务就不容易了,如果不使用多线程,要实现这种编程
任务,就要为串行程序使用一个或多个计时器,并实现一个多路复用方案.
一个串行程序需要从每个 I/O 终端通道来检查用户输入;重要的一点是,程序读取 I/O 通道
时是不能阻塞的,因为用户输入到达的时间是不确定的,并且阻塞会妨碍其他 I/O 通道的处
理.因此,串行程序必须使用非阻塞 I/O 或者拥有计时器的阻塞 I/O (保证阻塞只是暂时的).
</p>

<p>
由于串行程序只有唯一的执行线程,因此,它必须兼顾要执行的多个任务,确保其中某个任务
不会占用太多时间,并对用户的响应时间进行合理分配.这种类型的串行程序的使用,往往会
造成非常复杂的控制流,难以维护和理解.
</p>

<p>
使用多线程编程,以及类似 Queue 的共享数据结构,这个编程任务可以规划成几个执行特定
函数的线程:
</p>
<ul class="org-ul">
<li>UserRequestThread: 负责读取客户端输入,该输入可能来自 I/O 通道.程序会创建多个线
程,每个客户端一个,客户端的请求会被放入到队列中.</li>
<li>RequestProcessor: 该线程负责从队列中获取请求并进行处理,为第三个线程提供输出.</li>
<li>RequestThread: 负责向用户输出,将结果传回给用户或者把数据写到本地文件系统或数据
库中.</li>
</ul>


<p>
使用多线程来规划这种编程任务可以降低程序的复杂性,使其更加清晰,高效,简洁.每个线程
的逻辑都不复杂,因为它只有一个要完成的特定作业.比如,UserRequestThread 只需要读取
用户输入,然后把输入数据放到队列里,供后续其他线程处理.每个线程都有其明确的作业,你
只需要设计每类线程做一件事,并把这件事做好就可以了(Unix 哲学?).
</p>
</div>
</div>

<div id="outline-container-orgcd08bb8" class="outline-3">
<h3 id="orgcd08bb8"><span class="section-number-3">2.2</span> 线程和进程</h3>
<div class="outline-text-3" id="text-2-2">
</div>
<div id="outline-container-orge746e9e" class="outline-4">
<h4 id="orge746e9e"><span class="section-number-4">2.2.1</span> 进程</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
程序是存储在磁盘上的可执行文件.只有将其加载到内存中并被操作系统调用,才拥有其生命
期.
进程就是一个执行中的程序.每个进程都有 <span class="underline">自己</span> 的 <span class="underline">地址空间</span>, <span class="underline">内存</span>, <span class="underline">数据栈</span> 以及其他用
于跟踪执行的辅助数据.
</p>

<p>
操作系统管理其上所有进程的执行,并为这些进程合理分配时间.
</p>

<p>
进程也可以通过派生(fork 或 spawn) 新的进程来执行其他任务,不过因为每个新进程也拥
有自己的内存和数据栈等,所以只能采用进程间通信(IPC)的方式共享信息.
</p>
</div>
</div>

<div id="outline-container-orgf6d9625" class="outline-4">
<h4 id="orgf6d9625"><span class="section-number-4">2.2.2</span> 线程</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
线程与进程类似,不过他们是在同一进程下执行的,并共享相同的上下文.
可以将线程认为是在一个主进程或"主线程"中并行运行的一些"迷你进程".
</p>

<p>
线程包括开始,执行顺序和结束三部分.他有一个指令指针,用于记录当前运行的上下文.当其
他线程运行时,它可以被抢占(中断)和临时挂起(sleep 睡眠)&#x2013;这种做法叫让步(yielding).
</p>

<p>
一个进程中的各个线程和主线程共享一片数据空间.因此,相比于独立的进程而言,线程间的
信息共享和通信更加容易.线程一般以并发方式执行,而正是由于这种并行和数据共享机制,
使得多任务间的协作成为可能.当然,在单核 CPU 系统中,真正的并发是不可能的,所以线程
的执行实际上是这样规划的:每个线程运行一小会儿,然后让步给其他线程(再次排队等待更
多的 CPU 时间).在整个进程的执行过程中,每个线程执行它自己特定的任务,在必要时和其
他线程进行结果通信.
</p>

<p>
这种共享也是有风险的,如果多个线程访问同一片数据,由于数据访问顺序不同,可能导致结
果不一致.这种情况通常称为 <span class="underline">竞态条件</span> (race condition). 幸运的是,大多数线程库都有一
些同步原语,以允许线程管理器控制执行和访问.
</p>

<p>
另一个需要注意的是,线程无法给予公平的执行时间,因为一些函数会在完成前保持阻塞状态,如
果没有专门为多线程情况进行修改,会导致 CPU 的时间分配向这些贪婪的函数倾斜.
</p>
</div>
</div>
</div>

<div id="outline-container-org80e4bb7" class="outline-3">
<h3 id="org80e4bb7"><span class="section-number-3">2.3</span> 线程和Python</h3>
<div class="outline-text-3" id="text-2-3">
<p>
这部分讨论如何在Python中使用线程,其中包括全局解释器锁对线程的限制和一个快速的演
示脚本.
</p>
</div>

<div id="outline-container-org12725bc" class="outline-4">
<h4 id="org12725bc"><span class="section-number-4">2.3.1</span> 全局解释器锁</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
Python 代码的执行是由Python 虚拟机(又名解释器主循环)进行控制的.
Python 在设计时是这样考虑的:主循环中只能有一个控制线程在执行,就像单核 CPU 系统中
的多进程一样.内存中可以有许多程序,但是在任意给定的时刻只能有一个程序在运行.同理,
尽管Python 解释器中可以运行多个线程,但是在任意给定时刻只有一个线程会被解释器执行.
</p>

<p>
对于 Python 虚拟机的访问是由 <span class="underline">全局解释器锁</span> (GIL) 控制的. 这个锁就是用来保证同时只
能有一个线程运行的. 在多线程环境中, Python 虚拟机将安按照下面描述的方式执行:
</p>
<ol class="org-ol">
<li>设置GIL</li>
<li>切换进一个线程去执行</li>
<li>执行下面操作之一:
a. 指定数量的字节码指令
b. 线程主动让出控制权(可以调用 time.sleep(0) 来完成.)</li>
<li>把线程设置回睡眠状态(切出线程).</li>
<li>解锁GIL.</li>
<li>重复上述步骤.</li>
</ol>


<p>
当调用外部代码(即, 任意 C/C++ 扩展的内置函数)时,GIL 会保持锁定, 直到函数执行结束
(因为这期间没有Python字节码计数). 编写扩展函数的程序员有能力解锁 GIL, 然而,作为
Python 卡爱抚这,你并不需要担心 Python 代码在这些情况下被锁住.
</p>

<p>
例如,在对于任意面向 I/O 的 Python 程序中(调用了内置的操作系统C代码的程序), GIL
会在 I/O 调用前被释放,以允许其他线程在 I/O 执行时运行. 而对于没有太多 I/O 操作的
代码而言,更倾向于在该线程的整个时间片内始终占用处理器和 GIL.
也就是说, I/O 密集型的 Python 程序要比计算密集型的代码能够更好地利用多线程环境.
</p>

<p>
对源代码,解释器主循环和 GIL 感兴趣,可以看看 <a href="https://github.com/python/cpython/blob/main/Python/ceval.c">Python/ceval.c</a> 文件.
</p>
</div>
</div>

<div id="outline-container-orgffdd655" class="outline-4">
<h4 id="orgffdd655"><span class="section-number-4">2.3.2</span> 退出线程</h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
当一个线程完成函数的执行时,它就会退出.另外,还可以通过调用例如 thread.exit() 之类
的退出函数,或者 sys.exit() 之类的退出Python进程的标准方法,亦或是抛出 SystemExit
异常,来使线程退出. 不过,你不能直接 "终止" 一个线程.
</p>

<p>
下一节会讨论两个线程相关的 Python 模块,不过这两个模块中,不建议使用 thread 模块.
这个建议有很多原因,其中一个最明显的原因是在主线程退出之后,所有其他线程都会在没有
清理的情况下直接退出,而另一个 threading 模块会确保在所有 "重要的" 子线程退出前,
保持整个进程的存活(对于 "重要的" 这个含义的说明,请阅读下面的
<a href="#org551d69c">2.3.5</a> .)
</p>

<p>
主线程应该做一个好的管理者,负责了解每个单独的线程需要执行什么,每个派生的线程需要
哪些数据和参数,这些线程执行完成后会提供什么结果.这样,主线程就可以收集每个线程的
结果,然后汇总成一个有意义的最终结果.
</p>
</div>
</div>

<div id="outline-container-org923d6cc" class="outline-4">
<h4 id="org923d6cc"><span class="section-number-4">2.3.3</span> 在Python中使用线程</h4>
<div class="outline-text-4" id="text-2-3-3">
<p>
避免使用thread模块
Python 虽然支持多线程编程,但是还需要取决于它运行的操作系统.如下操作系统是支持多
线程的: 绝大多数类 UNIX 平台(Linux, Solris, MacOSX,*BSD 等),以及 Windows 平
台.Python 使用兼容 POSIX 的线程,也就是众所周知的 pthread.
</p>

<p>
默认情况下,从源码构建的 Python(2.0+) 或者 win32 二进制安装的 Python, 线程支持是
已经启用的. 要确定解释器是否支持线程,只需要在交互式解释器中尝试导入 thread 模块
即可,如果线程是可用的,则不会产生错误:
</p>
<pre class="example">
&gt;&gt;&gt; import _thread
&gt;&gt;&gt;
</pre>
<p>
我用的是 Python3 所以导入 _thread 模块,更多信息参考 <a href="#org551d69c">2.3.5</a>
如果你的 Python 解释器没有将线程支持编译进去,模块导入将会失败:
</p>
<pre class="example">
&gt;&gt;&gt; import thread
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ModuleNotFoundError: No module named 'thread'
&gt;&gt;&gt;
</pre>

<p>
如果是解释器不支持,那么你可能需要重新编译你的 Python 解释器才能够使用线程. 一般
可以在调用 configure 脚本的时候使用 &#x2013;with-thread 选项.查阅你所用发行版本的
README 文件,来获取如何在系统中编译线程支持的 Python 的指定指令.
</p>
</div>
</div>

<div id="outline-container-org4f7c51d" class="outline-4">
<h4 id="org4f7c51d"><span class="section-number-4">2.3.4</span> 不使用线程的情况</h4>
<div class="outline-text-4" id="text-2-3-4">
<p>
在第一个例子里,我们使用 time.sleep() 函数来演示线程是如何工作的. time.sleep() 函
数需要一个浮点型的参数,然后以这个给定的秒数进行"睡眠",也就是说,程序的执行会暂停
指定的时间.
</p>

<p>
创建两个时间循环:一个睡眠4秒(loop0()); 另一个睡眠2秒(loop1())(这里使用
"loop0","loop1" 作为函数名,暗示我们最终会有一个循环序列).
</p>

<p>
如果在一个单进程或单线程的程序中顺序执行 loop0() 和 loop1(), 就会像下面的
onethr.py 一样,整个执行时间至少会达到6秒钟.而在启动 loop0() 和 loop1() 以及执行
其他代码时,也可能存在1秒的开销,使整个时间达到7秒.
</p>

<ul class="org-ul">
<li><p>
onethr.py:
该脚本在一个单线程程序里连续执行两个循环.一个循环必须在另一个开始前完成,总共消
耗的时间是每个循环所用的时间之和.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">from</span> time <span style="font-weight: bold;">import</span> sleep, ctime

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">loop0</span>():
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'start loop 0 at:'</span>, ctime())
    sleep(4)
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'loop 0 done at:'</span>, ctime())


<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">loop1</span>():
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'start loop 1 at:'</span>, ctime())
    sleep(2)
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'loop 1 done at:'</span>, ctime())


<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">main</span>():
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'starting at:'</span>, ctime())
    loop0()
    loop1()
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'all Done at:'</span>, ctime())


<span style="font-weight: bold;">if</span> <span style="font-weight: bold;">__name__</span> == <span style="font-style: italic;">'__main__'</span>:
    main()
</pre>
</div>

<p>
现在假设 loop0() 和 loop1() 中的操作不是睡眠,而是执行独立计算操作的函数,所有结
果汇总成一个最终结果,那么,让他们并行执行来减少总的执行时间是不是有用的呢? 这就
是现在要介绍的多线程编程的前提.
</p></li>
</ul>
</div>
</div>

<div id="outline-container-orgbf3346a" class="outline-4">
<h4 id="orgbf3346a"><span class="section-number-4">2.3.5</span> Python的threading模块</h4>
<div class="outline-text-4" id="text-2-3-5">
<p>
Python 提供了多个模块来支持多线程编程,包括 thread, threading 和 Queue 模块等.程
序可以使用 thread 和 threading 模块开创建和管理线程. thread 模块提供了基本的线程
和锁定支持; 而 threading 模块提供了更高级别功能,功能更齐全的线程管理. Queue 模块,可
以创建一个队列数据结构,用于在多线程之间进行共享. 我们会分别查看这几个模块,并给出
几个例子和中等规模的应用.
</p>

<p>
<a id="org551d69c"></a>
推荐使用更高级别的 threading 模块,而不是使用 thread 模块有很多原因.
threading 模块更加先进,有更好的线程支持,并且 thread 模块中的一些属性会和
threading 模块有冲突. 另一个原因就是低级别的 thread 模块拥有的同步原语很少(实际
上只有一个), 而 threading 模块则有很多.
</p>

<p>
避免使用 thread 模块的另一个原因是它对于进程何时退出没有控制. 当主线程结束时,所
有其他线程也都强制结束, 不会发出警告或者进行适当的清理.如前所述,至少 threading
模块能确保重要的子线程在进程退出前结束.
</p>

<p>
我们只建议那些想访问线程的更底层级别的专家使用 thread 模块.为了强调这一点,
Python3 中该模块被重命名为 _thread. 你创建的任何多线程应用都应该使用 threading
模块或者其他更高级别的模块.
</p>

<p>
处于对 Python 的学习和线程的学习,我们会给出使用 thread 模块的一些代码.这些代码只
是出于学习目的,希望能更好的领悟为什么应该避免使用 thread 模块. 还将展示如何使用
更加合适的工具,如 threading 和 Queue 模块中的那些方法.
</p>
</div>
</div>
</div>

<div id="outline-container-org46e748e" class="outline-3">
<h3 id="org46e748e"><span class="section-number-3">2.4</span> thread 模块</h3>
<div class="outline-text-3" id="text-2-4">
<p>
除了派生线程外, thread 模块还提供了基本的同步数据结构,称为 <span class="underline">锁对象</span> (lock object,
也叫原语锁,简单锁,互斥锁,互斥和二进制信号量). 如前所述,这个同步原语和线程管理是
密切相关的.
</p>

<p>
thread 模块的核心函数是 start<sub>new</sub><sub>thread</sub>(). 他的参数包括函数(对象),函数的参数以
及可选的关键字参数.将专门派生新的线程来调用这个函数.
下面列出了一些常用的线程函数,以及 LockType 锁对象的方法.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">函数/方法</td>
<td class="org-left">描述</td>
</tr>

<tr>
<td class="org-left"><b>thread 模块的函数</b></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">start<sub>new</sub><sub>thread</sub>(function, args, kwars=None)</td>
<td class="org-left">派生一个新的线程,使用给定的 args 和可选的 kwargs 来执行 function</td>
</tr>

<tr>
<td class="org-left">allocate<sub>lock</sub>()</td>
<td class="org-left">分配 LockType 对象</td>
</tr>

<tr>
<td class="org-left">exit()</td>
<td class="org-left">给线程退出命令</td>
</tr>

<tr>
<td class="org-left"><b>LockType 锁对象的方法</b></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">acquire(wait=None)</td>
<td class="org-left">尝试获取锁对象</td>
</tr>

<tr>
<td class="org-left">locked()</td>
<td class="org-left">如果获取了锁对象则返回 True, 否则,返回 False</td>
</tr>

<tr>
<td class="org-left">release()</td>
<td class="org-left">释放锁</td>
</tr>
</tbody>
</table>

<p>
把多线程整合进 onethr.py 这个例子里. 把对 loop*() 函数的调用稍微改变一下,得到下
面 mtsleepA.py 文件.
</p>

<p>
<b>mtsleepA.py</b>
这里执行的循环和 onethr.py 是一样的,不过这次使用了 thread 模块提供的简单多线程机
制.两个循环是并发执行的(很明显,短的先结束),因此总的运行时间只与最慢的线程相关,而
不是每个线程运行时间之和.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> _thread
<span style="font-weight: bold;">from</span> time <span style="font-weight: bold;">import</span> sleep, ctime

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">loop0</span>():
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'start loop 0 at:'</span>, ctime())
    sleep(4)
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'loop 0 done at:'</span>, ctime())

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">loop1</span>():
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'start loop 1 at:'</span>, ctime())
    sleep(2)
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'loop 1 done at:'</span>, ctime())


<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">main</span>():
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'starting at:'</span>, ctime())
    _thread.start_new_thread(loop0, ())
    _thread.start_new_thread(loop1, ())
    sleep(6)
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'all Done at:'</span>, ctime())

<span style="font-weight: bold;">if</span> <span style="font-weight: bold;">__name__</span> == <span style="font-style: italic;">'__main__'</span>:
    main()
</pre>
</div>

<p>
start<sub>new</sub><sub>thread</sub>() 必须包含开始的两个参数,于是即使要执行的函数不需要参数,也需要
传递一个空元组.
</p>

<p>
与之前的代码比,这个程序执行的输出结果有很大不同.原来需要6-7秒的时间，而现在只需
要运行4秒,也就是最常的循环加上其他开销的时间之和.
</p>

<p>
这里面的睡眠4秒和2秒的代码片段是并发执行的,这样有助于减少整体的运行时间.从输出里
可以看到,loop1 是在 loop0 之前结束的.
这个程序中最主要的区别是增加了一个 sleep(6) 调用. 为什么要这样做呢? 前面说过
thread 模块对进程何时退出没有控制,如果不让主线程等待子线程全部完成,那它将继续执
行下一条语句,显示 "all done" ,然后直接退出, loop0() 和 loop1() 这两个线程会直接
终止:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> _thread
<span style="font-weight: bold;">from</span> time <span style="font-weight: bold;">import</span> sleep, ctime

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">loop0</span>():
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'start loop 0 at:'</span>, ctime())
    sleep(4)
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'loop 0 done at:'</span>, ctime())

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">loop1</span>():
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'start loop 1 at:'</span>, ctime())
    sleep(2)
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'loop 1 done at:'</span>, ctime())


<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">main</span>():
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'starting at:'</span>, ctime())
    _thread.start_new_thread(loop0, ())
    _thread.start_new_thread(loop1, ())
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'all Done at:'</span>, ctime())

<span style="font-weight: bold;">if</span> <span style="font-weight: bold;">__name__</span> == <span style="font-style: italic;">'__main__'</span>:
    main()
</pre>
</div>

<p>
上面去掉主线程等待的 sleep(6) 之后再多次执行的代码输出结果,可以看到,派生出的子线
程甚至没能执行到打印语句就已经由于主线程退出而直接终止了,多次执行可以观察到由于
操作系统调度的原因,两个线程执行顺序会有先后,有时能看到两个循环的打印,有时只能看
到一个循环的打印,但都在没有完成时就直接终止了.
</p>

<p>
我们没有写让主线程等待子线程全部完成之后在继续的代码,即我们所说的线程需要某种形
式的同步.
</p>

<p>
这上面的例子就是使用 sleep() 来作为同步机制,将其设置为 6s 是因为我们知道所有线程
会在主线程计时到 6s 之前完成.
</p>

<p>
你可能会想到,肯定有比在主线程中额外延时6s 更好的线程管理方式. 由于这个延时,整个
程序的运行时间没有比单线程的版本更快.像这样使用 sleep() 来进行线程同步是不可靠的.
如果循环有独立且不同的执行时间怎么办?我们可能会过早或过晚退出主线程. 这就是我们
引出锁的原因.
</p>

<p>
再次修改代码,引出锁,并去除单独的循环函数,修改后的代码为 mtsleepB.py, 如下所示:
<b>mtsleepB.oy</b>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> _thread
<span style="font-weight: bold;">from</span> time <span style="font-weight: bold;">import</span> ctime, sleep
<span style="font-weight: bold; font-style: italic;">loops</span> = [4, 2]

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">loop</span>(nloop, nsec, lock):
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'start loop,'</span>, nloop, <span style="font-style: italic;">'at:'</span>, ctime())
    sleep(nsec)
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'loop'</span>, nloop, <span style="font-style: italic;">'done at:'</span>, ctime())
    lock.release()
<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">main</span>():
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'starting at:'</span>, ctime())
    <span style="font-weight: bold; font-style: italic;">locks</span> = []
    <span style="font-weight: bold; font-style: italic;">nloops</span> = <span style="font-weight: bold;">range</span>(<span style="font-weight: bold;">len</span>(loops))
    <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> nloops:
        <span style="font-weight: bold; font-style: italic;">lock</span> = _thread.allocate_lock()
        lock.acquire()
        locks.append(lock)
    <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> nloops:
        _thread.start_new_thread(loop, (i, loops[i], locks[i]))
    <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> nloops:
        <span style="font-weight: bold;">while</span> locks[i].locked(): <span style="font-weight: bold;">pass</span>
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'all done at:'</span>, ctime())


<span style="font-weight: bold;">if</span> <span style="font-weight: bold;">__name__</span> == <span style="font-style: italic;">'__main__'</span>:
    main()
</pre>
</div>

<p>
allocate<sub>lock</sub>() 创建的锁对象,初始状态是解锁状态, acquire() 申请获得锁对象,获得锁
操作相当于"把锁锁上",上锁后,就可以添加到锁列表中了.上锁后就表示该锁已被"使用"了.而
release() 方法则表明获取该锁的线程已经完成. 没有在上锁的循环里立即启动线程有两个
原因:
</p>
<ol class="org-ol">
<li>我们要同步线程,以便"所有马同时冲出围栏"</li>
<li>获取锁需要时间,如果线程执行太快,可能会出现获取锁之前线程就执行结束的情况.</li>
</ol>


<p>
每个线程执行完成时,都会释放自己的锁对象. 最后一个循环就是等待(暂停主线程,而不是
让他直接结束),直到所有锁都被释放才会继续执行.
</p>
<blockquote>
<p>
锁机制的实现,锁的目的是为了实现同步,保证同一时间只有一个线程在使用某一资源,本质
上就是一个flag 变量,为1表示未上锁,为0表示上锁,当线程A访问flag 时,发现它为1,表示
可以使用该资源,并准备将flag 设置为0.但与此同时线程B 也访问 flag ,发现它为1(线程A
设置 flag 的操作并未完成),此时就会冲突,所以锁的操作需要有 <span class="underline">原子性</span> ,即锁的访问和设
置要么全部执行,要么都不执行;并且同一时间应只有一个线程能访问锁(具体实现暂且不管).
</p>
</blockquote>

<p>
正如前面提示的,这里使用 thread 模块只是为了介绍多线程编程. 多线程应用程序应当使
用更高级别的模块.比如下面的 threading 模块.
</p>
</div>
</div>

<div id="outline-container-orgd416a8b" class="outline-3">
<h3 id="orgd416a8b"><span class="section-number-3">2.5</span> threading 模块</h3>
<div class="outline-text-3" id="text-2-5">
<p>
现在介绍更高级别的 threading 模块. 除了 Thread 类外,该模块还包括许多非常好用的同
步机制.下面给出 threading 模块中所有可用对象的列表.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">对象</td>
<td class="org-left">描述</td>
</tr>

<tr>
<td class="org-left">Thread</td>
<td class="org-left">表示一个执行线程的对象</td>
</tr>

<tr>
<td class="org-left">Lock</td>
<td class="org-left">锁原语对象(和 _thread 模块中的锁一样)</td>
</tr>

<tr>
<td class="org-left">RLock</td>
<td class="org-left">可重入锁对象,是单一线程可以再次获得以持有的锁(递归锁)</td>
</tr>

<tr>
<td class="org-left">Condition</td>
<td class="org-left">条件变量对象,使得一个线程等待另一个线程满足特定的"条件",比如改变状态或某个数据值</td>
</tr>

<tr>
<td class="org-left">Event</td>
<td class="org-left">条件变量的通用版本,任意数量的线程等待某个事件的发生,在该事件发生后所有线程将被激活</td>
</tr>

<tr>
<td class="org-left">Semaphore</td>
<td class="org-left">信号量,为线程间共享的有限资源提供了一个"计数器",如果没有可用资源时会被阻塞</td>
</tr>

<tr>
<td class="org-left">BoundedSemaphore</td>
<td class="org-left">与 Semaphore 相似,不过它不允许超过初始值</td>
</tr>

<tr>
<td class="org-left">Timer</td>
<td class="org-left">与 Thread 相似,不过它要在运行前等待一段时间</td>
</tr>

<tr>
<td class="org-left">Barrier</td>
<td class="org-left">创建一个"障碍",必须达到指定数量的线程后才可以继续</td>
</tr>
</tbody>
</table>

<p>
核心提示: 守护线程
避免使用 thread 模块的另一个原因是该模块不支持守护线程这个概念. 当主线程退出时,
所有子线程都将终止,不管他们是否仍在工作.如果你不希望发生这种行为就要引入守护线程
的概念了.
</p>

<p>
threading 模块支持守护线程,其工作方式是:守护线程一般是一个等待客户端请求的服务器.如
果没有客户端请求,守护线程就是空闲的,如果将一个线程设置为守护线程,就意味着这个线
程是不重要的,进程退出时不用等待这个线程执行完成.
</p>

<p>
如果主线程准备退出时,不需要等待某些线程完成,就可以为这些子线程设置守护线程标记.该
标记为真时表示该线程能够不重要,或者说该线程只是用来等待客户端请求而不做任何其他
事情.
</p>

<p>
要将一个线程设置为守护线程,需要在启动线程之前执行: <code>thread.daemon = True</code> (旧的方
法为 thread.setDaemon(True)). 同样,要检查线程的守护状态,也只需要检查这个值即可
(对应的旧方法为 thread.isDaemon). 一个新的子线程会继承父线程的守护标记. 整个
Python 程序(理解为主线程)将在所有非守护线程退出后才退出,换句话说,就是没有剩下存
活的非守护进程时.
</p>
</div>

<div id="outline-container-org8c407f3" class="outline-4">
<h4 id="org8c407f3"><span class="section-number-4">2.5.1</span> Thread 类</h4>
<div class="outline-text-4" id="text-2-5-1">
<p>
threading 模块的 Thread 类是主要的执行对象. 它有 thread 模块中没有的很多函数.
</p>

<p>
下面给出它的属性和方法列表:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">属性</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Thread 对象数据属性</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">name</td>
<td class="org-left">线程名</td>
</tr>

<tr>
<td class="org-left">ident</td>
<td class="org-left">线程的标识符</td>
</tr>

<tr>
<td class="org-left">daemon</td>
<td class="org-left">布尔标志,表示这个线程是否为守护线程</td>
</tr>

<tr>
<td class="org-left">Thread 对象方法</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">_<sub>init</sub>_<sub>(group=None, target=None, name=None, args=(), kwargs={}, verbose=None, daemon=None)</sub></td>
<td class="org-left">实例化一个线程对象,需要有一个可调用的 target, 以及其参数 args 或 kwargs, 还可以传递 name 或 group 参数,不过后者还未实现,此外,verbose 标志也是可以接受的, 而 daemon 的值将会设置 thread.daemon 属性/标志</td>
</tr>

<tr>
<td class="org-left">start()</td>
<td class="org-left">开始执行该线程</td>
</tr>

<tr>
<td class="org-left">run()</td>
<td class="org-left">定义线程功能的方法(通常在子类中被应用开发者重写)</td>
</tr>

<tr>
<td class="org-left">join(timeout=None)</td>
<td class="org-left">直至启动的线程终止之前一直挂起,除非给出了 timeout(秒),否则会一直阻塞</td>
</tr>

<tr>
<td class="org-left">getName()</td>
<td class="org-left">返回线程名</td>
</tr>

<tr>
<td class="org-left">setName()</td>
<td class="org-left">设定线程名</td>
</tr>

<tr>
<td class="org-left">isAlive/is<sub>alive</sub>()</td>
<td class="org-left">布尔标志,表示线程是否还存活</td>
</tr>

<tr>
<td class="org-left">isDaemon()</td>
<td class="org-left">如果是守护线程则返回 True, 否则返回 False</td>
</tr>

<tr>
<td class="org-left">setDaemon(daemonic)</td>
<td class="org-left">把线程的守护标志设置为布尔值 daemonic( 必须在线程 start() 之前调用)</td>
</tr>
</tbody>
</table>

<blockquote>
<p>
注意: getName, setName, isAlive/is<sub>alive</sub>, isDaemon, setDaemon 都已经弃用
</p>
</blockquote>

<p>
使用 Thread 类,可以有很多方法创建线程.我们会介绍比较相似的三种方法(推荐最后一种).
</p>
<ul class="org-ul">
<li>创建 Thread 的实例,传给它一个函数.</li>
<li>创建 Thread 的实例,传给它一个可调用的类实例.</li>
<li>派生 Thread 的子类,并创建子类的实例.</li>
</ul>


<p>
你会发现你将选择第一个或第三个方案. 当你需要一个更加符合面向对象的接口时,选择第
三种,否则,选择第一种.
事实上,你会发现第二种方案有些尴尬并且难以阅读.
</p>

<p>
<b>创建 Thread 的实例,传给它一个函数</b>
第一个方案里,我们只是把 Thread 类实例化,然后将函数(及其参数)传递进去,和之前例子
中采取的方式一样. 当线程开始执行时,这个函数也会开始执行.
修改下 mtSleepB.py 脚本,添加使用 Thread 类,得到 mtsleepC.py:
threading 模块的 Thread 类有一个 join() 方法,可以让主线程等待所有线程执行完毕.
<b>mtsleepC.py:</b>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> threading
<span style="font-weight: bold;">from</span> time <span style="font-weight: bold;">import</span> sleep, ctime
<span style="font-weight: bold; font-style: italic;">loops</span> = [4, 2]

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">loop</span>(nloop, nsec):
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'start loop'</span>, nloop, <span style="font-style: italic;">'at:'</span>, ctime())
    sleep(nsec)
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'loop'</span>, nloop, <span style="font-style: italic;">'done at:'</span>, ctime())

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">main</span>():
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'starting at:'</span>, ctime())
    <span style="font-weight: bold; font-style: italic;">threads</span> = []

    <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(<span style="font-weight: bold;">len</span>(loops)):
        <span style="font-weight: bold; font-style: italic;">t</span> = threading.Thread(target=loop,args=(i, loops[i]))
        threads.append(t)

    <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(<span style="font-weight: bold;">len</span>(loops)):
        threads[i].start()

    <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(<span style="font-weight: bold;">len</span>(loops)):
        threads[i].join()

    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'all Done at:'</span>, ctime())

<span style="font-weight: bold;">if</span> <span style="font-weight: bold;">__name__</span> == <span style="font-style: italic;">'__main__'</span>:
    main()

</pre>
</div>

<p>
相比于 mtsleepB.py , mtsleepC.py 修改了哪些呢?
使用 thread 模块的锁没有了,取而代之的是一组 Thread 对象. 当实例化每个 Thread 对
象时,将函数(target) 和参数(args) 传进去,然后的到返回的 Thread 实例. 实例化
Thread( 调用 Thread()) 和调用 thread.start<sub>new</sub><sub>thread</sub>() 的最大区别是新线程不会立
即开始执行. 这是一个非常有用的同步功能,尤其是当你并不希望线程立即开始执行时.
</p>

<p>
<b>创建 Thread 的实例,传给它一个可调用的类实例</b>
</p>

<p>
创建线程时,与传入函数类似的一个方法是传入一个可调用的类的实例,用于线程执行&#x2013;这种
方法更加接近面向对象的多线程编程.
这种可调用的类包含一个执行环境,比起函数或者从一组函数中选择而言,有更好的灵活性.
现在你有了一个类对象,而不仅仅是单个函数或者一个函数列表/元组.
</p>

<p>
在 mtsleepC.py 中添加一个新类 ThreadFunc, 并进行一些其他改动,得到 mtsleepD.py,
如下:
<b>mtsleepD.py</b>:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> threading
<span style="font-weight: bold;">from</span> time <span style="font-weight: bold;">import</span> sleep, ctime

<span style="font-weight: bold; font-style: italic;">loops</span> = [4, 2]

<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">ThreadFunc</span>(<span style="font-weight: bold;">object</span>):

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">__init__</span>(<span style="font-weight: bold;">self</span>, func, args, name=<span style="font-style: italic;">''</span>):
        <span style="font-weight: bold;">self</span>.name = name
        <span style="font-weight: bold;">self</span>.func = func
        <span style="font-weight: bold;">self</span>.args = args

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">__call__</span>(<span style="font-weight: bold;">self</span>):
        <span style="font-weight: bold;">self</span>.func(*<span style="font-weight: bold;">self</span>.args)

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">loop</span>(nloop, secs):
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'start loop'</span>, nloop, <span style="font-style: italic;">'at:'</span>, ctime())
    sleep(secs)
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'loop'</span>, nloop, <span style="font-style: italic;">'done at:'</span>, ctime())

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">main</span>():
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'starting at:'</span>, ctime())
    <span style="font-weight: bold; font-style: italic;">threads</span> = []
    <span style="font-weight: bold; font-style: italic;">nloops</span> = <span style="font-weight: bold;">range</span>(<span style="font-weight: bold;">len</span>(loops))

    <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> nloops:
        <span style="font-weight: bold; font-style: italic;">t</span> = threading.Thread(target=ThreadFunc(loop, (i, loops[i]), loop.<span style="font-weight: bold;">__name__</span>))
        threads.append(t)
    <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> nloops:
        threads[i].start()

    <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> nloops:
        threads[i].join()

    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'all done at:'</span>, ctime())

<span style="font-weight: bold;">if</span> <span style="font-weight: bold;">__name__</span> == <span style="font-style: italic;">'__main__'</span>:
    main()
</pre>
</div>

<p>
mtsleepD.py 在实例化 Thread 对象时同时实例化了可调用类 ThreadFunc. 我们希望这个
类更加通用,而不是局限于 loop() 函数,因此添加了一些新的东西,比如让这个类保存了函
数的参数,函数自身和函数名字的字符串.而构造函数 _<sub>init</sub>_<sub>()</sub> 用于设定这些值.
</p>

<p>
创建新线程时, Thread 类的代码会调用 ThreadFunc 对象,此时会调用 _<sub>call</sub>_<sub>()</sub> 这个特
殊方法.因为已经有了要用到的参数,这里就不需要再将其传递给 Thread() 的构造函数里了,直
接调用就行了.
</p>

<p>
<b>派生Thread 的子类,并创建子类的实例</b>
</p>

<p>
最后一种创建线程的用法比上一个创建可调用类的例子类似,但是更容易阅读:
<b>mtsleepE.py</b>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> threading
<span style="font-weight: bold;">from</span> time <span style="font-weight: bold;">import</span> sleep, ctime

<span style="font-weight: bold; font-style: italic;">loops</span> = (4, 2)

<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">MyThread</span>(threading.Thread):
    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">__init__</span>(<span style="font-weight: bold;">self</span>, func, args, name=<span style="font-style: italic;">''</span>):
        threading.Thread.__init__(<span style="font-weight: bold;">self</span>)
        <span style="font-weight: bold;">self</span>.name = name
        <span style="font-weight: bold;">self</span>.func = func
        <span style="font-weight: bold;">self</span>.args = args

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">run</span>(<span style="font-weight: bold;">self</span>):
        <span style="font-weight: bold;">self</span>.func(*<span style="font-weight: bold;">self</span>.args)

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">loop</span>(nloop, secs):
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'start loop'</span>, nloop, <span style="font-style: italic;">'at:'</span>, ctime())
    sleep(secs)
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'loop'</span>, nloop, <span style="font-style: italic;">'done at:'</span>, ctime())

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">main</span>():
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'starting at:'</span>, ctime())
    <span style="font-weight: bold; font-style: italic;">threads</span> = []
    <span style="font-weight: bold; font-style: italic;">nloops</span> = <span style="font-weight: bold;">range</span>(<span style="font-weight: bold;">len</span>(loops))

    <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> nloops:
        <span style="font-weight: bold; font-style: italic;">t</span> = MyThread(loop,(i, loops[i]), loop.<span style="font-weight: bold;">__name__</span>)
        threads.append(t)

    <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> nloops:
        threads[i].start()


    <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> nloops:
        threads[i].join()

    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'all done at:'</span>, ctime())

<span style="font-weight: bold;">if</span> <span style="font-weight: bold;">__name__</span> == <span style="font-style: italic;">'__main__'</span>:
    main()
</pre>
</div>


<p>
比较 D 和 E 的代码:
</p>
<ol class="org-ol">
<li>MyThread 子类的构造函数必须先调用其基类的构造函数</li>
<li>之前的特殊方法 _<sub>call</sub>_<sub>()</sub> 在这个子类里必须写为 run().</li>
</ol>


<p>
Thread 对象开始运行时(执行 start()), 它会在一个独立的控制进程里调用对象的 run()
方法. run() 方法是代表线程活动的方法,这个方法可有在子类型里重载. 标准的 run() 方
法会对作为 target 参数传递给该对象构造器的<a href="#org5027237">3</a>(如果存在)发起调用,并从附带
args 和 kwargs 参数分别获取的位置和关键字参数.
</p>

<p>
现在,对 Mythread 类进行修改,增加一些调试信息的输出,并将其存为 myThread 的独立模
块,以便后面的例子里导入这个类. 除了简单地调用函数外,还将结果保存到实例属性
self.res 中,并创建一个获取这个值的新方法 getResult()
</p>

<p>
<b>Thread 子类 MyThread(myThread.py)</b>:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> threading
<span style="font-weight: bold;">from</span> time <span style="font-weight: bold;">import</span> sleep, ctime


<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">MyThread</span>(threading.Thread):

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">__init__</span>(<span style="font-weight: bold;">self</span>, func, args, name=<span style="font-style: italic;">''</span>):
        threading.Thread.__init__(<span style="font-weight: bold;">self</span>)
        <span style="font-weight: bold;">self</span>.name = name
        <span style="font-weight: bold;">self</span>.func = func
        <span style="font-weight: bold;">self</span>.args = args

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">getResult</span>(<span style="font-weight: bold;">self</span>):
        <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">self</span>.res

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">run</span>(<span style="font-weight: bold;">self</span>):
        <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'starting'</span>, <span style="font-weight: bold;">self</span>.name, <span style="font-style: italic;">'at:'</span>, ctime())
        <span style="font-weight: bold;">self</span>.res = <span style="font-weight: bold;">self</span>.func(*<span style="font-weight: bold;">self</span>.args)
        <span style="font-weight: bold;">print</span>(<span style="font-weight: bold;">self</span>.name, <span style="font-style: italic;">'finished at:'</span>, ctime())
</pre>
</div>
</div>
</div>



<div id="outline-container-orge542c93" class="outline-4">
<h4 id="orge542c93"><span class="section-number-4">2.5.2</span> threading 模块的其他函数</h4>
<div class="outline-text-4" id="text-2-5-2">
<p>
除了各种同步和线程对象外, threading 模块还提供一些函数,如下所示:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">函数</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">activeCount/active<sub>count</sub>()</td>
<td class="org-left">当前活动的 Thread 对象个数</td>
</tr>

<tr>
<td class="org-left">currentThread()/current<sub>thread</sub></td>
<td class="org-left">返回当前的Thread 对象</td>
</tr>

<tr>
<td class="org-left">enumerate()</td>
<td class="org-left">返回当前活动的 Thread 对象列表</td>
</tr>

<tr>
<td class="org-left">settrace(func)</td>
<td class="org-left">为所有线程设置一个 trace 函数</td>
</tr>

<tr>
<td class="org-left">setprofile(func)</td>
<td class="org-left">为所有线程设置一个 profile 函数</td>
</tr>

<tr>
<td class="org-left">stack<sub>size</sub>(size=0)</td>
<td class="org-left">返回新创建线程的栈大小,或为后续创建的线程设定栈的大小为size</td>
</tr>
</tbody>
</table>

<blockquote>
<p>
注意:
</p>
<ol class="org-ol">
<li>驼峰式命名已经弃用,并从Python2.6 版本起已经开始被取代</li>
<li>thread.stack<sub>size</sub>() 的一个别名是从 Python2.5 开始引入.</li>
</ol>
</blockquote>
</div>
</div>
</div>

<div id="outline-container-orga69531d" class="outline-3">
<h3 id="orga69531d"><span class="section-number-3">2.6</span> 单线程或多线程执行对比</h3>
<div class="outline-text-3" id="text-2-6">
<p>
下面的 mtfacfib.py 脚本比较了递归求斐波那契,阶乘与累加函数的执行.该脚本按照单线
程方式运行这三个函数.之后使用多线程方式执行同样任务.来比较多线程环境的优点.
</p>

<p>
<b>mtfacfib.py</b>:
</p>
<div class="org-src-container">
<pre class="src src-python">
<span style="font-weight: bold;">from</span> myThread <span style="font-weight: bold;">import</span> MyThread
<span style="font-weight: bold;">from</span> time <span style="font-weight: bold;">import</span> ctime, sleep


<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">fib</span>(x):
    sleep(0.005)
    <span style="font-weight: bold;">if</span> x &lt; 2:
        <span style="font-weight: bold;">return</span> 1
    <span style="font-weight: bold;">return</span> (fib(x - 2) + fib(x - 1))


<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">sum</span>(x):
    sleep(0.1)
    <span style="font-weight: bold;">if</span> x &lt; 2:
        <span style="font-weight: bold;">return</span> 1
    <span style="font-weight: bold;">return</span> (x + <span style="font-weight: bold;">sum</span>(x - 1))


<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">fac</span>(x):
    sleep(0.1)
    <span style="font-weight: bold;">if</span> x &lt; 2:
        <span style="font-weight: bold;">return</span> 1
    <span style="font-weight: bold;">return</span> (x * fac(x - 1))


<span style="font-weight: bold; font-style: italic;">funcs</span> = [fib, fac, <span style="font-weight: bold;">sum</span>]
<span style="font-weight: bold; font-style: italic;">n</span> = 12


<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">main</span>():
    <span style="font-weight: bold; font-style: italic;">nfuncs</span> = <span style="font-weight: bold;">range</span>(<span style="font-weight: bold;">len</span>(funcs))
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'*** SINGLE THREAD'</span>)
    <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> nfuncs:
        <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'starting'</span>, funcs[i].<span style="font-weight: bold;">__name__</span>, <span style="font-style: italic;">'at:'</span>, ctime())
        <span style="font-weight: bold;">print</span>(funcs[i](n))
        <span style="font-weight: bold;">print</span>(funcs[i].<span style="font-weight: bold;">__name__</span>, <span style="font-style: italic;">'finished'</span>, <span style="font-style: italic;">'at:'</span>, ctime())

    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'\n*** MULTIPLE THREADS'</span>)
    <span style="font-weight: bold; font-style: italic;">threads</span> = []
    <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> nfuncs:
        <span style="font-weight: bold; font-style: italic;">t</span> = MyThread(funcs[i], (n,), funcs[i].<span style="font-weight: bold;">__name__</span>)
        threads.append(t)
    <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> nfuncs:
        threads[i].start()
    <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> nfuncs:
        threads[i].join()
        <span style="font-weight: bold;">print</span>(threads[i].getResult())
    <span style="font-weight: bold;">print</span>(<span style="font-style: italic;">'all Done at:'</span>, ctime())


<span style="font-weight: bold;">if</span> <span style="font-weight: bold;">__name__</span> == <span style="font-style: italic;">'__main__'</span>:
    main()
</pre>
</div>
</div>
</div>

<div id="outline-container-org9116e0b" class="outline-3">
<h3 id="org9116e0b"><span class="section-number-3">2.7</span> 多线程实践</h3>
<div class="outline-text-3" id="text-2-7">
<p>
<a href="#org12725bc">2.3.1</a> 里曾提到,由于 Python 虚拟机是单线程(GIL) 的原因,只有线程在执行 I/O
密集型的应用时才能更好发挥 Python 的并发性(对比计算密集型,I/O 密集型只需要做轮
询),因此让我们看一个 I/O 密集型的例子.
</p>
</div>

<div id="outline-container-orge8d7f20" class="outline-4">
<h4 id="orge8d7f20"><span class="section-number-4">2.7.1</span> 图书排名示例</h4>
<div class="outline-text-4" id="text-2-7-1">
<p>
下面例子在 Amazon 上查询图书的当前排名.这个例子里函数 getRanking() 使用正则表达
式来拉取和返回当前排名,而函数 _showRanking() 用于向用户显示结果.
</p>

<p>
<b>bookrank.py</b>
</p>
<div class="org-src-container">
<pre class="src src-python">
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org968d539" class="outline-2">
<h2 id="org968d539"><span class="section-number-2">3</span> 相关概念</h2>
<div class="outline-text-2" id="text-3">
<p>
<a id="org5027237"></a>:函数(用户自定义,内置,内置对象的方法), 类对象, 类实例的方法以及任何具
有 _<sub>call</sub>_<sub>()</sub> 方法的对象都是可调用对象
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2023-06-05 Mon 08:33</p>
</div>
</body>
</html>
