<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title> Emacs Lisp 学习笔记</title>
<meta name="author" content="kamisama" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<script>
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
// @license-end
</script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="./index.html"> UP </a>
 |
 <a accesskey="H" href="../index.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title"> Emacs Lisp 学习笔记</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgf7582ba">Xahlee 的 Elisp 教程</a>
<ul>
<li>
<ul>
<li><a href="#org41486ef">执行 Elisp</a></li>
<li><a href="#org3b0d487">打印</a></li>
<li><a href="#orgc9a8aea">格式化字符串</a></li>
<li><a href="#orgdb28419">注释</a></li>
<li><a href="#orge1235ee">字符串</a></li>
<li><a href="#orgf40228e">算术运算</a></li>
<li><a href="#orgeb74258">整型/浮点型,数字/字符串类型转换</a></li>
<li><a href="#org49990af">光标位置函数</a></li>
<li><a href="#org26bcbec">文本编辑函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orga9a3171"><span class="todo TODO">TODO</span> Emacs 的 Elisp 手册</a>
<ul>
<li><a href="#orgd8959a2"><span class="todo TODO">TODO</span> 介绍</a>
<ul>
<li><a href="#orgb43e28a">TODO</a></li>
<li><a href="#orgb184206">TODO</a></li>
<li><a href="#org6b43b6a">TODO</a></li>
</ul>
</li>
<li><a href="#org9659351"><span class="done DONE">DONE</span> Lisp 数据类型(Lisp Data Types)</a>
<ul>
<li><a href="#org4204de3"><span class="done DONE">DONE</span> 打印表示(Printed Representation)</a></li>
<li><a href="#org1c51290"><span class="done DONE">DONE</span> 特殊的读取语法(Special Read Syntax)</a></li>
<li><a href="#org9ba3a65"><span class="done DONE">DONE</span> 注释(Comments)</a></li>
<li><a href="#org4c0aa1c"><span class="done DONE">DONE</span> 编程类型(Programming Types)</a></li>
<li><a href="#org0ce4b6f"><span class="done DONE">DONE</span> 编辑类型(Editing Types)</a></li>
<li><a href="#org208487c"><span class="done DONE">DONE</span> 循环对象(Circular Objects)</a></li>
<li><a href="#orgc2fc5ac"><span class="done DONE">DONE</span> 类型断言(Type Predicates)</a></li>
<li><a href="#org9fe4c9b"><span class="done DONE">DONE</span> 相等断言(Equality Predicates)</a></li>
<li><a href="#org73c2bd1"><span class="done DONE">DONE</span> 易变性(Mutability)</a></li>
</ul>
</li>
<li><a href="#orgf4cc629"><span class="done DONE">DONE</span> 数字(Numbers)</a>
<ul>
<li><a href="#orgd30d351"><span class="done DONE">DONE</span> 整型基础(Integer Basic)</a></li>
<li><a href="#orgeefbeee"><span class="done DONE">DONE</span> 浮点型基础(Float Basics)</a></li>
<li><a href="#org12871ce"><span class="done DONE">DONE</span> 数字的断言(Predicates on Numbers)</a></li>
<li><a href="#org8d901a6"><span class="done DONE">DONE</span> 数字的比较(Comparison of Numbers)</a></li>
<li><a href="#org1e0eb75"><span class="done DONE">DONE</span> 数字转换(Numeric Conversions)</a></li>
<li><a href="#org5c7d3e5"><span class="done DONE">DONE</span> 算术运算(Arithmetic Operations)</a></li>
<li><a href="#org8bf1e68"><span class="done DONE">DONE</span> 舍入运算(Rounding Operations)</a></li>
<li><a href="#org000a652"><span class="done DONE">DONE</span> 位运算(BitWise Operations)</a></li>
<li><a href="#org4c9e8f2"><span class="done DONE">DONE</span> 数学函数(Math Functions)</a></li>
<li><a href="#org09faeb9"><span class="done DONE">DONE</span> 随机数(Random Numbers)</a></li>
</ul>
</li>
<li><a href="#orgb4aecb8"><span class="done DONE">DONE</span> 字符串和字符(Strings and Characters)</a>
<ul>
<li><a href="#org2931f49"><span class="done DONE">DONE</span> 基础(Basics)</a></li>
<li><a href="#org98774e8"><span class="done DONE">DONE</span> 字符串的断言(Predicates for Strings)</a></li>
<li><a href="#orgd539f64"><span class="done DONE">DONE</span> 创建字符串(Creating Strings)</a></li>
<li><a href="#org2a04154"><span class="done DONE">DONE</span> 修改字符串(Modifying Strings)</a></li>
<li><a href="#org3bcdb05"><span class="done DONE">DONE</span> 文本比较(Text Comparison)</a></li>
<li><a href="#org5727e33"><span class="done DONE">DONE</span> 字符串转换(String Conversion)</a></li>
<li><a href="#org993d6e9"><span class="done DONE">DONE</span> 格式化字符串(Formatting Strings)</a></li>
<li><a href="#org489125c"><span class="done DONE">DONE</span> 自定义格式字符串(Custom Format Strings)</a></li>
<li><a href="#org6cc59f3"><span class="done DONE">DONE</span> 大小写转换(Case Conversion)</a></li>
<li><a href="#org50fbb35"><span class="done DONE">DONE</span> Case Tables</a></li>
</ul>
</li>
<li><a href="#orgaeae923"><span class="done DONE">DONE</span> 列表(Lists)</a>
<ul>
<li><a href="#org0f39bb9"><span class="done DONE">DONE</span> Cons Cells</a></li>
<li><a href="#org622036f"><span class="done DONE">DONE</span> 列表相关的断言(List-related Predicates)</a></li>
<li><a href="#orgf87bd69"><span class="done DONE">DONE</span> 列表元素(List Elements)</a></li>
<li><a href="#org2213f78"><span class="done DONE">DONE</span> 构建列表(Building Lists)</a></li>
<li><a href="#orgfff3f75"><span class="done DONE">DONE</span> 列表变量(List Variables)</a></li>
<li><a href="#org65e7d81"><span class="done DONE">DONE</span> 修改列表(Modifying Lists)</a></li>
<li><a href="#org1ae1b05"><span class="done DONE">DONE</span> 集合与列表(Sets And Lists)</a></li>
<li><a href="#orgaf2e615"><span class="done DONE">DONE</span> 关联表(Association Lists)</a></li>
<li><a href="#orgab3b2c8"><span class="done DONE">DONE</span> 属性列表(Property Lists)</a></li>
</ul>
</li>
<li><a href="#orgc0e0dcf"><span class="todo NEXT">NEXT</span> 序列 数组 向量(Sequences Arrays Vectors)</a>
<ul>
<li><a href="#org6f6c0f4"><span class="todo NEXT">NEXT</span> 序列函数(Sequence Functions)</a></li>
<li><a href="#orga89d466"><span class="todo NEXT">NEXT</span> 数组(Arrays)</a></li>
<li><a href="#orga12e3af"><span class="todo NEXT">NEXT</span> 数组函数(Array Functions)</a></li>
<li><a href="#org8139b11"><span class="todo NEXT">NEXT</span> 向量(Vectors)</a></li>
<li><a href="#org714d4f3"><span class="todo NEXT">NEXT</span> 向量函数(Vectors Functions)</a></li>
<li><a href="#org74ce9c3"><span class="todo NEXT">NEXT</span> 字符表(Char-Tables)</a></li>
<li><a href="#org4b3540d"><span class="todo NEXT">NEXT</span> 布尔向量(Bool-Vectors)</a></li>
<li><a href="#org81013e3"><span class="done DONE">DONE</span> Rings</a></li>
</ul>
</li>
<li><a href="#org0dc4d87"><span class="todo TODO">TODO</span> 记录(Records)</a></li>
<li><a href="#orgf516f8b"><span class="todo TODO">TODO</span> 哈希表(Hash Tables)</a>
<ul>
<li><a href="#org06d4537">TODO</a></li>
<li><a href="#org500d54b">TODO</a></li>
<li><a href="#orgdd7fefe">TODO</a></li>
<li><a href="#orgdc3fd16"><span class="todo TODO">TODO</span> 其他哈希(Other Hash)</a></li>
</ul>
</li>
<li><a href="#orgf14e561"><span class="todo TODO">TODO</span> 符号(Symbols)</a>
<ul>
<li><a href="#org971770a"><span class="todo TODO">TODO</span> 符号组成(Symbol Components)</a></li>
<li><a href="#org9900be8">TODO</a></li>
<li><a href="#org5f3730c"><span class="todo TODO">TODO</span> 创建符号(Creating Symbols)</a></li>
<li><a href="#orgcdc18d7"><span class="todo TODO">TODO</span> 符号属性(Symbol Properties)</a></li>
</ul>
</li>
<li><a href="#org8786ce9"><span class="done DONE">DONE</span> 求值(Evaluation)</a>
<ul>
<li><a href="#org869e90d"><span class="done DONE">DONE</span> Eval 简介(Intro Eval)</a></li>
<li><a href="#org0d16480"><span class="done DONE">DONE</span> 表达式(Forms)</a></li>
<li><a href="#orgc309393"><span class="done DONE">DONE</span> 引用(Quoting)</a></li>
<li><a href="#orgd7832f2"><span class="done DONE">DONE</span> 反引用(Backquote)</a></li>
<li><a href="#org823d079"><span class="done DONE">DONE</span> 执行(Eval)</a></li>
<li><a href="#orgde5b9c4"><span class="done DONE">DONE</span> 延迟执行(Deffered Eval)</a></li>
</ul>
</li>
<li><a href="#org553107e"><span class="done DONE">DONE</span> 控制结构(Control Structures)</a>
<ul>
<li><a href="#org2916e3a"><span class="done DONE">DONE</span> 顺序执行(Sequencing)</a></li>
<li><a href="#orgaa372a6"><span class="done DONE">DONE</span> 条件(Conditionals)</a></li>
<li><a href="#org95c036a"><span class="done DONE">DONE</span> 组合条件(Combining Conditions)</a></li>
<li><a href="#org9b24c8c"><span class="done DONE">DONE</span> 模式匹配的条件(Pattern-Matching Conditional)</a></li>
<li><a href="#orgcf83ad9"><span class="done DONE">DONE</span> 迭代(Iteration)</a></li>
<li><a href="#org964311a"><span class="done DONE">DONE</span> 生成器(Generators)</a></li>
<li><a href="#org61d300d"><span class="done DONE">DONE</span> 非局部退出(Nonlocal Exits)</a></li>
</ul>
</li>
<li><a href="#org7e787fa"><span class="todo NEXT">NEXT</span> 变量(Variables)</a>
<ul>
<li><a href="#org7542c90"><span class="done DONE">DONE</span> 全局变量(Global Variables)</a></li>
<li><a href="#orgde44202"><span class="done DONE">DONE</span> 常量(Constant Variable)</a></li>
<li><a href="#org6826578"><span class="done DONE">DONE</span> 局部变量(Local Variables)</a></li>
<li><a href="#org5fe7735"><span class="done DONE">DONE</span> 空变量(Void Variables)</a></li>
<li><a href="#org01c338c"><span class="todo TODO">TODO</span> 定义变量(Defining Variables)</a></li>
<li><a href="#org9c62aa8"><span class="done DONE">DONE</span> 关于定义的提示(Tips for Defining)</a></li>
<li><a href="#org936f45c"><span class="todo TODO">TODO</span> 访问变量(Accessing Variables)</a></li>
<li><a href="#orgbd90c15"><span class="done DONE">DONE</span> 设置变量(Setting Variables)</a></li>
<li><a href="#org0d27d4f"><span class="done DONE">DONE</span> 监视变量(Watching Variables)</a></li>
<li><a href="#orgc0f0806"><span class="todo NEXT">NEXT</span> 变量范围(Variable Scoping)</a></li>
<li><a href="#org002980b"><span class="todo NEXT">NEXT</span> 缓冲区局部变量(Buffer-Local Variables)</a></li>
<li><a href="#org6a93d16"><span class="todo NEXT">NEXT</span> 文件局部变量(File Local Variables)</a></li>
<li><a href="#orgba5e1a5"><span class="todo NEXT">NEXT</span> 目录局部变量(Directory Local Variables)</a></li>
<li><a href="#org0e2cd29"><span class="todo NEXT">NEXT</span> 连接局部变量(Connection Local Variables)</a></li>
<li><a href="#org4257d69"><span class="todo NEXT">NEXT</span> 变量别名(Variable Aliases)</a></li>
<li><a href="#org15b5af2"><span class="todo NEXT">NEXT</span> 有限制值的变量(Variables with Restricted Values)</a></li>
<li><a href="#org728a322"><span class="todo NEXT">NEXT</span> 广义变量(Generalized Variables)</a></li>
</ul>
</li>
<li><a href="#org5921345"><span class="todo TODO">TODO</span> 函数(Functions)</a>
<ul>
<li><a href="#orgb4e7d90"><span class="todo TODO">TODO</span> 什么是函数(What Is a Function)</a></li>
<li><a href="#org8ae8a6d"><span class="todo TODO">TODO</span> Lambda 表达式(Lambda Expressions)</a></li>
<li><a href="#orga05ec51"><span class="todo TODO">TODO</span> 定义函数(Defining Functions)</a></li>
<li><a href="#orgb7df300"><span class="todo TODO">TODO</span> 函数名(Function Names)</a></li>
<li><a href="#orgfb3c20f"><span class="todo TODO">TODO</span> 调用函数(Calling Functions)</a></li>
<li><a href="#orgbf27a2a"><span class="todo TODO">TODO</span> 匿名函数(Anonymous Functions)</a></li>
<li><a href="#orgd2781b6"><span class="todo TODO">TODO</span> 映射函数(Mapping Functions)</a></li>
<li><a href="#org0e545a5">TODO</a></li>
<li><a href="#org991a09f">TODO</a></li>
<li><a href="#org86bef4b"><span class="todo TODO">TODO</span> 函数单元(Function Cells)</a></li>
<li><a href="#orgfa246ab"><span class="todo TODO">TODO</span> 闭包(Closures)</a></li>
<li><a href="#org2840aef">TODO</a></li>
<li><a href="#orge7a93e3">TODO</a></li>
<li><a href="#orge58db4b">TODO</a></li>
<li><a href="#org69ddd2a">TODO</a></li>
<li><a href="#orge121275">TODO</a></li>
<li><a href="#org5af1f92">TODO</a></li>
</ul>
</li>
<li><a href="#org15d607f"><span class="todo TODO">TODO</span> 宏(Macros)</a></li>
<li><a href="#orgc5a4660"><span class="todo TODO">TODO</span> 自定义(Customization)</a>
<ul>
<li><a href="#org4c105ee">TODO</a></li>
<li><a href="#org878ff12">TODO</a></li>
<li><a href="#orga9166ed"><span class="todo TODO">TODO</span> 变量定义(Variabel Definitions)</a></li>
</ul>
</li>
<li><a href="#orgfe470e1"><span class="todo TODO">TODO</span> 加载(Loading)</a>
<ul>
<li><a href="#orgb7a9174"><span class="todo TODO">TODO</span> 程序如何执行加载(How Programs Do Loading)</a></li>
<li><a href="#org1926660">TODO</a></li>
<li><a href="#orgae87e98">TODO</a></li>
<li><a href="#org1682114">TODO</a></li>
<li><a href="#org910e488"><span class="todo TODO">TODO</span> 自动加载(Autoload)</a></li>
<li><a href="#org54993f9">TODO</a></li>
<li><a href="#org2430434">TODO</a></li>
<li><a href="#orge38a4a3">TODO</a></li>
<li><a href="#org0148acb"><span class="todo TODO">TODO</span> 卸载(Unloading)</a></li>
<li><a href="#org1a742c1">TODO</a></li>
<li><a href="#orgea07986">TODO</a></li>
</ul>
</li>
<li><a href="#org83b295a"><span class="todo TODO">TODO</span> 字节编译(Byte Compilation)</a>
<ul>
<li><a href="#org3638602"><span class="todo TODO">TODO</span> 文档和编译(Docs and Compilation)</a></li>
<li><a href="#org58e91b7"><span class="todo TODO">TODO</span> 字节码对象(Byte-Code Objects)</a></li>
<li><a href="#orgf8d6226">TODO</a></li>
<li><a href="#orgb4b6576">TODO</a></li>
<li><a href="#org98ca786">TODO</a></li>
<li><a href="#org218f0cd"><span class="todo TODO">TODO</span> 编译器错误(Compiler Errors)</a></li>
</ul>
</li>
<li><a href="#orgff349d0">TODO</a></li>
<li><a href="#org964807e">TODO</a></li>
<li><a href="#org4b93f42">TODO</a></li>
<li><a href="#orgc25d34c">TODO</a></li>
<li><a href="#org716d8f7">TODO</a></li>
<li><a href="#orgb639419">TODO</a></li>
<li><a href="#orge99f6f6"><span class="todo TODO">TODO</span> 模式(Modes)</a>
<ul>
<li><a href="#org8f73bee"><span class="todo TODO">TODO</span> 钩子(Hooks)</a></li>
</ul>
</li>
<li><a href="#orgb14dd88"><span class="todo TODO">TODO</span> 文档(Documentation)</a>
<ul>
<li><a href="#org8a84f14"><span class="todo TODO">TODO</span> 描述字符(Describing Characters)</a></li>
<li><a href="#org9c3df19">TODO</a></li>
<li><a href="#orgf5103df">TODO</a></li>
<li><a href="#orgb8798d2"><span class="todo TODO">TODO</span> 文本引用格式(Text Quoting Style)</a></li>
</ul>
</li>
<li><a href="#org0bf9401"><span class="todo TODO">TODO</span> 调试(Debugging)</a>
<ul>
<li><a href="#orge70b4e9"><span class="todo TODO">TODO</span> 调试器(Debugger)</a></li>
</ul>
</li>
<li><a href="#orgf48e6af">TODO</a></li>
<li><a href="#org655c91e">TODO</a></li>
<li><a href="#org6ebe914"><span class="todo TODO">TODO</span> 命令循环(Command Loop)</a>
<ul>
<li><a href="#org7aa3c11">TODO</a></li>
<li><a href="#org4ba0631">TODO</a></li>
<li><a href="#org30f4580"><span class="todo TODO">TODO</span> 交互式调用(Interactive Call)</a></li>
<li><a href="#orgb928846"><span class="todo TODO">TODO</span> 输入事件(Input Events)</a></li>
<li><a href="#org9ae97a7"><span class="todo TODO">TODO</span> 键盘宏(Keyboard Macros)</a></li>
<li><a href="#org292391b">TODO</a></li>
<li><a href="#org527d6a0">TODO</a></li>
<li><a href="#orge4d50b7">TODO</a></li>
<li><a href="#org137edca">TODO</a></li>
<li><a href="#org184c7fd">TODO</a></li>
<li><a href="#orge169eec"><span class="todo TODO">TODO</span> 退出(Quiting)</a></li>
<li><a href="#org663c402">TODO</a></li>
<li><a href="#orgeb295fc"><span class="todo TODO">TODO</span> 递归编辑((Recursive Editing)</a></li>
</ul>
</li>
<li><a href="#orgad5bc8b"><span class="todo TODO">TODO</span> 按键映射(Keymaps)</a>
<ul>
<li><a href="#orgf28896f">TODO</a></li>
<li><a href="#orge5b6789">TODO</a></li>
<li><a href="#orgc909ec2">TODO</a></li>
<li><a href="#org799bd20"><span class="todo TODO">TODO</span> 创建按键映射(Creating Keymaps)</a></li>
</ul>
</li>
<li><a href="#orge187988">TODO</a></li>
<li><a href="#orgf8513c7"><span class="todo TODO">TODO</span> 读取和打印(Read and Print)</a>
<ul>
<li><a href="#orge639fe7">TODO</a></li>
<li><a href="#org57020dc">TODO</a></li>
<li><a href="#orgdd8af85"><span class="todo TODO">TODO</span> 输入函数(Input Functions)</a></li>
<li><a href="#org8c6411d"><span class="todo TODO">TODO</span> 输出流(Output Streams)</a></li>
<li><a href="#orge0896d7"><span class="todo TODO">TODO</span> 输出函数(Output Functions)</a></li>
<li><a href="#orgb1bf5b1"><span class="todo TODO">TODO</span> 输出变量(Output Variables)</a></li>
</ul>
</li>
<li><a href="#orga1c7a88"><span class="todo TODO">TODO</span> 迷你缓冲区(Minibuffers)</a></li>
<li><a href="#org605fe44">TODO</a></li>
<li><a href="#orgcab4107">TODO</a></li>
<li><a href="#org718863b"><span class="todo TODO">TODO</span> 框架(Frames)</a>
<ul>
<li><a href="#org340d88f">TODO</a></li>
<li><a href="#org70d6964"><span class="todo TODO">TODO</span> 多终端(Multiple Terminals)</a></li>
<li><a href="#org3a989e4">TODO</a></li>
<li><a href="#orgbad06fb">TODO</a></li>
<li><a href="#org168a3cc">TODO</a></li>
<li><a href="#org34e6f5c">TODO</a></li>
<li><a href="#org6c473c3"><span class="todo TODO">TODO</span> 删除框架(Deleting Frames)</a></li>
<li><a href="#orgdee515b">TODO</a></li>
<li><a href="#orgac4a650">TODO</a></li>
<li><a href="#orgfadec79">TODO</a></li>
<li><a href="#org995f568">TODO</a></li>
<li><a href="#org2cd0bd6">TODO</a></li>
<li><a href="#org784167d"><span class="todo TODO">TODO</span> 框架配置(Frame Configurations)</a></li>
</ul>
</li>
<li><a href="#orgcde4f6b">TODO</a></li>
<li><a href="#org561b2c5">TODO</a></li>
<li><a href="#orga7bfbe8"><span class="todo TODO">TODO</span> 标记(Markers)</a>
<ul>
<li><a href="#orgff497a5">TODO</a></li>
<li><a href="#org8194aed"><span class="todo TODO">TODO</span> 标记的断言(Predicates on Markers)</a></li>
</ul>
</li>
<li><a href="#org35285e5">TODO</a></li>
<li><a href="#orgd3dbadb">TODO</a></li>
<li><a href="#org21204c1"><span class="todo TODO">TODO</span> 搜索和匹配(Searching and Matching)</a>
<ul>
<li><a href="#orged3be7e">TODO</a></li>
<li><a href="#orge1685b9">TODO</a></li>
<li><a href="#org3c6463d"><span class="todo TODO">TODO</span> 正则表达式(Regular Expressions)</a></li>
<li><a href="#org8dfde4e"><span class="todo TODO">TODO</span> 正则搜索(Regexp Search)</a></li>
<li><a href="#org5c8f6df">TODO</a></li>
<li><a href="#orge41d11a"><span class="todo TODO">TODO</span> 匹配数据(Match Data)</a></li>
<li><a href="#org42e5cd6"><span class="todo TODO">TODO</span> 搜索和替换(Search and Replace)</a></li>
</ul>
</li>
<li><a href="#org1beb779">TODO</a></li>
<li><a href="#orgbf47603">TODO</a></li>
<li><a href="#org5d465d5">TODO</a></li>
<li><a href="#orgc988708">TODO</a></li>
<li><a href="#orgb624181"><span class="todo TODO">TODO</span> 线程(Threads)</a>
<ul>
<li><a href="#org3a73c7a"><span class="todo TODO">TODO</span> 基本线程函数(Basic Thread Functions)</a></li>
<li><a href="#org899103b"><span class="todo TODO">TODO</span> 互斥锁(Mutexes)</a></li>
<li><a href="#orgb3c45a9"><span class="todo TODO">TODO</span> 条件变量(Condition Variables)</a></li>
</ul>
</li>
<li><a href="#orgacdc11c"><span class="todo TODO">TODO</span> 显示(Display)</a>
<ul>
<li><a href="#org16edf4c"><span class="todo TODO">TODO</span> 字符显示(Character Display)</a></li>
<li><a href="#org00f2169">TODO</a></li>
<li><a href="#org38ac545">TODO</a></li>
<li><a href="#orgc320f09">TODO</a></li>
<li><a href="#orga01d471">TODO</a></li>
<li><a href="#org10acdca">TODO</a></li>
<li><a href="#org301407a">TODO</a></li>
<li><a href="#org132a1de">TODO</a></li>
<li><a href="#org562b087"><span class="todo TODO">TODO</span> 覆盖层(Overlays)</a></li>
<li><a href="#org09acbcb"><span class="todo TODO">TODO</span> 显示的文本的大小(Size of Displayed Text)</a></li>
<li><a href="#org90be08c"><span class="todo TODO">TODO</span> 回显区(The Echo Area)</a></li>
<li><a href="#orgaa6c179"><span class="todo TODO">TODO</span> 面(Faces)</a></li>
</ul>
</li>
<li><a href="#org752eca9">TODO</a></li>
<li><a href="#orgaf6b33c">TODO</a></li>
<li><a href="#orgc4f19d0">TODO</a></li>
<li><a href="#orgfff7377">TODO</a></li>
<li><a href="#org536a4d8">TODO</a></li>
<li><a href="#org301788e"><span class="todo TODO">TODO</span> 进程(Processes)</a>
<ul>
<li><a href="#org82ca383">TODO</a></li>
<li><a href="#orga93600a"><span class="todo TODO">TODO</span> Shell 参数(Shell Arguments)</a></li>
</ul>
</li>
<li><a href="#org75e49d9"><span class="todo TODO">TODO</span> 文件(Files)</a></li>
<li><a href="#org12fbc0b"><span class="todo TODO">TODO</span> 缓冲区(Buffers)</a>
<ul>
<li><a href="#orgfac7b85"><span class="todo TODO">TODO</span> 缓冲区基础(Buffer Basics)</a></li>
<li><a href="#org75e596b"><span class="todo TODO">TODO</span> 当前缓冲区(Current Buffer)</a></li>
<li><a href="#org6bf99ea"><span class="todo TODO">TODO</span> 间接缓冲区(Indirect Buffers)</a></li>
<li><a href="#org235c270"><span class="todo TODO">TODO</span> 缓冲区文件名(Buffer File Name)</a></li>
</ul>
</li>
<li><a href="#org24b263f"><span class="todo TODO">TODO</span> 窗口(Windows)</a>
<ul>
<li><a href="#org3ece239"><span class="todo TODO">TODO</span> 基本窗口(Basic Windows)</a></li>
<li><a href="#org963d2b2">TODO</a></li>
<li><a href="#orgbcab970"><span class="todo TODO">TODO</span> 选择窗口(Selecting Windows)</a></li>
<li><a href="#org86a8972">TODO</a></li>
<li><a href="#orge31427e">TODO</a></li>
<li><a href="#org6077611">TODO</a></li>
<li><a href="#org384e44a">TODO</a></li>
<li><a href="#orgb0b9038"><span class="todo TODO">TODO</span> 删除窗口(Deleting Windows)</a></li>
<li><a href="#org740c6ee">TODO</a></li>
<li><a href="#orga6e5e66">TODO</a></li>
<li><a href="#orgb55b8af">TODO</a></li>
<li><a href="#org03b6d20">TODO</a></li>
<li><a href="#orgfc16270">TODO</a></li>
<li><a href="#orgeaf4b6c">TODO</a></li>
<li><a href="#orgd4ab6aa">TODO</a></li>
<li><a href="#orgafadc73">TODO</a></li>
<li><a href="#org90c87cb">TODO</a></li>
<li><a href="#org2f89eff">TODO</a></li>
<li><a href="#orgdec0158">TODO</a></li>
<li><a href="#org27c7c9a">TODO</a></li>
<li><a href="#org67e123c">TODO</a></li>
<li><a href="#orgbfb76da">TODO</a></li>
<li><a href="#orga526990">TODO</a></li>
<li><a href="#org1905db4">TODO</a></li>
<li><a href="#orgd3876a9">TODO</a></li>
<li><a href="#org8509ca3"><span class="todo TODO">TODO</span> 窗口配置(Window Configurations)</a></li>
<li><a href="#orgad7b324">TODO</a></li>
<li><a href="#org20af33c">TODO</a></li>
</ul>
</li>
<li><a href="#orgbef9fd7"><span class="todo TODO">TODO</span> 位置(Positions)</a>
<ul>
<li><a href="#orge6d8e83">TODO</a></li>
<li><a href="#org43baec3">TODO</a></li>
<li><a href="#orgb7f4793"><span class="todo TODO">TODO</span> Excursions</a></li>
<li><a href="#org3ea3146"><span class="todo TODO">TODO</span> Narrowing</a></li>
</ul>
</li>
<li><a href="#org3ec44e9"><span class="todo TODO">TODO</span> 文本(Text)</a>
<ul>
<li><a href="#orgd372b48">TODO</a></li>
<li><a href="#org72b73c0"><span class="todo TODO">TODO</span> 缓冲区内容(Buffer Contents)</a></li>
<li><a href="#org1889664"><span class="todo TODO">TODO</span> 比较文本(Comparing Text)</a></li>
<li><a href="#org662352f">TODO</a></li>
<li><a href="#orgc022639">TODO</a></li>
<li><a href="#org6793745">TODO</a></li>
<li><a href="#orgd828518">TODO</a></li>
<li><a href="#org71fe477">TODO</a></li>
<li><a href="#org9f8bdc7">TODO</a></li>
<li><a href="#org91b88c6">TODO</a></li>
<li><a href="#orgf263675">TODO</a></li>
<li><a href="#org5da8f9f">TODO</a></li>
<li><a href="#org064801c">TODO</a></li>
<li><a href="#orge6d636a">TODO</a></li>
<li><a href="#org493e050">TODO</a></li>
<li><a href="#org37714ed">TODO</a></li>
<li><a href="#org430ea45">TODO</a></li>
<li><a href="#orgc009e1c"><span class="todo TODO">TODO</span> 大小写转换(Case Changes)</a></li>
<li><a href="#org05aca52"><span class="todo TODO">TODO</span> 文本属性(Text Properties)</a></li>
<li><a href="#org2bce212">TODO</a></li>
<li><a href="#org0bbbc89">TODO</a></li>
<li><a href="#org80c4d27">TODO</a></li>
<li><a href="#org3d4ffbf">TODO</a></li>
<li><a href="#orgad16fda">TODO</a></li>
<li><a href="#org84668a5">TODO</a></li>
<li><a href="#orgafdb7e0">TODO</a></li>
<li><a href="#orgdc50193">TODO</a></li>
<li><a href="#org5bc668f">TODO</a></li>
<li><a href="#org28aac15">TODO</a></li>
<li><a href="#org90970db">TODO</a></li>
<li><a href="#org78e262a"><span class="todo TODO">TODO</span> 原子变化(Atomic Changes)</a></li>
<li><a href="#orgf338f5a">TODO</a></li>
</ul>
</li>
<li><a href="#org9ab52af"><span class="todo TODO">TODO</span> 非 ASCII 字符(Non-ASCII Characters)</a>
<ul>
<li><a href="#org263a727"><span class="todo NEXT">NEXT</span> 文本表示(Text Representations)</a></li>
<li><a href="#orgd121d78">NEXT</a></li>
<li><a href="#orgfbaf65b"><span class="todo NEXT">NEXT</span> 转换表示形式(Converting Representations)</a></li>
<li><a href="#org4cb460f">NEXT</a></li>
<li><a href="#org65793c7"><span class="todo NEXT">NEXT</span> 字符编码(Character Codes)</a></li>
<li><a href="#org52ed95a"><span class="todo NEXT">NEXT</span> 字符属性(Character Properties)</a></li>
<li><a href="#org6d14b29">NEXT</a></li>
<li><a href="#orgd9ab8b3">NEXT</a></li>
<li><a href="#orge7609cb">NEXT</a></li>
<li><a href="#orgfc5d22b"><span class="todo NEXT">NEXT</span> 编码系统(Coding Systems)</a></li>
</ul>
</li>
<li><a href="#org78c3e54"><span class="todo TODO">TODO</span> 语法表(Syntax Tables)</a>
<ul>
<li><a href="#org24bb661"><span class="todo TODO">TODO</span> 语法描述符(Syntax Descriptors)</a></li>
<li><a href="#orgd9a3c9f"><span class="todo TODO">TODO</span> 类别(Categories)</a></li>
</ul>
</li>
<li><a href="#org1161c82"><span class="todo TODO">TODO</span> 附录</a>
<ul>
<li><a href="#orgd5390f5">提示(Tips)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p>
Created: <span class="timestamp-wrapper"><span class="timestamp">[2023-02-21 Tue 12:18]</span></span>
Last modified:2024-02-16 12:52:26 kamisama
</p>

<div id="outline-container-orgf7582ba" class="outline-2">
<h2 id="orgf7582ba">Xahlee 的 Elisp 教程</h2>
<div class="outline-text-2" id="text-orgf7582ba">
<p>
Xahlee 的 Emacs Lisp 分为了基础和实践部分,基础只包含 LISP 语言通用的部分,实践部
分才涉及 Emacs Lisp 这种 LISP 方言特有的知识,我就不按照他的排版来记笔记了,按照我
自己学习的路线记算了.
</p>
</div>

<div id="outline-container-org41486ef" class="outline-4">
<h4 id="org41486ef">执行 Elisp</h4>
<div class="outline-text-4" id="text-org41486ef">
<p>
在任意缓冲区中键入
</p>
<pre class="example" id="orgb427691">
(+ 3 4)
</pre>
<p>
然后将光标移动到右边括号处,按下按键 <code>Ctrl-x Ctrl-e</code> 就可以看到代码被执行,且执行
结果 7 会显示在 Message Buffer 里.
</p>

<p>
这是最简单的执行 Elisp 片段的方式,还有好几种执行 Elisp 的方式如下:
</p>
<ul class="org-ul">
<li><code>M-x eval-last-sexp</code> : 执行光标左边的 Elisp 表达式.其实就是上面的 <code>Ctrl-x
  Ctrl-e</code> 快捷键所代表的操作.</li>
<li><code>M-x eval-region</code> : 执行选中的文本.</li>
<li><code>M-x eval-buffer</code> : 执行整个缓冲区.</li>
<li><code>M-x load-file</code> : 执行一个文件,会提示输入文件路径/名.</li>
<li><code>M-x eval-defun</code> : 执行光标所在处的函数定义.(该函数的代码必须要有良好的缩进,不
然在查找函数时会有问题.就像 narrow-to-defun, eval-defun 一样有bug)</li>
<li><code>M-x eval-expression</code> : 提示你输入要执行的 Elisp 表达式.</li>
</ul>
<blockquote>
<p>
关于 <code>narrow-to-defun</code> 有问题的部分 Xahlee 的文章是 2015年的,Emacs 24.4.1 但是直
到现在我测试时还是有问题.
</p>
</blockquote>

<p>
此外, Elisp 也有交互式运行环境,叫做 ielm 使用 <code>M-x ielm</code> 就可以调用它了,使用起来
和其他语言的交互式运行环境没有差别.
</p>
</div>
</div>
<div id="outline-container-org3b0d487" class="outline-4">
<h4 id="org3b0d487">打印</h4>
<div class="outline-text-4" id="text-org3b0d487">
<p>
我接触过的几乎所有语言都有类似 print 的这样的函数,用来打印数据, Elisp 也不例外,
不过 Emacs 最简单的打印函数应该是 <code>(message FORMAT-STRING &amp;rest ARGS)</code>, 它用来在
Message Buffer 里打印数据,不会干扰到其他缓冲区,格式化字符串的用法和 C 语言的
printf() 类似.
</p>

<p>
<code>(message "Hi Emacs!")</code> 会在消息缓冲区中显示 "Hi Emacs!"
</p>

<p>
<code>message</code> 也可以打印变量值,如 <code>(message "Her age is %d" 16)</code> ,占位符 <code>%s</code> 表示字
符串, <code>%S</code> 表示任意Lisp 表达式,例如 <code>(message "Her name is %s" "Jessica")</code>,
<code>(message "A List : %S" (list 1 2 3 4))</code>
</p>

<blockquote>
<p>
common Lisp 的官网手册教程中使用的是 (format STRING &amp;reset OBJECTS) 函数,它主要
用来格式化字符串,在所有使用格式化字符串的地方,比如上面的
<code>(message "Her name is %s" "Jessica")</code> ,
都可以使用 format 函数替代: <code>(message (format "Her name is %s" "Jessica"))</code>.
</p>

<p>
关于格式化字符串占位符的文档,可以查看 format 函数的文档字符串.
</p>
</blockquote>

<p>
其他 LISP 一般都有的打印函数是 (print OBJECT &amp;optional PRINTCHARFUN) 以 lisp 语
法打印 lisp 对象. 打印的输出可以被其他函数读取,可选的参数可以是一个目标缓冲区或
是其他函数,如果被省略,那么可选参数会默认是变量 <code>standard-output</code> 里的值,而
<code>standart-output</code> 为 <code>t</code> 是,指的就是 Message Buffer, 因此可选参数省略时就默认打
印输出到 Message Buffer . 当编写一个做批处理的 elsip 脚本时,最好是将输出打印到你
自己的缓冲区,因为 Messages Buffer 会滚动.
</p>

<p>
print 的示例:
</p>
<pre class="example" id="org13a1a40">
(setq xbuff (generate-new-buffer "*my output*"))

(print "something" xbuff)

(switch-to-buffer xbuff )
</pre>
<p>
上面代码我只熟悉一个 setq 和 print 一个是设置变量用的,一个就是刚学的 print ,不过
这些函数名都取的很好,看见名字就知道是做什么用的, 第一条语句生成一个新的缓冲区,名
字叫做 <code>*my output*</code> 然后将这个缓冲区赋值给变量 xbuff, 第二条语句打印字符串
"something" 到变量 xbuff, 也就是我们刚刚创建的缓冲区,第三条语句是切换到缓冲区
xbuff 去,所以三条语句执行的结果就是会切换到一个新的缓冲区,这个缓冲区名字叫 <code>*my
output*</code> 而里面的内容是 "something".
</p>

<p>
与 pirnt 相似的还有两个函数:
</p>
<ul class="org-ul">
<li>(prin1 OBJECT &amp;optional PRINTCHARFUN) : 和 print 相似,但是不会在每个打印输出的
后面添加换行符.</li>
<li>(princ OBJECT &amp;optional PRINTCHARFUN) : 打印输出不带换行符和字符串分隔符的内容,为
了方便人类阅读.</li>
</ul>


<p>
还有可以直接输出到当前缓冲区的函数 (insert &amp;rest ARGS) 可以将字符串输出到当前缓
冲区的光标位置.
例如:
</p>
<pre class="example" id="orgea65801">
(insert "something")
</pre>
<p>
在用 <code>Ctrl-x Ctrl-e</code> 执行代码后,就会产生下面的结果中的一种,具体是哪种结果取决于
在执行代码时光标是在右边括号上还是右边括号的右侧.
</p>
<pre class="example" id="org9e4cced">
(insert "something")something
(insert "something"something)
</pre>
<p>
关于光标位置的函数参见 <a href="#org49990af">光标位置函数</a> 部分.
形如 insert 这样编辑文本的函数参见 <a href="#org26bcbec">文本编辑函数</a> 部分.
</p>

<p>
我们经常需要将一系列输出全输入到一个缓冲区,每次都要像 print 函数一样指定缓冲区就
太麻烦了,所以我们可以使用 (with-output-to-temp-buffer BUFNAME &amp;rest BODY) 函数,
这个函数会将"标准输出"绑定到 BUFNAME 缓冲区,然后执行 BODY, BODY 里所有输出到标准
输出的函数的输出都会输出到 BUFNAME 里.这个结构会在 BODY 部分执行之前清空 BUFNAME
缓冲区.print , prin1 这样默认输出到标准输出的函数在 BODY 里执行的输出结构都会进
入到 BUFNAME 里.另外,这个结构在最后会也将 BUFNAME 这个缓冲区设置为只读的.
</p>

<p>
示例如下:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">
(<span style="color: #89DDFF;">setq</span> xbuff (generate-new-buffer <span style="color: #c3e88d;">"*my output*"</span>))

(<span style="color: #89DDFF;">with-output-to-temp-buffer</span> xbuff

  <span style="color: #676E95;">;; </span><span style="color: #676E95;">this is inserted in current buffer</span>
  (insert <span style="color: #c3e88d;">"xyz"</span>)

  <span style="color: #676E95;">;; </span><span style="color: #676E95;">this is printed in buffer xbuff</span>
  (print <span style="color: #c3e88d;">"abc"</span>))

(switch-to-buffer xbuff )
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc9a8aea" class="outline-4">
<h4 id="orgc9a8aea">格式化字符串</h4>
<div class="outline-text-4" id="text-orgc9a8aea">
<p>
Elisp 里格式字符串的规则基本与 format 函数的文档字符串里解释的一致,使用
<code>M-x describe-function format</code> 或快捷键 <code>Ctrl-h f format</code> 很容易就能查看到
format 的文档字符串,既然都在学 Elisp 了,那肯定在用 Emacs, 这部分的笔记就不用记了,在
需要时调出来看看就可以了.
</p>
</div>
</div>

<div id="outline-container-orgdb28419" class="outline-4">
<h4 id="orgdb28419">注释</h4>
<div class="outline-text-4" id="text-orgdb28419">
<p>
Elisp 代码的注释由一个分号 <code>;</code> 开始,按照传统约定,单行注释由两个分号开始,小节标题
由三个分号开始:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #676E95;">;; </span><span style="color: #676E95;">this is a comment</span>

(+ 1 2) <span style="color: #676E95;">; </span><span style="color: #676E95;">result is 3</span>

<span style="color: #676E95;">;; </span><span style="color: #676E95;">by emacs convention, comment on a line by itself starts with 2 semicolons</span>

<span style="color: #676E95;">;;; </span><span style="color: #676E95;">HEADER COMMENT</span>
<span style="color: #676E95;">;; </span><span style="color: #676E95;">by emacs convention, comment starting with 3 semicolons is a header, e.g. section title</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orge1235ee" class="outline-4">
<h4 id="orge1235ee">字符串</h4>
<div class="outline-text-4" id="text-orge1235ee">
<p>
Elisp 里字符串由双引号引用,语法如下:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #c3e88d;">"this is a string"</span>

(length <span style="color: #c3e88d;">"abc"</span>)
<span style="color: #676E95;">;; </span><span style="color: #676E95;">3</span>
</pre>
</div>
<p>
要在字符串里使用双引号,需要使用字符串转义:例如 <code>"He said \"something\""</code> 还有许
多特殊的转义字符,如 <code>\n</code> 换行符, <code>\t</code> 制表符等,这在大多数语言中都是通用的.有些我
没见过的就是 <code>\uxxxx</code> 和 <code>\U00xxxxxx</code> 的 Unicode 转义序列了. 使用 Unicode 转义序
列可以在字符串里使用符号,形状和表情:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(string-equal <span style="color: #c3e88d;">"\u0061"</span> <span style="color: #c3e88d;">"a"</span>)
<span style="color: #676E95;">;; </span><span style="color: #676E95;">t</span>

<span style="color: #676E95;">;; </span><span style="color: #676E95;">&#9829; BLACK HEART SUIT</span>
<span style="color: #676E95;">;; </span><span style="color: #676E95;">codepoint 9829</span>
<span style="color: #676E95;">;; </span><span style="color: #676E95;">hexadecimal 2665</span>
(string-equal <span style="color: #c3e88d;">"\u2665"</span> <span style="color: #c3e88d;">"&#9829;"</span>)
<span style="color: #676E95;">;; </span><span style="color: #676E95;">t</span>
<span style="color: #676E95;">;; </span><span style="color: #676E95;">&#128568; GRINNING CAT FACE WITH SMILING EYES</span>
<span style="color: #676E95;">;; </span><span style="color: #676E95;">codepoint 128568</span>
<span style="color: #676E95;">;; </span><span style="color: #676E95;">hexadecimal 1f638</span>
(string-equal <span style="color: #c3e88d;">"\U0001f638"</span> <span style="color: #c3e88d;">"&#128568;"</span>)
(string-equal <span style="color: #c3e88d;">"\U00010000"</span> <span style="color: #c3e88d;">"\u0061"</span>)
<span style="color: #676E95;">;; </span><span style="color: #676E95;">t</span>
</pre>
</div>
<p>
<code>\uxxxx</code> 和 <code>\U00xxxxxx</code> 后者能表达的字符更多,两者格式有些许差别,其他就都差不多
了.
</p>

<p>
更多内容请参考 info 手册 <a href="https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#String-Type">elisp#String Type</a>
</p>
</div>
</div>

<div id="outline-container-orgf40228e" class="outline-4">
<h4 id="orgf40228e">算术运算</h4>
<div class="outline-text-4" id="text-orgf40228e">
<p>
基本的算术运算看几个例子就都明白了:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #676E95;">;; </span><span style="color: #676E95;">addition</span>
(+ 4 5 1) <span style="color: #676E95;">; </span><span style="color: #676E95;">10</span>
<span style="color: #676E95;">;; </span><span style="color: #676E95;">Subtraction</span>
(- 9 2) <span style="color: #676E95;">; </span><span style="color: #676E95;">7</span>
(- 9 2 3) <span style="color: #676E95;">; </span><span style="color: #676E95;">4</span>
<span style="color: #676E95;">;; </span><span style="color: #676E95;">Multiplication</span>
(* 2 3) <span style="color: #676E95;">; </span><span style="color: #676E95;">6</span>
(* 2 3 2) <span style="color: #676E95;">; </span><span style="color: #676E95;">12</span>
<span style="color: #676E95;">;; </span><span style="color: #676E95;">Division</span>

<span style="color: #676E95;">;; </span><span style="color: #676E95;">WARNING: 7 divided by 2 returns 3, not 3.5,</span>
<span style="color: #676E95;">;; </span><span style="color: #676E95;">because the division function return a int when both operands are int.</span>

<span style="color: #676E95;">;; </span><span style="color: #676E95;">integer part of quotient</span>
(/ 7 2) <span style="color: #676E95;">; </span><span style="color: #676E95;">3</span>

(/ 7 2.0) <span style="color: #676E95;">; </span><span style="color: #676E95;">3.5</span>

WARNING: 2. is still a int. 2.0 is a float.
</pre>
</div>
<p>
上面加减乘除值得注意的还是涉及浮点数的除法,依旧和 C 语言一样,分整型除法和浮点型
除法,有一点和其他语言不一样的是,在 Elisp 里 <code>2.</code> 仍然是整型,只有 <code>2.0</code> 才被视为
浮点数,其他语言如 python 就将 <code>.2</code> 和 <code>2.</code> 都视为浮点数 <code>0.2</code> 和 <code>2.0</code> 了.
</p>

<p>
一个有用的小技巧是 Elsip 里许多判断类型的函数都是用 <code>***p</code> 或 <code>***-p</code> 来命名的,
比如下面判断是否为整型和浮点型的代码示例:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(integerp 2) <span style="color: #676E95;">; </span><span style="color: #676E95;">t</span>
(integerp 2.) <span style="color: #676E95;">; </span><span style="color: #676E95;">t</span>
(integerp 2.0) <span style="color: #676E95;">; </span><span style="color: #676E95;">nil</span>

(floatp 2) <span style="color: #676E95;">; </span><span style="color: #676E95;">nil</span>
(floatp 2.) <span style="color: #676E95;">; </span><span style="color: #676E95;">nil</span>
(floatp 2.0) <span style="color: #676E95;">; </span><span style="color: #676E95;">t</span>
</pre>
</div>
<blockquote>
<p>
另一个小规则, 以 "p" 结尾的函数通常返回值都是 "真" 值或"假" 值, Elisp 里一般 t
代表真值, nil 代表假值.
</p>
</blockquote>

<p>
另外还有取模运算求余数:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(% 7 4) <span style="color: #676E95;">; </span><span style="color: #676E95;">3</span>
</pre>
</div>
<p>
以及幂运算:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(expt 2 3) <span style="color: #676E95;">; </span><span style="color: #676E95;">8</span>
</pre>
</div>

<p>
更多关于数字计算的内容可以查阅Emacs 的 info 文档 <a href="https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Numbers">elisp#Numbers</a>
</p>
</div>
</div>

<div id="outline-container-orgeb74258" class="outline-4">
<h4 id="orgeb74258">整型/浮点型,数字/字符串类型转换</h4>
</div>

<div id="outline-container-org49990af" class="outline-4">
<h4 id="org49990af">光标位置函数</h4>
</div>
<div id="outline-container-org26bcbec" class="outline-4">
<h4 id="org26bcbec">文本编辑函数</h4>
</div>
</div>
<div id="outline-container-orga9a3171" class="outline-2">
<h2 id="orga9a3171"><span class="todo TODO">TODO</span> Emacs 的 Elisp 手册</h2>
<div class="outline-text-2" id="text-orga9a3171">
</div>
<div id="outline-container-orgd8959a2" class="outline-3">
<h3 id="orgd8959a2"><span class="todo TODO">TODO</span> 介绍</h3>
<div class="outline-text-3" id="text-orgd8959a2">
<p>
介绍和惯例用法
</p>
</div>
<div id="outline-container-orgb43e28a" class="outline-4">
<h4 id="orgb43e28a">TODO</h4>
</div>
<div id="outline-container-orgb184206" class="outline-4">
<h4 id="orgb184206">TODO</h4>
</div>
<div id="outline-container-org6b43b6a" class="outline-4">
<h4 id="org6b43b6a">TODO</h4>
<div class="outline-text-4" id="text-org6b43b6a">
</div>
<ul class="org-ul">
<li><a id="orgc8ef3e8"></a>TODO<br /></li>
<li><a id="org0464d25"></a><span class="todo TODO">TODO</span> <code>nil</code> 和 <code>t</code><br /></li>
</ul>
</div>
</div>

<div id="outline-container-org9659351" class="outline-3">
<h3 id="org9659351"><span class="done DONE">DONE</span> Lisp 数据类型(Lisp Data Types)</h3>
<div class="outline-text-3" id="text-org9659351">
<p>
Emacs Lisp 中对象的数据类型.
</p>

<p>
一个 Lisp 对象就是一块被 Lisp 程序使用和操作的数据. 在这个手册中, "类型"或"数据
类型" 是一组可能的对象.
</p>

<p>
每个对象至少属于一种类型. 相同类型的对象具有相似的结合并且通常在相同情况下使用.类
型可以重叠,对象可以属于两种或多种类型. 因此,我们可以询问某个对象是否属于特定类型,但
不能询问对象的类型.
</p>

<p>
Emacs 中内置了几个基本的对象类型. 所有的其他类型都是从这几个类型中构造出来的,因
此这几个类型被称为"primitive types"(原始类型). 每个对象都属于且仅属于一个基本类
型.这些原始类型包括 "integer", "float", "cons", "symbol", "string", "vector",
"hash-table", "subr", "byte-code function" 和 "record", 再加上几个特殊的类型,是
与编辑相关的,例如 "buffer" 类型(参见<a href="#org0ce4b6f">编辑类型(Editing Types)</a>)
</p>

<p>
每个原始类型有着对应的 Lisp 函数用来检测一个对象是否是该类型的成员.
</p>

<p>
Lisp 不像其他的语言,它的对象是 "类型自明" 的: 每个对象的原始类型就是对象本身的一
部分.例如如果一个对象是 vector 类型,没有什么能够将其作为数字处理, Lisp 知道它是
一个 vector 而不是数字.
</p>

<p>
在大多数语言中,程序员必需声明每个变量的数据类型,并且只有编译器知道该类型,但不会
表现在数据中. 这样的类型声明在 Emacs Lisp 中是不存在的. 一个 Lsip 变量可以有任意
类型的值,它会记住你储存在其中的值,类型和其他一切.(事实上,少数的 Emacs Lisp 变量
只能接收特定类型的值.参见<a href="#org15b5af2">有限制值的变量(Variables with Restricted Values)</a>)
</p>

<p>
这一章节会介绍 GNU Emacs Lisp 中每种标准类型的用途,打印表示和读取语法.有关如何使
用这些类型的详细信息,参考更后面的章节.
</p>
</div>

<div id="outline-container-org4204de3" class="outline-4">
<h4 id="org4204de3"><span class="done DONE">DONE</span> 打印表示(Printed Representation)</h4>
<div class="outline-text-4" id="text-org4204de3">
<p>
Lisp 对象如何表示为文本.
一个对象的 "打印表示" 就是该对象的 Lisp 打印器(函数 <code>prin1</code>) 生成的输出格式. 每
个数据类型都有独一无二的打印表示. 一个对象的 "读取语法" 就是该对象的 Lisp 读取器
(函数 <code>read</code>)  所接收的输入格式. 读取语法没必要独一无二;许多对象都有着不止一种语
法. 参见<a href="#orgf8513c7">读取和打印(Read and Print)</a>
</p>

<p>
在大多数情况下,一个对象的打印表示同时也是该对象的读取语法. 然而有些类型没有读取
语法,因为在一个 Lisp 程序中,输入这些类型的对象作为常量是没有意义的. 这些对象会以
"哈希表示法"的形式打印,哈希表示法由字符 <code>#&lt;</code> ,描述字符串(通常是类型名后接对象名),和
一个关闭字符 <code>&gt;</code> 组成. 例如:
</p>
<pre class="example" id="org65b4dee">
(current-buffer)
     ⇒ #&lt;buffer objects.texi&gt;
</pre>

<p>
哈希表示法完全不能被读取,因此每当 Lisp 读取器遇到 "#&lt;" 时,就会发出"无效读取语法
"(invalid-read-syntax)的错误信号.
</p>

<p>
在其他语言中一个表达式是文本,没有其他的形式. 在 Lisp 中,一个表达式首先是一个
Lisp 对象,其次才是该对象读取语法的文本. 通常来说,没有必要强调这个区别,但是你必需
记住这一区别,否则你有时会非常困惑.
</p>

<p>
当你交互式执行一个表达式时, Lisp 解释器首先读取该表达式的文本表达,生成一个 Lisp
对象,然后执行该对象(参见 <a href="#org8786ce9">求值(Evaluation)</a>). 然而,执行和读取是分开的活动.读取操作
返回读取到的文本表示的 Lisp 对象; 随后可能执行该对象,也可能不执行. 关于读取对象
的基本函数 <code>read</code> 的描述参见 <a href="#orgdd8af85">输入函数 (Input Functions)</a> .
</p>
</div>
</div>

<div id="outline-container-org1c51290" class="outline-4">
<h4 id="org1c51290"><span class="done DONE">DONE</span> 特殊的读取语法(Special Read Syntax)</h4>
<div class="outline-text-4" id="text-org1c51290">
<p>
所有特殊序列的概述.
</p>

<p>
Emacs Lisp 使用哈希表示法来表示许多特殊的对象和结构.
</p>

<dl class="org-dl">
<dt><code>#&lt;...&gt;</code></dt><dd>没有读取语法的对象会这样表示(参见 <a href="#org4204de3">打印表示(Printed Representation)</a>).</dd>
<dt><code>##</code></dt><dd>名称为空字符串的内部符号的打印表示(参见 <a href="#org8291fa7">符号类型(Symbol Type)</a> ).</dd>
<dt><code>#'</code></dt><dd>这是 <code>function</code> 的简写,参见<a href="#orgbf27a2a">匿名函数(Anonymous Functions)</a>.</dd>
<dt><code>#:</code></dt><dd>名称为 FOO 的非内部符号的打印表示是
<code>#:FOO</code> (参见 <a href="#org8291fa7">符号类型(Symbol Type)</a> ).</dd>
<dt><code>#N</code></dt><dd><p>
当打印 circular 结构时,这个构造用来表示结构循环回到自身的位置, N 是列
表计数的开始:
</p>
<pre class="example" id="orgdbcbeb5">
	    (let ((a (list 1)))
	      (setcdr a a))
	    =&gt; (1 . #0)
</pre></dd>
<dt><code>#N=</code> <code>#N#</code></dt><dd><code>#N=</code> 赋予一个对象名字, <code>#N#</code> 表示这个对象,所以,当从对象中读回
时,它们是相同的对象而不是副本(参见 <a href="#org208487c">循环对象(Circular Objects)</a>)</dd>
<dt><code>#xN</code></dt><dd>N 表示一个十六进制数( <code>#x2a</code> ).</dd>
<dt><code>#oN</code></dt><dd>N 表示一个八进制数( <code>#o52</code> ).</dd>
<dt><code>#bN</code></dt><dd>N 表示一个二进制数( <code>#b101010</code> ).</dd>
<dt><code>#(...)</code></dt><dd>字符串文本属性(参见<a href="#org6842192">文本属性和字符串(Text Props and Strings)</a>).</dd>
<dt><code>#^</code></dt><dd>一个字符表,参见 <a href="#orgaee97ae">字符表类型(Char-Table Type)</a>.</dd>
<dt><code>#s(hash-bale ...)</code></dt><dd>一个哈希表,参见 <a href="#org2a8e6a9">哈希表类型(Hash Table Type)</a>.</dd>
<dt><code>?C</code></dt><dd>一个字符,参见<a href="#org6a37950">基本字符语法(Basic Char Syntax)</a>.</dd>
<dt><code>#$</code></dt><dd>在字节编译的文件中的当前文件名(参见
<a href="#org3638602">文档和编译(Docs and Compilation)</a>). 这个表示法不是用于 Emacs Lisp 源文件中的.</dd>
<dt><code>#@N</code></dt><dd>跳过下面 N 个字符(参见<a href="#org9ba3a65">注释(Comments)</a>). 这个是用在字节编译的文件中的,
不是用在 Emacs Lisp 源文件中的.</dd>
<dt><code>#f</code></dt><dd>表明下面的形式不是 Emacs Lisp 读取器可读的. 这只会在用于显示的文本(当
文本看起来比表明不可读的形式这种方式更美观时)中出现,并且永远不会出现在任何
Lisp 文件中.</dd>
</dl>
</div>
</div>

<div id="outline-container-org9ba3a65" class="outline-4">
<h4 id="org9ba3a65"><span class="done DONE">DONE</span> 注释(Comments)</h4>
<div class="outline-text-4" id="text-org9ba3a65">
<p>
注释和它们的格式惯例.
</p>

<p>
一个注释,就是程序中只为了让人类阅读程序而编写的文本,注释对程序的意义没有任何影响.
</p>

<p>
在 Lisp 中,如果注释不是写在一个字符串中或是字符常量中,则注释以一个未转义的分号开
头(<code>;</code>). 注释一直到行尾结束. Lisp 读取器会丢弃注释;它们不会成为 Lisp 对象的一部
分,这里的对象表示 Lisp 系统中的程序.
</p>

<p>
<code>#@COUNT</code> 构造会跳过下面的 COUNT 个字符,对于程序生成的包含二进制数据的注释非常有
用. Emacs Lisp 字节编译器在它的输出文件中使用这一构造
(参见 <a href="#org83b295a">字节编译(Byte Compilation)</a>), 然而这个构造不适用于源文件.
</p>

<p>
注释的格式惯例请参阅 <a href="#org5245b99">注释提示(Comment Tips)</a>.
</p>
</div>
</div>


<div id="outline-container-org4c0aa1c" class="outline-4">
<h4 id="org4c0aa1c"><span class="done DONE">DONE</span> 编程类型(Programming Types)</h4>
<div class="outline-text-4" id="text-org4c0aa1c">
<p>
所有 Lisp 系统中都可以找到的类型.
</p>
</div>

<ul class="org-ul">
<li><a id="org9b6f3aa"></a><span class="done DONE">DONE</span> 整数类型(Integer Type)<br />
<div class="outline-text-5" id="text-org9b6f3aa">
<ul class="org-ul">
<li>State "DONE"       from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-19 Sun 09:27]</span></span></li>
</ul>
<p>
没有小数部分的数字.
</p>

<p>
在底层,有两种整数类型,小整数类型(称为 "fixnums") 和大整数类型(称为 "bignums").
</p>

<p>
小整数类型的取值范围取决于机器,最小的范围是 -536,870,912 到 536,870,911 (30 位,
也就是 -2**29 到 2**29-1).但是许多机器都提供了更大的范围.
</p>

<p>
大整数类型可以有任意精度.让小整数类型溢出的操作会返回一个大整数类型.
</p>

<p>
所有的数字都可以用 <code>eql</code> 或 <code>=</code> 比较; 小整数类型还可以用 <code>eq</code> 来比较. 要测试一个
整数类型是大整数类型还是小整数类型,你可以用 <code>most-negative-fixnum</code> 和
<code>most-positive-fixnum</code>, 来比较这个整数(就是和最大最小的小整数型数比较大小),或者
你也可以对任意对象使用便利断言 <code>fixnump</code> 和 <code>bignump</code> .
</p>

<p>
整数的读取语法是一个(以10为基数)的数字序列,开头带有一个可选的符号结尾有一个可选
的句号.由 Lisp 解释器产生的打印表示则不会有前导的 "+" 或结尾的 "."
</p>
<pre class="example" id="org54f589f">
-1               ; The integer −1.
1                ; The integer 1.
1.               ; Also the integer 1.
+1               ; Also the integer 1.
</pre>

<blockquote>
<p>
读取语法就是 Lisp 解释器能够识别能够理解的某种写法,例如上面这几个数字,一个1,写在
程序里写成 <code>1</code>, <code>+1</code>, <code>+1.</code>, <code>1.</code> 或 <code>+1.</code> Lisp 解释器都能理解这是数字1.例如
(+ 1. +2.) 的执行结果是 3, 说明 Lisp 解释器正确读取了这里这种写法的2 和 1.
</p>
</blockquote>

<p>
更详细的信息,请查阅 <a href="#orgf4cc629">数字(Numbers)</a>.
</p>
</div>
</li>

<li><a id="org722b65b"></a><span class="done DONE">DONE</span> 浮点类型(Floating-Point Type)<br />
<div class="outline-text-5" id="text-org722b65b">
<ul class="org-ul">
<li>State "DONE"       from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-19 Sun 12:08]</span></span></li>
</ul>
<p>
有小数部分且范围大的数字.
</p>

<p>
浮点数等于是计算机上的科学计数法.你可以认为浮点数是一个小数和10的幂组成. 有效数
字的精度值和10 的指数范围取决于机器; Emacs 使用 C 的数据类型 <code>double</code> 来储存这个
值,并且在内部记录的是2的幂而不是10的幂.
</p>

<p>
浮点数的打印表示需要有小数点(小数点后至少有一位数字),指数,或是两者都有. 例如,
<code>1500.0</code> , <code>+15e2</code>, <code>15.0e+2</code>, <code>+1500000e-3</code> 和 <code>.15e4</code> 是 1500 这个值的5种浮点
数写法,他们都是相等的.
</p>

<p>
更详细的信息,请查阅 <a href="#orgf4cc629">数字(Numbers)</a>.
</p>
</div>
</li>

<li><a id="orga65fe6b"></a><span class="done DONE">DONE</span> 字符类型(Character Type)<br />
<div class="outline-text-5" id="text-orga65fe6b">
<p>
(setq org-enforce-todo-dependencies t)
字母,数字,和控制字符的表现形式.
</p>

<p>
Emacs Lisp 中的一个字符就是一个整数. 换句话说,字符是由他们的字符编码表示的.例如,
字符 <code>A</code> 是用整数 65 表示的.
</p>

<p>
单个字符在程序中偶尔会用到,但是更多的使用的是字符串,也就是字符组成的序列.
参见<a href="#org3fe47cb">字符串类型(String Type)</a>.
</p>

<p>
字符串和缓冲区中的字符目前限制在范围 0到4194303,也就是 20 位(参见
<a href="#org65793c7">字符编码 (Character Codes)</a>). 编码0到127 是 ASCII 编码;剩下的是非 ASCII 编码(参见
<a href="#org9ab52af">非 ASCII 字符(Non-ASCII Characters)</a>). 表示键盘输入的字符有更广的范围,因为要编码
修饰符按键,例如 Control, Meta 和 Shift 键.
</p>

<p>
出于消息显示的原因,还有一些特殊的函数用于生成一个字符的人类可读的文本描述.
参见<a href="#org8a84f14">描述字符(Describing Characters)</a>.
</p>
</div>


<ul class="org-ul">
<li><a id="org6a37950"></a><span class="done DONE">DONE</span> 基本字符语法(Basic Char Syntax)<br />
<div class="outline-text-6" id="text-org6a37950">
<ul class="org-ul">
<li>State "DONE"       from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-19 Sun 13:12]</span></span></li>
</ul>
<p>
常规字符的语法.
</p>

<p>
因为字符就是数字,所以字符的打印表示就是一个十进制数. 这同时也是字符的读取语法,但
是在 Lisp 程序中用这种方式编写字符不是一个清楚的编程方式.你应该一直使用 Emacs
Lisp 为字符提供的特殊读取语法. 这些语法格式以一个问号作为开始.
</p>

<p>
常用的字母表中的字母的读取语法是一个问号后面跟着字符;因此, <code>?A</code> 表示字符 <code>A</code>,
<code>?B</code> 表示字符 <code>B</code>, <code>?a</code> 表示字符 <code>a</code>.
</p>

<p>
例如:
</p>
<pre class="example" id="org75d3b93">
     ?Q ⇒ 81     ?q ⇒ 113
</pre>

<p>
对标点符号你也可以使用相同的语法. 但是,如果表单符号在 Lisp 中有着特殊语法含义,那
么你就必须要用 <code>\</code> 来引用它. 例如 <code>?\(</code> 是编写开括号字符的方式.同样地,如果字符是
<code>\</code>,你就必须使用第二个 <code>\</code> 来引用它: <code>?\\</code>.
</p>

<p>
你可以使用 <code>?\a</code>, <code>?\b</code>, <code>?\t</code>, <code>?\n</code>, <code>?\v</code>, <code>?\f</code>, <code>?\s</code>, <code>?\r</code>, <code>?\d</code>,
和 <code>?\e</code>  来分别表示 control-g, backspace(回退向左删除),tab(制表符),newline(换行),
vertical tab( 纵向制表符),formfeed(换页),space (空格), return (回车), del (删除,
向右删除) 和 escape (转义字符)( <code>?\s</code> 后面跟一个破折号有着不同的意义,它会将
Super 修饰符应用于下面的字符.).因此,
</p>
<pre class="example" id="orgca3cd24">
?\a ⇒ 7                 ; control-g, ‘C-g’
?\b ⇒ 8                 ; backspace, &lt;BS&gt;, ‘C-h’
?\t ⇒ 9                 ; tab, &lt;TAB&gt;, ‘C-i’
?\n ⇒ 10                ; newline, ‘C-j’
?\v ⇒ 11                ; vertical tab, ‘C-k’
?\f ⇒ 12                ; formfeed character, ‘C-l’
?\r ⇒ 13                ; carriage return, &lt;RET&gt;, ‘C-m’
?\e ⇒ 27                ; escape character, &lt;ESC&gt;, ‘C-[’
?\s ⇒ 32                ; space character, &lt;SPC&gt;
?\\ ⇒ 92                ; backslash character, ‘\’
?\d ⇒ 127               ; delete character, &lt;DEL&gt;
</pre>

<p>
这些以反斜杠开头的序列也被叫做 "转义序列", 因为反斜杠是作为一个转义字符; 转义对
<code>&lt;ESC&gt;</code>  字符无效. <code>\s</code> 是用在字符常量中的,在字符串常量中,只需要直接写入空格.
</p>

<p>
反斜杠在任意没有特殊转义含义的字符前都是允许的,无害的;因此 <code>?\+</code> 等价与 <code>?+</code>. 在
大多数字符前加一个反斜杠都是毫无道理的. 但是,你必须在这些字符中的任意一个前加上
反斜杠: <code>()[]\;"</code> , 在这些字符的任意一个前,你也应该加上反斜杠: <code>|'`#.,</code> ,这样做
是为了避免将 Emacs 命令和编辑 Lisp 代码搞混. 你也应该在 Unicode 字符前加上反斜杠,
Unicode 字符和前面提到过的 ASCII 字符类似, 这样做是为了避免阅读你代码的人感到困
惑. Emacs 会高亮某些未转义的且经常弄混的字符,例如 <code>‘</code> 字符,来刺激拥护转义它. 你
也可以在空白字符前添加反斜杠,例如空格,制表符,换行符和换页符. 然而,使用一个更容易
阅读的转义序列,例如 <code>\t</code>, <code>\s</code>, 而不是实际的空白字符(例如制表符或空白) 会让代码
更干净.(如果你真的在空格前写入了一个反斜杠,你需要在这个字符常量之后写入一个额外
的空格来将其与后面的文本区分开.)
</p>

<blockquote>
<p>
在程序中调用 Emacs 的快捷键可能会用到转义;
</p>

<p>
需要特殊字符作为常量,也会用到转义;
</p>
</blockquote>
</div>
</li>
<li><a id="org3fed69d"></a><span class="done DONE">DONE</span> 通用转义语法(General Escape Syntax)<br />
<div class="outline-text-6" id="text-org3fed69d">
<ul class="org-ul">
<li>State "DONE"       from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-19 Sun 14:14]</span></span></li>
</ul>
<p>
如何通过字符编码指定字符.
</p>

<p>
除了特殊的重要控制字符的特殊转义序列之外, Emacs 还提供了几种你可以用来指定非
ASCII 文本字符的转义语法.
</p>

<ul class="org-ul">
<li>如果有字符,你可以通过字符的 Unicode 名称来指定它们. <code>?\N{NAME}</code> 表示一个名字为
NAME 的 Unicode 字符. 因此, <code>?\N{LATIN SMALL LETTER A WITH GRAVE}</code> 就等价于
<code>?à</code>,表示的是 Unicode 字符 U+00E0. 为了化简键入多行字符串的操作,你可以将名字中
的空格替换为空白的非空序列(例如,换行符的序列).</li>

<li>你可以通过字符的 Unicode 值来指定字符. <code>?\N{U+X}</code> 表示一个 Unicode 编码为 X 的
字符, X 是一个十六进制数. <code>?\uXXXX</code>  和  <code>?\UXXXXXXXX</code> 也分别表示编码点为 XXXX
和 XXXXXXXX 的字符, 这里的每个 X 都是单个十六进制数字. 例如, <code>?N{U+E0}</code>,
<code>?u00e0</code> 和 <code>?\U000000E0</code> 都是等价于 <code>?à</code> 和
<code>?\N{LATIN SMALL LETTER A WITH GRAVE}</code> 的. Unicode 标准定义编码点最高为
<code>U+10FFFF</code>, 所以你指定了一个高于该编码点的值, Emcas 会发出错误信号.</li>

<li>你可以使用字符的十六进制字符编码来指定字符. 一个十六进制转义序列由一个反斜杠,~x~
和十六进制字符编码组成. 例如, <code>?\x41</code> 是字符 <code>A</code>, <code>?\x1</code> 是字符 <code>C-a</code>, <code>?\xe0</code>
是字符 <code>à</code> (带沉音符的a). 你可以使用任意数量的十六进制数,所以使用这种方式你可
以表示任意字符编码.</li>

<li>你可以通过字符的八进制字符编码来指定字符. 一个八进制转义序列由一个反斜杠后面跟
着最多三个八进制位组成; 例如, <code>?\101</code> 是字符 <code>A</code> , <code>?\001</code> 是字符 <code>C-a</code>,
<code>?\002</code> 是字符 <code>C-b</code>. 只有八进制编码在 777 以下的字符可以通过这种方式指定.</li>
</ul>


<p>
这些转义序列也可以用在字符串中.参见<a href="#org9c761e4">字符串中的非 ASCII 字符(Non-ASCII in Strings)</a>.
</p>
</div>
</li>

<li><a id="org08eddfd"></a><span class="done DONE">DONE</span> 控制字符语法(Ctl-Char Syntax)<br />
<div class="outline-text-6" id="text-org08eddfd">
<ul class="org-ul">
<li>State "DONE"       from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-19 Sun 14:37]</span></span></li>
</ul>
<p>
控制字符的语法.
</p>

<p>
控制字符可以使用另一种读取语法表示.
</p>

<p>
这种语法由一个问号后面跟着一个反斜杠,脱字号(<code>^</code>),和相应的非控制字符(大小写都行)
组成.例如, <code>?\^I</code> 和 <code>?\^i</code> 都是字符 <code>C-i</code> 的有效读取语法, 这个字符的值是9.
</p>

<p>
你也可以使用 <code>C-</code> 来代替 <code>^</code>; 因此, <code>?\C-i</code> 等价于 <code>?\^I</code> 和 <code>?\^i</code>:
</p>
<pre class="example" id="orgc7075ea">
     ?\^I ⇒ 9     ?\C-I ⇒ 9
</pre>

<p>
在字符串和缓冲区中,只允许使用 ASCII 中存在的字符; 但出于键盘输入的目的,你可以用
<code>C-</code> 将任意字符转换成控制字符. 这些非 ASCII 控制字符和相应的非控制字符的字符编码
有 2**26 位. 不是所有的文本终端都能生成非 ASCII 控制字符,但是用 X 和其他窗口系统
来生成它们是很简单的.
</p>

<p>
由于历史原因, Emacs 将 <code>&lt;DEL&gt;</code> 字符视为 <code>?</code> 的控制等价物:
</p>
<pre class="example" id="org1d76c49">
     ?\^? ⇒ 127     ?\C-? ⇒ 127
</pre>

<p>
因此,在目前无法使用 <code>\C-</code> 来表示字符 <code>Control-?</code> ,这个字符是 X 系统下的一个有意
义的输入字符. 要改变这一点并不容易,因为各种 Lisp 文件都使用这种方式引用了 <code>&lt;DEL&gt;</code>.
</p>

<p>
对于表示在文件或字符串中找到的控制字符,我们推荐使用 <code>^</code> 语法;对于键盘输入的控制
字符,我们更喜欢 <code>C-</code> 语法. 你使用哪种方式都不影响程序的意义,但可能会引导阅读程序
的人的理解.
</p>
</div>
</li>

<li><a id="org031aa09"></a><span class="done DONE">DONE</span> Meta 字符语法(Meta-Char Syntax)<br />
<div class="outline-text-6" id="text-org031aa09">
<ul class="org-ul">
<li>State "DONE"       from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-19 Sun 15:53]</span></span></li>
</ul>
<p>
meta 字符的语法.
</p>

<p>
一个"meta"字符就是一个使用 &lt;META&gt; 修饰符键入的字符. 表达这样一个字符的数字有
2**27 位组. 我们对这个字符和其他修饰符使用高位,来让广泛的基本字符编码成为可能.
</p>

<p>
在字符串中,附加到 ASCII 字符的 2**27 位表示一个 meta 字符;因此,可以放入字符串的
meta 字符的范围是从 128 到 255,而且是普通字符的 meta 版本. 关于字符串中处理
&lt;META&gt; 的详细信息请参考 <a href="#orgad73c35">事件字符串(Strings of Events )</a>.
</p>

<p>
meta 字符的读取语法使用 <code>\M-</code>. 例如, <code>?\M-A</code> 表示 <code>M-A</code>. 你可以把 <code>\M-</code> 和八进制
字符编码, <code>\C-</code> ,或是任意其他字符的语法一起使用. 因此,你可以将字符 <code>M-A</code> 写成
<code>?\M-A</code>, 或是 <code>?\M-\101</code>. 相同的,你也可以把字符 <code>C-M-b</code> 写成 <code>?\M-\C-b</code>,
<code>?\C-\M-b</code> 或 <code>?\M-\002</code>.
</p>
</div>
</li>

<li><a id="org19ef380"></a><span class="done DONE">DONE</span> 其他字符位(Other Char Bits)<br />
<div class="outline-text-6" id="text-org19ef380">
<ul class="org-ul">
<li>State "DONE"       from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-19 Sun 16:29]</span></span></li>
</ul>
<p>
hyper-, super- 和 alt 字符的语法.
</p>

<p>
图形字符的大小写由其字符编码表示; 例如, ASCII 编码区分字符 <code>a</code> 和 <code>A</code>. 但是
ASCII 编码没有表示一个控制字符是大写还是小写的方法. Emacs 使用 2**25 位来表明
在键入控制字符时 Shift 键的使用.这种区分只在图形显示上是可能的(例如 X 环境的 GUI
显示); 文本终端不会显示这种区别. Shift 位的 Lisp 语法是 <code>\S-</code> ; 因此 <code>?\C-\S-o</code>
或 <code>?\C-\S-O</code> 表示的是 shift 键按下时的控制字符 control-o .
</p>

<p>
X 窗口系统定义了另外三个可以在字符中设置的修饰符位: <code>hyper</code>, <code>super</code> 和 <code>alt</code>
. 这三个位的语法是 <code>\H-</code>, <code>\s-</code> 和 <code>\A-</code> .(大小写在这些前缀中是区分的.)因此,
<code>?\H-\M-\A-x</code> 表示的是 <code>Alt-Hyper-Meta-x</code> .(请注意, <code>\s</code> 后面不接 <code>-</code> 表示的是空
格这个字符.)从数字上看, alt 的比特值是 2**22, super 的是 2**23, hyper 的是 2**24.
</p>
</div>
</li>
</ul>
</li>

<li><a id="org8291fa7"></a><span class="done DONE">DONE</span> 符号类型(Symbol Type)<br />
<div class="outline-text-5" id="text-org8291fa7">
<ul class="org-ul">
<li>State "DONE"       from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-20 Mon 10:18]</span></span></li>
</ul>
<p>
<a href="https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Symbol-Type">elisp#Symbol Type</a>
一个指向函数,变量,或属性列表的多用途对象,且具有唯一标识.
</p>

<p>
GNU Emacs Lisp 中的一个"符号"就是一个有名字的对象.符号名用于符号的打印表示. 在只
有单个 obarray(object 数组,对象数组)(参见 <a href="#org5f3730c">创建符号(Creating Symbols)</a>)的普通 Lisp
用法中,一个符号的名字是唯一的,没有两个符号有相同的名字.
</p>

<p>
符号可以作为变量,函数名,或是属性列表.或是它可以只用来区别于其他所有的 Lisp 对象,
以便可以在数据结构中可靠地识别它的存在. 在给定的环境中,通常只会使用这些用法中的
一种. 但是你可以单独的用上面的所有方式来使用一个符号(也就是说一个符号可以作为变
量,函数名,属性列表,或只是为了区分的用途.).
</p>

<p>
名字以 <code>:</code> 冒号开头的符号叫做 "关键字符号". 这种符号会自动充当常量,并且通常只通
过将未知符号与少数特定的替代符号进行比较来使用. 参见<a href="#orgde44202">常量(Constant Variable)</a>.
</p>

<p>
符号名可以包含任意字符. 大多数符号名是由字母,数字和标点符号(<code>-+=*/</code>)书写的.这些
名字要求不能有特殊标点符号; 只要名字的字符让名字看起来不像数字就足够了.(如果确实
像数字,在名称的前面加上一个 <code>\</code> 来强制将其解释为符号.) <code>_@_!@$%^&amp;:&lt;&gt;{}?</code> 这些字
符较少使用,但同样也不能有特殊标点. 任何其他的字符也可以通过用反斜杠转义它们的方
式来在符号名中使用. 然而,与字符串中使用反斜杠相反,符号名中的反斜杠只是引用反斜杠
后面的单个字符.例如,在字符串中, <code>\t</code> 表示一个制表符;然而,在符号名中, <code>\t</code> 只表示
引用字母 t. 要让符号名中有一个制表符,你必需真正使用一个制表符(前面加一个反斜杠).但
是很少会做这样的事情.
</p>

<blockquote>
<p>
Common Lisp 提示: 在 Common Lisp 中,除非显式转义,否则所有小写总是整合到大写中.
在 Emacs Lisp 中,大写和小写字母则是不同的.
</p>
</blockquote>

<p>
下面是一些符号名的例子. 请注意,在第四个例子中的 <code>+</code> 被转义了是为了防止它被读取乘
一个数字. 这在第六个例子中是没有必要的,因为名字的剩下部分让它不能作为一个数字.
</p>
<pre class="example" id="org84589e4">
foo                 ; A symbol named ‘foo’.
FOO                 ; A symbol named ‘FOO’, different from ‘foo’.
1+                  ; A symbol named ‘1+’
                    ;   (not ‘+1’, which is an integer).
\+1                 ; A symbol named ‘+1’
                    ;   (not a very readable name).
\(*\ 1\ 2\)         ; A symbol named ‘(* 1 2)’ (a worse name).
+-*/_~!@$%^&amp;=:&lt;&gt;{}  ; A symbol named ‘+-*/_~!@$%^&amp;=:&lt;&gt;{}’.
                    ;   These characters need not be escaped.
</pre>

<p>
一个符号名作为其打印表示的规则的例外, <code>##</code> 是一个名字为空字符串的内部符号的打印
表示.此外, <code>#:FOO</code> 是一个名字为 <code>FOO</code> 的非内部符号的打印表示.(通常情况下, Lisp
读取器会内部化所有符号; 参见 <a href="#org5f3730c">创建符号(Creating Symbols)</a>)
</p>
</div>
</li>
<li><a id="org7920d83"></a><span class="done DONE">DONE</span> 序列类型(Sequence Type)<br />
<div class="outline-text-5" id="text-org7920d83">
<ul class="org-ul">
<li>State "DONE"       from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-20 Mon 10:42]</span></span></li>
</ul>
<p>
列表和数组都归类为序列.
</p>

<p>
一个 "序列" 就是一个表示有序元素集的 Lisp 对象. Emacs Lisp 中有两种序列: 列表和
数组.
</p>

<p>
列表是最常用的序列. 一个列表可以储存任意类型的元素,列表的长度可以通过添加和删除
元素很容易地修改.列表的更多信息参见后面的小节.
</p>

<p>
数组是固定长度的序列.它们被进一步细分为字符串,向量,字符表和布尔向量. 向量可以储
存任意类型的元素,然而,字符串的元素必须是字符,布尔向量的元素必需是 <code>t</code> 或
<code>nil</code>. 字符表和向量类似,但字符表是由任意有效的字符编码索引的. 字符串中的字符像缓
冲区中的字符一样,可以有文本属性(参见<a href="#org05aca52">文本属性(Text Properties)</a>), 但是即使当向量的
元素恰巧是字符时,向量也不支持文本属性.
</p>

<p>
列表,字符串和其他数组类型都有着重要的相似性.例如,都有一个长度 L, 都有着索引从0到
L-1 的元素.有几个函数,叫做序列函数,可以接受各种序列. 例如, <code>length</code> 函数会报告任
意类型序列的长度. 参见 <a href="#orgc0e0dcf">序列 数组 向量(Sequences Arrays Vectors)</a>.
</p>

<p>
通常不可能读取同一个序列两次,因为序列总是在读取时重新创建的. 如果你读取一个序列
的读取代码两次,你会得到具有相同内容的两个序列.不过有一个例外: 空列表 <code>()</code> 总是表
示相同的对象,即 <code>nil</code>.
</p>
</div>
</li>
<li><a id="org31f8654"></a><span class="done DONE">DONE</span> Construction of Cell 类型(Cons Cell Type)<br />
<div class="outline-text-5" id="text-org31f8654">
<p>
Cons cells 和 cons cells 产生的列表.
</p>

<p>
一个 cons cell 是由两个插槽组成的对象,这两个插槽叫做 CAR 槽和 CDR 槽. 每个插槽都
可以储存任意 Lisp 对象. 我们也称 cons cell 的 CAR 是 CAR 槽当前持有的任意对象,
CDR 也是如此.
</p>

<p>
一个列表,就是一系列连接在一起的 cons cell, 所以每个 cons cel 的 CDR 槽能储存下一
个 cons cel 或空列表. 空列表实际上是符号 <code>nil</code>. 详细信息参见 <a href="#orgaeae923">列表(Lists)</a>. 因为大
多数 cons cell 都用作列表的一部分,所以我们把由 cons cell 组成的任何结构都叫做 "
列表结构".
</p>

<blockquote>
<p>
给 C 程序员的提示: 一个 Lisp 列表像一个由 cons cell 构造的"链式列表"一样工作. 因
为 Lisp 的指针是隐式的,我们不区分一个 cons cell 是持有值还是指向值.
</p>
</blockquote>

<p>
因为 cons cell 对 Lisp 来说是如此重要,所以我们也有一个词来表示不是 cons cell 的
对象. 这些对象被叫做 "atoms" (原子).
</p>

<p>
列表的读取语法和打印表示是相同的,由一个左括号,任意数量的元素和一个右括号组成.下
面是一些列表的例子:
</p>

<pre class="example" id="orga4eb08b">
(A 2 "A")            ; A list of three elements.
()                   ; A list of no elements (the empty list).
nil                  ; A list of no elements (the empty list).
("A ()")             ; A list of one element: the string ‘"A ()"’.
(A ())               ; A list of two elements: ‘A’ and the empty list.
(A nil)              ; Equivalent to the previous.
((A B C))            ; A list of one element
                     ;   (which is a list of three elements).
</pre>

<p>
在读取的时候,括号内的每个对象都会成为列表的一个元素. 也就是说,每个元素都是一个
cons cell. cons cell 的 CAR 插槽储存元素, CDR 插槽指向列表的下一个 cons cell, 这
个 cons cell 储存的是列表的下一个元素.最后一个 cons cell 的 CDR 插槽被设置为储存
<code>nil</code>.
</p>

<p>
CAR 和 CDR 这个两个名字来自于 Lisp 的历史.最原始的 Lisp 实现运行在 IBM 704 计算
机上,该机器将指令分成两个部分,地址和递减量; CAR 是提取寄存器地址部分内容的指令,
CDR 是提取递减量内容的指令. 相比之下, cons cells 是以创建它们的函数 <code>cons</code> 命名
的,是反过来以其用途命名,即构造单元(construction of cells).
</p>

<blockquote>
<p>
CAR (Content of Address Register, 地址寄存器的内容),CDR (Content of Decrement
Register, 递减量寄存器的内容)
</p>
</blockquote>
</div>

<ul class="org-ul">
<li><a id="org37b809b"></a><span class="done DONE">DONE</span> 方框图(Box Diagrams)<br />
<div class="outline-text-6" id="text-org37b809b">
<ul class="org-ul">
<li>State "DONE"       from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-20 Mon 14:18]</span></span></li>
</ul>
<p>
绘制列表图片.
</p>

<p>
列表可以用图表来说明,其中 cons cell 用成对的方框来表示,就像多米诺骨牌一样. Lisp
读取器无法读取这样的说明;与能同时被人类和计算机理解的文本符号不同,这种方框图的说
明只能被人类理解. 下面这个图表示的是有三个元素的列表 <code>(rose violet buttercup)</code>:
</p>
<pre class="example" id="orgc1d83e0">
         --- ---      --- ---      --- ---
        |   |   |--&gt; |   |   |--&gt; |   |   |--&gt; nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
           --&gt; rose     --&gt; violet   --&gt; buttercup
</pre>
<p>
在这个图中,每个方框表示一个可以储存或指向任意 Lisp 对象的插槽. 每个方框对表示一
个 cons cell. 每个箭头表示一个引用,引用指向一个 Lisp 对象,一个原子或其他 cons cell.
</p>

<p>
在这个例子中,第一个方框,代表第一个 cons cell 的 CAR, 它指向或储存 <code>rose</code> (一个符
号).第二个方框,代表第一个 cons cell 的 CDR, 指向下一个方框对,也就是第二个 cons
cell. 第二个 cons cell 的 CAR 是 <code>violet</code>, 它的 CDR 是第三个 cons cell. 第三个
(最后一个) cons cell 的 CDR 是 <code>nil</code>.
</p>

<p>
下面是同一个列表的另一种图表,以不同的方式绘制 <code>(rose violet buttercup)</code> :
</p>
<pre class="example" id="orgc6ed22d">
 ---------------       ----------------       -------------------
| car   | cdr   |     | car    | cdr   |     | car       | cdr   |
| rose  |   o--------&gt;| violet |   o--------&gt;| buttercup |  nil  |
|       |       |     |        |       |     |           |       |
 ---------------       ----------------       -------------------
</pre>

<p>
一个没有元素的列表是"空列表";空列表和符号 <code>nil</code> 完全相同. 换句话说, <code>nil</code> 既是一
个列表也是一个符号.
</p>

<p>
下面是用方框和箭头描绘出的列表 <code>(A ())</code> 或等价的 <code>(A nil)</code>:
</p>
<pre class="example" id="org90c089d">
         --- ---      --- ---
        |   |   |--&gt; |   |   |--&gt; nil
         --- ---      --- ---
          |            |
          |            |
           --&gt; A        --&gt; nil
</pre>

<p>
下面是一个更复杂的说明,演示的是一个三元素的列表, <code>((pine needles) oak maple)</code> ,
其第一个元素是一个两元素的列表:
</p>
<pre class="example" id="orge5203e7">

         --- ---      --- ---      --- ---
        |   |   |--&gt; |   |   |--&gt; |   |   |--&gt; nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
          |             --&gt; oak      --&gt; maple
          |
          |     --- ---      --- ---
           --&gt; |   |   |--&gt; |   |   |--&gt; nil
                --- ---      --- ---
                 |            |
                 |            |
                  --&gt; pine     --&gt; needles
</pre>
<p>
同一个列表使用第二种方框表示法来描述是这样的:
</p>
<pre class="example" id="org09c13a3">

      --------------       --------------       --------------
     | car   | cdr  |     | car   | cdr  |     | car   | cdr  |
     |   o   |   o-------&gt;| oak   |   o-------&gt;| maple |  nil |
     |   |   |      |     |       |      |     |       |      |
      -- | ---------       --------------       --------------
         |
         |
         |        --------------       ----------------
         |       | car   | cdr  |     | car     | cdr  |
          ------&gt;| pine  |   o-------&gt;| needles |  nil |
                 |       |      |     |         |      |
                  --------------       ----------------

</pre>
</div>
</li>

<li><a id="orge3c05bd"></a><span class="done DONE">DONE</span> 点对表示法(Dotted Pair Notation)<br />
<div class="outline-text-6" id="text-orge3c05bd">
<ul class="org-ul">
<li>State "DONE"       from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-20 Mon 17:17]</span></span></li>
</ul>
<p>
cons cell 的通用语法.
</p>

<p>
点对表示法是 cons cell 的通用语法,用于显式地表示 CAR 和 CDR. 在这种语法中 <code>(A
. B)</code> 表示一个 cons cell ,其 CAR 是对象 A, CDR 是对象 B. 点对表示法比列表语法更
通用,因为 CDR 不必是列表. 然而,在列表语法可以生效的情况下,点对表示法会更麻烦.在
点对表示法中,列表 <code>(1 2 3)</code> 会写成 <code>(1 . (2 . (3 . nil)))</code> .对于以 <code>nil</code> 结尾的
列表,你可以使用这两种方法,但是列表表示法通常更整洁,更方便. 当打印一个列表时,只有
当 cons cell 的 CDR 不是一个列表的时候,才会使用点对表示法.
</p>

<p>
下面是一个使用图表来解释点对表示法的例子. 这个例子演示的是 <code>(rose . violet)</code> 对:
</p>
<pre class="example" id="org86fed86">
         --- ---
        |   |   |--&gt; violet
         --- ---
          |
          |
           --&gt; rose
</pre>

<p>
你可以将点对表示法和列表表示法结合来方便地表示一连串的 cons cell, 这个 cons cell
的最后一个 CDR 要是非 <code>nil</code> 的值. 你在列表的最后一个元素后写上点号,后面接最后一
个 cons cell 的 CDR. 例如 <code>(rose violet . buttercup)</code> 等价于
<code>(rose . (violet . buttercup))</code> . 这个对象的图示:
</p>
<pre class="example" id="org312daa2">
         --- ---      --- ---
        |   |   |--&gt; |   |   |--&gt; buttercup
         --- ---      --- ---
          |            |
          |            |
           --&gt; rose     --&gt; violet
</pre>

<p>
<code>(rose . violet . buttercup)</code> 这样的语法是无效的,因为它不能表示任何对象. 如果真
要说能表示什么对象,那这个语法就是把 <code>buttercup</code> 放到一个 cons cell 的 CDR 中, 但
这个 cons cell 的 CDR 已经用来存放 <code>violet</code> 了.
</p>

<blockquote>
<p>
这里我的理解是,纯点对表示法,点号左边是 CAR, 点号右边是 CDR,如果最后一个 cons
cell 的 CDR 没有存放数据,那就是 nil 有 nil 就一定会在纯点对表示法中显式写出来,就
算是点对表示法和列表表示法结合,也会要求最后一个 CDR 是非 <code>nil</code>, 如果上面这个错误
的点对表示法示例按照正确逻辑去理解,那么 <code>rose . violet</code> 是 CAR 存放 rose , CDR
存放 violet, buttercup 是没有多余的CDR 来存放的.
</p>
</blockquote>

<p>
列表 <code>(rose violet)</code> 等价于 <code>(rose . (violet))</code> ,图示如下:
</p>
<pre class="example" id="org88454f6">
         --- ---      --- ---
        |   |   |--&gt; |   |   |--&gt; nil
         --- ---      --- ---
          |            |
          |            |
           --&gt; rose     --&gt; violet
</pre>

<blockquote>
<p>
这个示例中,前面一个列表表示法好理解,列表表示法前面说过,每个元素都是一个
cons cell , CAR 存放元素值, CDR 指向下一个元素,最后一个元素的 CDR 指向 nil, 而第
二个表示法 <code>(rose . (violet))</code> 在 violet 外加了括号,就表示这是一个列表表示法,前
面说过结合使用时,点对表示法的最后一个 CDR 不能是 <code>nil</code>, 这里也符合条件,因为点对
表示法的最后一个 CDR 是列表 <code>(violet)</code>, 而列表表示法的最后一个元素(cons cell)的
CDR 可以是 <code>nil</code>.
</p>
</blockquote>

<p>
类似的,三元素列表 <code>(rose violet buttercup)</code> 等价于
<code>(rose . (violet . (buttercup . nil)))</code>, 也等价于
<code>(rose . (violet . (buttercup)))</code> ,图示:
</p>
<pre class="example" id="org93bd71a">
         --- ---      --- ---      --- ---
        |   |   |--&gt; |   |   |--&gt; |   |   |--&gt; nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
           --&gt; rose     --&gt; violet   --&gt; buttercup
</pre>

<p>
作为 <code>(a b . c)</code> 和 <code>(a . (b . c))</code> 等价的一个有点特殊的副作用,为了一致性,这就意
味着如果你将 <code>b</code> 换成了一个空序列,那么 <code>(a . c)</code> 和 <code>(a . ( . c))</code> 也是等价的.这
也就意味着 <code>( . c)</code> 和 <code>c</code> 是等价的,但是很少会这样使用.
</p>
</div>
</li>


<li><a id="orge4283bc"></a><span class="done DONE">DONE</span> 关联列表类型(Association List Type)<br />
<div class="outline-text-6" id="text-orge4283bc">
<ul class="org-ul">
<li>State "DONE"       from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-20 Mon 17:31]</span></span></li>
</ul>
<p>
一个特殊构造的列表.
</p>

<p>
一个 "关联列表"("association list" 或 "alist") 是一种特殊构造的列表,它的元素是
cons cells. 在每个元素中, CAR 作为 "键"(key), CDR 作为"关联值"(associated
value).(在某些情况下,关联值存放在 CDR 的 CAR 中.) 关联列表通常用来作为堆栈
(stacks), 因为在关联表的前面删除和添加关联很容易.
</p>

<p>
例如:
</p>
<pre class="example" id="org254bbbe">
(setq alist-of-colors
      '((rose . red) (lily . white) (buttercup . yellow)))
</pre>
<p>
这个例子中,将变量 <code>alist-of-colors</code> 设置为一个有三个元素的关联表. 在第一个元素
中, <code>rose</code> 是键, <code>red</code> 是值.
</p>

<p>
关于关联表和用于关联表的函数的进一步说明请参阅 <a href="#orgaf2e615">关联表(Association Lists)</a>. 关于另
一种查询表,请参见 <a href="#orgf516f8b">哈希表(Hash Tables)</a> ,这是一种处理大量键要快得多的查询表.
</p>
</div>
</li>
</ul>
</li>

<li><a id="org1a07ef3"></a><span class="done DONE">DONE</span> 数组类型(Array Type)<br />
<div class="outline-text-5" id="text-org1a07ef3">
<ul class="org-ul">
<li>State "DONE"       from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-21 Tue 10:23]</span></span></li>
</ul>
<p>
包含字符串和 vector (向量)的数组.
<a href="https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Array-Type">elisp#Array Type</a>
</p>

<p>
一个数组是由任意数量的 "插槽" 组成的,这些插槽是用来存放或指向任意其他 Lisp 对象
的,并且它们会被安排到连续的内存块中.访问数组中的任意元素消耗的时间大致是相同的.相
比之下,访问列表中的元素需要的时间与元素在列表中的位置成比例.(访问列表最后的元素
所需要的时间要比访问列表最前面的元素所需要的时间长.)
</p>

<p>
Emacs 定义了四种类型的数组: 字符串(strings), 向量(vectors), 布尔向量
(bool-vectors), 和字符表(char-tables)
</p>

<p>
一个字符串就是字符的数组,一个向量就是任意对象的数组. 一个布尔向量只能储存 <code>t</code> 或
<code>nil</code>. 这类数组可以有任意长度,上到最大的小整数类型数,下到系统架构的限制和可用内
存的限制. 字符表是由任意有效字符编码索引的稀疏矩阵,可以储存任意对象.
</p>

<p>
数组的第一个元素索引为0,第二个元素索引为1,依次类推. 这种索引方式称为 "零原点
(zero-origin)" 索引. 例如,一个有四个元素的数组的索引是 0,1,2,3. 可能的最大索引值
是数组的长度减去一. 一旦数组被创建了,它的长度就不能修改了.
</p>
<blockquote>
<p>
数组创建了长度就不能再该了,就和 C 语言的数组一样,甚至可能 Lisp 的数组底层也是用
C 语言实现的?
</p>
</blockquote>

<p>
所有的 Emacs Lisp 数组都是一维的.(大部分其他编程语言支持多维数组,但是这不重要;因
为你可以使用一维数组嵌套来得到相同效果.) 每种类型的数组都有其自己的读取语法;详细
信息参见下面的小节.
</p>

<p>
数组类型是序列类型的子集,包括了字符串类型,向量类型,布尔向量类型和字符表类型.
</p>
</div>
</li>

<li><a id="org3fe47cb"></a><span class="done DONE">DONE</span> 字符串类型(String Type)<br />
<div class="outline-text-5" id="text-org3fe47cb">
<ul class="org-ul">
<li>State "DONE"       from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-21 Tue 20:53]</span></span></li>
</ul>
<p>
一个(高效的)字符数组.
</p>

<p>
一个字符串就是一个字符的数组. 字符串在 Emacs 中有多种用途,正如一个文本编辑器所期
望的一样; 例如,作为 Lisp 符号的名字, 作为提醒用户的信息,以及用来打印从缓冲区中提
取的文本. Lisp 中的字符串是常量:对字符串的求值返回的是相同的字符串.
(require 'sound-wav)
操作字符串的相关函数请参见 <a href="#orgb4aecb8">字符串和字符(Strings and Characters)</a>.
</p>
</div>

<ul class="org-ul">
<li><a id="org9301358"></a><span class="done DONE">DONE</span> 字符串的语法(Syntax for Strings)<br />
<div class="outline-text-6" id="text-org9301358">
<p>
如何指定 Lisp 字符串.
</p>

<p>
字符串的读取语法是一个双引号,任意数量的字符再加一个双引号( <code>"like this"</code> ). 想要在
字符串中包含一个双引号,要在它前面加上反斜杠; 因此 <code>"\""</code> 表示的是一个字符串,其内
容只包含了一个双引号字符. 而且,你可以在反斜杠前面加上一个反斜杠来在字符串里使用
它,就像这样: <code>"this \\ is a single embeded backslash"</code>.
</p>

<p>
字符串的读取语法中,换行符不是特殊的;如果你在两个双引号之间写入了一个换行符,它就
会称为字符串中的一个字符. 但是一个转义后的换行符(前面加上了反斜杠 <code>\</code> )不会成为
字符串的一部分;也就是说, Lisp 读取器在读取字符串时会忽略转义后的换行符.转义后的
空格: <code>"\ "</code> ,同样也会被忽略.
</p>

<p>
下面是一个示例:
</p>
<pre class="example" id="org518ea9a">


     "It is useful to include newlines
     in documentation strings,
     but the newline is \
     ignored if escaped."
          ⇒ "It is useful to include newlines
     in documentation strings,
     but the newline is ignored if escaped."

</pre>
<p>
上面例子中反斜杠后面跟一个换行符,被 Lisp 读取器读取的结果里就忽视了这个被转义的
换行符.这在文档字符串中很好用.
</p>
</div>
</li>

<li><a id="org9c761e4"></a><span class="done DONE">DONE</span> 字符串中的非 ASCII 字符(Non-ASCII in Strings)<br />
<div class="outline-text-6" id="text-org9c761e4">
<ul class="org-ul">
<li>State "DONE"       from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-21 Tue 20:08]</span></span></li>
</ul>
<p>
字符串中的国际字符.
</p>

<p>
Emacs 中的非 ASCII 字符有两种文本表示: 多字节和单字节(参见
<a href="#org263a727">文本表示(Text Representations)</a>). 粗略地讲,单字节字符串储存原始字节,而多字节字符
串储存人类可读的文本. 单字节字符串中的每个字符都是一个字节,也就是说,其值为 0
到 255. 相比之下,多字节字符串中的每个字符可以是 0 到 4194303 之间的值(
参见<a href="#orga65fe6b">字符类型(Character Type)</a>). 在这两种情况下,值在 127 以上的字符都是非 ASCII 字
符.
</p>

<p>
你可以在字符串常量中使用字符的字面值写入非 ASCII 字符. 如果字符串常量是从一个多
字节源(例如,字符串,多字节缓冲区,或是一个会作为多字节形式访问的文件)中读取的,那么
Emacs 将每个非 ASCII 字符读取为一个多字节字符,并且会自动将字符串设置为多字节字符
串. 如果字符串常量是从一个单字节源中读取的,那么 Emacs 会将非 ASCII 字符读取为单
字节,并且将字符串设置为单字节字符串.
</p>

<p>
你可以使用转义序列来将一个字符写入到多字节字符串中,而不是直接将字符写入多字节字
符串. 关于转义序列的细节请参阅 <a href="#org3fed69d">通用转义语法(General Escape Syntax)</a>.
</p>

<p>
如果你在一个字符串常量中使用了任意 Unicode 风格的转义序列(<code>\uNNNN</code> 或
<code>\U00NNNNNN</code>), Emacs 会自动假定这个字符串常量是多字节的.
</p>

<p>
你可以在字符串常量中使用十六进制转义序列(<code>\xN</code>)和八进制转义序列(<code>\N</code>). <b>但是,请
注意:</b> 如果一个字符串常量中有十六进制或八进制转义序列,这些转义序列全都是指定单字
节字符(也就是值小于255 的字符),而且字符串中没有其他的非 ASCII 字符字面量或
Unicode 格式的转义序列,那么 Emacs 会自动假设这个字符串常量是一个单字节字符串.也
就是说,它会假定出现在字符串中的所有非 ASCII 字符是 8位的原始字节.
</p>
<blockquote>
<p>
单字节字符串中每个字符用8位(一个字节)储存,多字节字符串中每个字符用 20位储存.
Unicode 编码格式需要的位数多于 8 位, 字符编码大于255 的非 ASCII 字符也需要多于 8
位数据来储存,因此只要字符串中出现这两种字符,就会被认为是多字节字符串.
</p>
</blockquote>

<p>
在十六进制和八进制转义序列中, 被转义的字符编码可能包含可变数量的数字,所以后续第
一个非十六进制或非八进制的字符表明转义序列的终止. 如果字符串中的下一个字符可能会
被理解成十六进制或八进制的数字,请写入一个 "\ "(反斜杠加空格) 来终结这个转义序列.
例如, "\xe0\ " 表示一个字符 <code>à</code>,字符串常量中的 "\ "就像是反斜杠加上换行,它不会为
字符串贡献任何字符,但会终止前面的任何十六/八进制转义.
</p>
</div>
</li>

<li><a id="org994c76b"></a><span class="done DONE">DONE</span> 非打印字符(Nonprinting Characters)<br />
<div class="outline-text-6" id="text-org994c76b">
<ul class="org-ul">
<li>State "DONE"       from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-21 Tue 20:32]</span></span></li>
</ul>
<p>
字符串中不可打印的文字字符.
</p>

<p>
你可以在字符串常量中使用相同的反斜杠转义序列作为字符字面量(但是不能用问号作为一
个字符常量的开始). 例如,你可以编写一个包含非打印字符制表符(tab)和 <code>C-a</code> 的字符串,在
他们中间加上逗号和空格,就像这样: <code>"\t, \C-a"</code>. 关于字符的读取语法的描述
参见<a href="#orga65fe6b">字符类型(Character Type)</a>.
</p>

<p>
然而,并不是所有你可以使用反斜杠转义序列编写的字符在字符串中都是有效的.字符串中能
包含的控制字符只有 ASCII 控制字符.字符串不区分 ASCII 控制字符的大小写.
</p>

<p>
严格来讲,字符串中不能有 meta 字符;但是当一个字符串用作案件序列时,有一种特殊的惯
例,提供了一种在字符串中表示 meta 版本的 ASCII 字符的方式. 如果你使用 <code>\M-</code> 语法
来在字符串常量中表示一个 meta 字符,这将会设置字符串中字符的 2**7 位. 如果字符串
用在 <code>define-key</code> 或 <code>lookup-key</code> 函数中, 这个设置的数字代码会被翻译乘等价的
meta 字符. 参见<a href="#orga65fe6b">字符类型(Character Type)</a>.
</p>

<blockquote>
<p>
Emacs 的字符串中的字符占 20 位, meta 字符占 27 位,因此才说严格来讲字符串中是不能
有 meta 字符的,只是我们为字符串中的 "\M-" 进行了额外的操作,所以才看起来像是字符
串中有了 meta 字符.
</p>
</blockquote>

<p>
字符串中的字符是不能有 hyper, super, 或 alt 修饰符的.
</p>
</div>
</li>

<li><a id="org6842192"></a><span class="done DONE">DONE</span> 文本属性和字符串(Text Props and Strings)<br />
<div class="outline-text-6" id="text-org6842192">
<ul class="org-ul">
<li>State "DONE"       from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-21 Tue 20:46]</span></span></li>
</ul>
<p>
带文本属性的字符串.
</p>

<p>
一个字符串除了可以包含字符本身之外,还可以包含所含字符的属性. 这使得在字符串和缓
冲区之间复制文本的程序不需要特别的操作即可复制文本的属性. 关于文本属性含义的解释,
参见 <a href="#org05aca52">文本属性(Text Properties)</a>.
</p>

<p>
带文本属性的字符串使用一种特殊的读取和打印语法:
</p>
<pre class="example" id="org993ec92">
     #("CHARACTERS" PROPERTY-DATA...)
</pre>
<p>
PROPERTY-DATA 由0个或更多元素组成,以三个元素为一组,如下所示:
</p>
<pre class="example" id="org967bf7d">
     BEG END PLIST
</pre>

<p>
BEG 和 END 元素是整数,它们一起指定字符串的某个索引范围; PLIST 是这个范围中的属性
列表,例如:
</p>
<pre class="example" id="org3367ce2">
     #("foo bar" 0 3 (face bold) 3 4 nil 4 7 (face italic))
</pre>
<p>
这个例子表示一个文本内容为 <code>foo bar</code> 的字符串,前三个字符有一个值为 <code>bold</code> 的
<code>face</code> 属性,最后三个字符有一个值为 <code>italic</code> 的 <code>face</code> 属性.(第四个字符没有文本属
性,所以它的属性列表为 <code>nil</code>. 实际上,没有必要在属性列表中写出属性为 <code>nil</code> 的范围,
因为任意范围中未写出的任意字符都会默认为没有属性.)
</p>
</div>
</li>
</ul>
</li>

<li><a id="orgfcfe156"></a><span class="done DONE">DONE</span> 向量类型(Vector Type)<br />
<div class="outline-text-5" id="text-orgfcfe156">
<ul class="org-ul">
<li>State "DONE"       from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-21 Tue 21:05]</span></span></li>
</ul>
<p>
一维数组.
</p>

<p>
一个向量,就是一个任意类型元素的一维数组. 访问向量中的任意元素需要一个恒定的时间
量.(在列表中,元素的访问时间跟元素与列表中最开始的元素之间的距离成比例.)
</p>

<p>
一个向量的打印表示由一个左方括号,元素,和一个右方括号组成. 这也是向量的读取语法.
</p>

<p>
与数字,字符串一样,向量也是作为一个常量来求值的.
</p>

<pre class="example" id="orge724833">
     [1 "two" (three)]      ; A vector of three elements.
          ⇒ [1 "two" (three)]
</pre>

<p>
和向量一起使用的函数参见 <a href="#org8139b11">向量(Vectors)</a>
</p>
</div>
</li>


<li><a id="orgaee97ae"></a><span class="done DONE">DONE</span> 字符表类型(Char-Table Type)<br />
<div class="outline-text-5" id="text-orgaee97ae">
<ul class="org-ul">
<li>State "DONE"       from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-21 Tue 23:11]</span></span></li>
</ul>
<p>
按字符索引的一维稀疏矩阵.
</p>

<p>
一个字符表就是一个由字符编码索引的任意类型元素的一维数组. 字符表有某些额外的特性,使
其在许多设计为字符编码分配信息的工作中更有用,例如,一个字符表可以有一个要继承的父
级,一个默认值,和少量用于特殊用途的额外插槽.一个字符表也可以为整个字符集指定一个
值.
</p>

<p>
字符表的打印表示和向量的类似,除了前面有一个额外的 <code>#^</code> <sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>.
</p>

<p>
关于操作字符表的特殊函数,请参阅 <a href="#org74ce9c3">字符表(Char-Tables)</a>.
</p>

<p>
字符表的使用包括:
</p>
<ul class="org-ul">
<li>Case tables (大小写表?)(参见 <a href="#org50fbb35">Case Tables</a>).</li>
<li>字符类别表(参见 <a href="#orgd9a3c9f">类别(Categories)</a>).</li>
<li>显示表(参见 <a href="#orgaf27afa">显示表(Display Tables)</a>).</li>
<li>语法表(参见 <a href="#org78c3e54">语法表(Syntax Tables)</a>).</li>
</ul>
</div>
</li>

<li><a id="orgdbf8d98"></a><span class="done DONE">DONE</span> 布尔向量类型(Bool-Vector Type)<br />
<div class="outline-text-5" id="text-orgdbf8d98">
<ul class="org-ul">
<li>State "DONE"       from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-21 Tue 23:58]</span></span></li>
</ul>
<p>
<code>t</code> 或 <code>nil</code> 的一维数组.
</p>

<p>
布尔向量是一个元素必须是 <code>t</code> 或 <code>nil</code> 的一维数组.
</p>

<p>
布尔向量的打印表示与字符串类似,除了它以 <code>#&amp;</code> 加上长度开头. 后面的字符串常量实际
上是将布尔向量的内容指定为一个位图,字符串中的每个字符都有 8 位,每个字符指定布尔
向量的后8个元素(1表示 <code>t</code>, 0 表示 <code>nil</code>). 字符的最低有效位对应布尔向量的最低索引.
</p>

<pre class="example" id="org8d34498">
     (make-bool-vector 3 t)
          ⇒ #&amp;3"^G"
     (make-bool-vector 3 nil)
          ⇒ #&amp;3"^@"
</pre>
<p>
上面的结果是讲得通的,因为 <code>C-g</code> 的二进制编码是 111 <code>C-@</code> 的字符编码是 0.
</p>

<p>
如果长度不是8的倍数,则其打印表示会显示额外的元素,但是这些额外的元素实际上没什么
影响. 例如, 在下面的例子中,两个布尔向量是相等的,因为只用到了前三位:
</p>
<pre class="example" id="org5127817">
(equal #&amp;3"\377" #&amp;3"\007")
     ⇒ t
</pre>
<blockquote>
<p>
337 和 007 是字符编码的八进制表示法.转换成二进制是 011 011 111 和 000
000 111. 字符的最低位是布尔向量的最低索引,因此是从最右边开始算的三位,最右边的三
位都是111,所以相等,如果是最右边的4位,就不相等了.
(equal #&amp;4"\377" #&amp;4"\007")
     ⇒ nil
</p>
</blockquote>
</div>
</li>

<li><a id="org2a8e6a9"></a><span class="done DONE">DONE</span> 哈希表类型(Hash Table Type)<br />
<div class="outline-text-5" id="text-org2a8e6a9">
<ul class="org-ul">
<li>State "DONE"       from "TODO"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-22 Wed 00:15]</span></span></li>
</ul>
<p>
超级快的查找表.
</p>

<p>
一个哈希表是一种速度非常快的查询表,有点向关联表,因为它也将键映射到相应的值,但速
度要快得多. 哈希表的打印表示规定了它的属性和内容,就像这样:
</p>
<pre class="example" id="org9293fec">
(make-hash-table)
     ⇒ #s(hash-table size 65 test eql rehash-size 1.5
                             rehash-threshold 0.8125 data ())
</pre>
<p>
关于哈希表的更多信息,参见 <a href="#orgf516f8b">哈希表(Hash Tables)</a>.
</p>
</div>
</li>

<li><a id="orgfdeb66b"></a><span class="done DONE">DONE</span> 函数类型(Function Type)<br />
<div class="outline-text-5" id="text-orgfdeb66b">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-22 Wed 07:28]</span></span></li>
</ul>
<p>
你可以在其他地方调用的一段可执行的代码.
</p>

<p>
Lisp 函数就和其他语言里的函数一样,是可以执行的代码.和多数语言不同的是, 在 Lisp
中,函数也是 Lisp 对象. Lisp 中一个未编译的函数是一个 lambda 表达式: 也就是一个列
表,其第一个元素是符号 <code>lambda</code> (参见<a href="#org8ae8a6d">Lambda 表达式(Lambda Expressions)</a>).
</p>

<p>
在大多数编程语言中,函数没有函数名是不可能的. 在 Lisp 中,一个函数并不是必须要有函
数名.一个 lambda 表达式可以作为一个函数被调用,即使它没有函数名;为了强调这一点,我
们把它叫做"匿名函数"(参见 <a href="#orgbf27a2a">匿名函数(Anonymous Functions)</a>). Lisp 中一个有名字的函
数仅仅是一个符号(函数名)再加上函数单元里的有效函数而已(参见
<a href="#orga05ec51">定义函数(Defining Functions)</a>).
</p>

<p>
大多数情况下,当函数名被编写到 Lisp 程序的 Lisp 表达式中时,函数就会被调用.然而,你
可以在运行时构造或获取一个函数对象,然后通过原始函数 <code>funcall</code> 和 <code>apply</code> 来调用
它. 参见 <a href="#orga05ec51">定义函数(Defining Functions)</a>.
</p>
</div>
</li>


<li><a id="orgf774527"></a><span class="done DONE">DONE</span> 宏类型(Macro Type)<br />
<div class="outline-text-5" id="text-orgf774527">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-22 Wed 07:42]</span></span></li>
</ul>
<p>
将一个表达式扩展成另一个表达式的方法,更基本,但不太美观.
</p>

<p>
一个 Lisp 宏,就是一个用户定义的构造,它扩展了 Lisp 语言.它表示为一个很像函数的对
象,但是有着不同的参数来传递语义. 一个 Lisp 宏的形式是一个列表,其第一个元素是符号
<code>macro</code> ,它的 CDR 是一个 Lisp 函数对象,也可以有 <code>lambda</code> 符号.
</p>

<p>
Lisp 宏对象通常使用内置的 <code>defmacro</code> 宏来定义,但是就 Emacs 而言,任何以 <code>macro</code>
开头的列表都是宏. 关于如何编写一个宏的阐述参见 <a href="#org15d607f">宏(Macros)</a>.
</p>

<p>
<b>警告</b> : Lisp 宏和键盘宏(参见<a href="#org9ae97a7">键盘宏(Keyboard Macros)</a>)是完全不同的东西.当我们在没
有限定的情况下使用 <code>macro</code> 时,我们指的是 Lisp 宏,而不是键盘宏.
</p>
</div>
</li>

<li><a id="org9524920"></a><span class="done DONE">DONE</span> 原始函数类型(Primitive Function Type)<br />
<div class="outline-text-5" id="text-org9524920">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-22 Wed 08:05]</span></span></li>
</ul>
<p>
用 C 编写的函数,可以由 Lisp 调用.
</p>

<p>
一个"原始函数"就是可以从 Lisp 调用,但是是用 C 语言编写的函数. 原始函数也叫做
"subr"(子程序,来源于 subroutine) 或 "built-in" (内置函数). 大多数原始函数在调用
时会求值它们的所有参数.一个不对其所有参数求值的原始函数叫做 "special form"( 特殊
形式或特殊表达式)(参见 <a href="#org1ce4062">特殊表达式(Special Forms)</a>).
</p>

<p>
对于函数的调用者来说,函数是否为原始函数无关紧要. 然而,如果你试图用一个 Lisp 编写
的函数来对原始函数进行重定义,那这就很重要.原因是原始函数可能会直接从 C 代码里调
用. 从 Lisp 中调用重定义的函数会使用新的定义,但是从 C 代码中调用仍然会使用内置的
定义.因此 <b>我们不推荐原始函数的重定义</b>.
</p>

<p>
"函数" 一词,指的是所有的 Emacs 函数,不管它是用 C 还是 Lisp 编写的. 关于 Lisp 编
写的函数的相关信息,请参见 <a href="#orgfdeb66b">函数类型(Function Type)</a>.
</p>

<p>
原始函数没有读取语法,并且会以哈希表示法打印其自子程序名.
</p>

<pre class="example" id="orge13ddce">
     (symbol-function 'car)          ; Access the function cell
                                     ;   of the symbol.
          ⇒ #&lt;subr car&gt;
     (subrp (symbol-function 'car))  ; Is this a primitive function?
          ⇒ t                       ; Yes.
</pre>
<blockquote>
<p>
subr , built-in, primitive (子程序/例程, 内置函数,原始函数) 都指的是同一个东西.
</p>
</blockquote>
</div>
</li>

<li><a id="org1c22079"></a><span class="done DONE">DONE</span> 字节码类型(Byte-Code Type)<br />
<div class="outline-text-5" id="text-org1c22079">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-22 Wed 08:14]</span></span></li>
</ul>
<p>
由 Lisp 编写后再编译的程序.
</p>

<p>
"字节码函数对象" 是 Lisp 代码经过字节编译后产生的(参见
<a href="#org83b295a">字节编译(Byte Compilation)</a>). 在内部,字节码的函数对象很像向量,但是,当这个数据类型
出现在函数调用中时,求值器会对其特殊处理. 参见 <a href="#org58e91b7">字节码对象(Byte-Code Objects)</a>.
</p>

<p>
字节码函数对象的打印表示和读取语法和向量类似,只是在 <code>[</code> 前有一个额外的 <code>#</code>
</p>

<blockquote>
<p>
向量的打印表示是 <code>[1 "2" (3)]</code> 字节码对象的打印表示就是 <code>#[1 "2" (3)]</code>. 语法形式
应该是这样内部的数据类型就不确定了,只说了像向量,没说其他.
</p>
</blockquote>
</div>
</li>

<li><a id="org1df8e41"></a><span class="done DONE">DONE</span> 记录类型(Record Type)<br />
<div class="outline-text-5" id="text-org1df8e41">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-22 Wed 09:44]</span></span></li>
</ul>
<p>
含有程序员定义的类型的复合对象.
</p>

<p>
"记录" 很像向量,但是第一个元素是用来储存它的类型(就是 <code>type-of</code> 返回的内容)的.
记录的用途是允许程序员创建 Emacs 没有内置的新类型的对象.
</p>

<p>
用于"记录"的函数,参见 <a href="#org0dc4d87">记录(Records)</a>.
</p>
</div>
</li>

<li><a id="org815c857"></a><span class="done DONE">DONE</span> 类型描述符(Type Descriptors)<br />
<div class="outline-text-5" id="text-org815c857">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-22 Wed 11:08]</span></span></li>
</ul>
<p>
保存关于类型信息的对象.
</p>

<p>
类型描述符是一个保存类型信息的 <code>record</code> (记录). 这个记录的插槽1必须是一个符号,用
来给类型命名, <code>type-of</code> 函数就是靠这个来返回 <code>record</code> 对象的类型. Emacs 没有使用
其余的类型描述符插槽, Lisp 扩展可以随意使用它们.
</p>

<p>
一个类型描述符的例子是 <code>cl-structure-class</code> 的任意实例.(使用 <code>describe-symbol</code> 命
令可以查看这个符号的相关内容)
</p>
</div>
</li>

<li><a id="org7e3d24d"></a><span class="done DONE">DONE</span> 自加载类型(Autoload Type)<br />
<div class="outline-text-5" id="text-org7e3d24d">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-22 Wed 11:34]</span></span></li>
</ul>
<p>
一个用来自动加载很少使用的函数的数据类型.
</p>

<p>
一个"自动加载对象" 是一个列表,其第一个元素是符号 <code>autoload</code>. 自动加载对象储存为
符号的函数定义,这里是作为真正定义的占位符. 自动加载对象表示,真正的定义位于一个
Lisp 代码文件中,必要时应该加载该文件. 自动加载对象中含有文件名加上一些关于真正定
义的其他信息.
</p>

<p>
在文件被加载后,该符号应该会有一个新的函数定义,该定义就不再是自动加载对象了.然后,
新的定义会被调用,就好像它一开始就在那里一样.从用户的角度看,使用被加载的文件中的
函数定义,函数的调用如期运行.
</p>

<p>
自动加载对象通常用函数 <code>autoload</code> 创建, 该函数将对象储存在一个符号的函数单元中.更
多细节参考 <a href="#org910e488">自动加载(Autoload)</a>.
</p>
</div>
</li>

<li><a id="orge541d9d"></a><span class="done DONE">DONE</span> 终结器类型(Finalizer Type)<br />
<div class="outline-text-5" id="text-orge541d9d">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-22 Wed 11:49]</span></span></li>
</ul>
<p>
在代码不再访问时运行的代码.
</p>

<p>
"终结器对象"帮助 Lisp 代码清理不再需要的对象.一个终结器持有一个 Lisp 函数对象.
当一个终结器对象在一次垃圾收集发生后变得不可访问时, Emacs 会调用该终结器的相关的
函数对象. 当决定一个终结器是否可访问时, Eamcs 不会计算终结器本身的引用,因此你可
以使用终结器,而不用担心意外输入了对已终结的对象本身的引用.
</p>

<p>
终结器中的错误会被打印到 <code>*Message*</code> 缓冲区.即使函数运行失败了, Eamcs 也会运行一
次给定终结器对象相关联的函数.
</p>

<dl class="org-dl">
<dt>函数: <code>make-finalizer FUNCTION</code></dt><dd>生成一个会运行 FUNCTION 函数的终结器.
当返回(生成)的终结器对象在垃圾收集后变得不可访问后, FUNCTION 就会被调用.出于决
定是否运行 FUNCTION 的目的, 如果终结器对象只能通过来自终结器对象自身的引用访问,这
不会算作是可以访问.每个终结器对象的 FUNCTION  都会被运行一次.</dd>
</dl>
</div>
</li>
</ul>
</div>

<div id="outline-container-org0ce4b6f" class="outline-4">
<h4 id="org0ce4b6f"><span class="done DONE">DONE</span> 编辑类型(Editing Types)</h4>
<div class="outline-text-4" id="text-org0ce4b6f">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-22 Wed 17:36]</span></span></li>
</ul>
<p>
Emacs 特有的类型.
</p>

<p>
前面一节中的类型是用作通用编程用途的,其中的大多数类型在大多数 Lisp 方言中是通用
的. Emacs 为与编辑相关的用途提供了几种额外的数据类型.
</p>
</div>

<ul class="org-ul">
<li><a id="orgf033db3"></a><span class="done DONE">DONE</span> 缓冲区类型(Buffer Type)<br />
<div class="outline-text-5" id="text-orgf033db3">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-22 Wed 13:51]</span></span></li>
</ul>
<p>
基本的编辑对象.
</p>

<p>
"缓冲区" 是一个有着可编辑文本的对象(参见 <a href="#org12fbc0b">缓冲区(Buffers)</a>). 大多数的缓冲区保存的
是磁盘文件(参见 <a href="#org75e49d9">文件(Files)</a>)的内容,因此可以对其进行编辑, 但有些缓冲区有着其他用
途. 大多数缓冲区是给用户看的,因此,在某些时候会显示在窗口(参见<a href="#org24b263f">窗口(Windows)</a>)中.
但是一个缓冲区不是必需要显示在任意窗口中的. 每个缓冲区都有一个指定的位置叫做
"point"(光点,光标)(参见 <a href="#orgbef9fd7">位置(Positions)</a> );大多数编辑命令是作用于当前缓冲区中光标
/点附近的内容的. 在任何时候,一个缓冲区指的就是"current buffer"(当前缓冲区).
</p>

<p>
缓冲区的内容很像字符串,但是在 Emacs Lisp 中, 缓冲区不像字符串那样使用,并且可用的
操作也不相同. 例如, 你可以高效地将文本插入到一个已有的缓冲区,修改缓冲区内容,然而,向
字符串中插入文本需要连接子字符串,并且结果是一个全新的字符串对象.
</p>

<p>
有许多标准 Emacs 函数操作或测试当前缓冲区的字符;手册中有一整章的内容来专门介绍这
些函数(参见 <a href="#org3ec44e9">文本(Text)</a>).
</p>

<p>
还有几个其他的数据结构与每个缓冲区相关:
</p>
<ul class="org-ul">
<li>局部语法表(参见 <a href="#org78c3e54">语法表(Syntax Tables)</a>).</li>
<li>局部按键映射(参见 <a href="#orgad5bc8b">按键映射(Keymaps)</a>).</li>
<li>overlay (覆盖层) (参见 <a href="#org562b087">覆盖层(Overlays)</a>).</li>
<li>缓冲区中文本的文本属性(参见 <a href="#org05aca52">文本属性(Text Properties)</a>)</li>
</ul>


<p>
局部按键映射和变量列表包含了分别重写全局按键绑定或值的条目.这可用于自定义不同缓
冲区中程序的行为,而不用真的更改程序.
</p>

<p>
缓冲区可能是"间接的",这意味着它共享另一个缓冲区的文本,但是显示的内容不同.
参见 <a href="#org6bf99ea">间接缓冲区(Indirect Buffers)</a>.
</p>

<p>
缓冲区没有读取语法.它们以哈希表示法打印,用来显示缓冲区名称.
</p>
<pre class="example" id="org22124e2">
     (current-buffer)
          ⇒ #&lt;buffer objects.texi&gt;
</pre>
</div>
</li>

<li><a id="org102f28e"></a><span class="done DONE">DONE</span> 标记类型(Marker Type)<br />
<div class="outline-text-5" id="text-org102f28e">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-22 Wed 13:59]</span></span></li>
</ul>
<p>
缓冲区中的位置.
</p>

<p>
一个"Marker"(标记)表示特定缓冲区中的位置. 因此, 标记有两个组成部分,一个用于缓冲
区,一个用于位置.缓冲区中文本的改变会根据需要自动重新定位位置的值,以确保标记始终
指向缓冲区中相同的两个字符之间.
</p>

<p>
标记没有读取语法. 它也是以哈希表示法打印,给出当前的字符位置和缓冲区名称:
</p>
<pre class="example" id="org7ed87c0">
     (point-marker)
          ⇒ #&lt;marker at 10779 in objects.texi&gt;
</pre>

<p>
关于如何测试,创建,复制和移动标记的相关信息,请参见 <a href="#orga7bfbe8">标记(Markers)</a>.
</p>
</div>
</li>

<li><a id="orgad69063"></a><span class="done DONE">DONE</span> 窗口类型(Window Type)<br />
<div class="outline-text-5" id="text-orgad69063">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-22 Wed 14:25]</span></span></li>
</ul>
<p>
缓冲区显示在窗口中.
</p>

<p>
"window"(窗口)描述的是 Emacs 用来显示缓冲区的屏幕部分. 每一个活动的窗口(参见
<a href="#org3ece239">基本窗口(Basic Windows)</a> )都有一个相关联的缓冲区,其内容显示在该窗口中. 相比之下,
给定的缓冲区可能出现在一个窗口,没有窗口,或多个窗口中.窗口在屏幕上被分组为框架,每
个窗口属于且只属于一个框架. 参见 <a href="#org0f7aa9e">框架类型(Frame Type)</a>.
</p>

<p>
尽管多个窗口可能同时存在,但在同一时间只会有一个窗口被指定为 "selected window" "
选定的窗口"(参见 <a href="#orgbcab970">选择窗口(Selecting Windows)</a>). 这个窗口就是当 Emacs 准备执行命令
时光标(通常)所在的窗口.选定的窗口通常显示当前缓冲区(参见
<a href="#org75e596b">当前缓冲区(Current Buffer)</a>), 但情况也并非都是如此.
</p>

<p>
窗口没有读取语法. 它们以哈希表示法打印,给出窗口编号和显示的缓冲区名称. 窗口编号
的存在是为了唯一标识窗口,因为任意给定窗口中显示的缓冲区都可能频繁的变化.
</p>
<pre class="example" id="org289d1fa">
     (selected-window)
          ⇒ #&lt;window 1 on objects.texi&gt;
</pre>

<p>
用于窗口函数的描述,请参见 <a href="#org24b263f">窗口(Windows)</a>.
</p>
</div>
</li>

<li><a id="org0f7aa9e"></a><span class="done DONE">DONE</span> 框架类型(Frame Type)<br />
<div class="outline-text-5" id="text-org0f7aa9e">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-22 Wed 14:31]</span></span></li>
</ul>
<p>
窗口将框架分割.
</p>

<p>
"框架"就是包含有一个或多个 Emacs 窗口的屏幕区域; 我们也用 "框架"这一术语来指代
Emacs 中用来指代屏幕区域的 Lisp 对象.
</p>

<p>
框架没有读取语法. 它们也以哈希表示法打印,给出框架的标题,加上它在核心中的地址(有
助于唯一标识框架).
</p>

<pre class="example" id="orgb3f6825">
     (selected-frame)
          ⇒ #&lt;frame emacs@psilocin.gnu.org 0xdac80&gt;
</pre>

<blockquote>
<p>
这里提到的核心,可能是 Emacs 程序的核心?更可能的是系统的核心/内核吧.
</p>
</blockquote>

<p>
关于作用于框架的函数的说明,请参见 <a href="#org718863b">框架(Frames)</a>.
</p>
</div>
</li>

<li><a id="org916183d"></a><span class="done DONE">DONE</span> 终端类型(Terminal Type)<br />
<div class="outline-text-5" id="text-org916183d">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-22 Wed 14:34]</span></span></li>
</ul>
<p>
一个显示框架的终端设备.
</p>

<p>
"终端"(terminal) 就是一个能够显示一个或多个 Emacs 框架(参见
<a href="#org0f7aa9e">框架类型(Frame Type)</a>)的设备.
</p>

<p>
终端没有读取语法. 他们以哈希表示法打印,给出终端的序号及其 TTY 设备文件名.
</p>

<pre class="example" id="org3047d2f">
     (get-device-terminal nil)
          ⇒ #&lt;terminal 1 on /dev/tty&gt;
</pre>

<blockquote>
<p>
终端类型应该就是 Emcas 用来指代 Emacs 所运行的机器的类型.比如运行在 window10 上,
     (get-device-terminal nil)
          ⇒ #&lt;terminal 1 on w32&gt;
</p>
</blockquote>
</div>
</li>

<li><a id="orga196489"></a><span class="done DONE">DONE</span> 窗口配置类型(Window Configuration Type)<br />
<div class="outline-text-5" id="text-orga196489">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-22 Wed 14:49]</span></span></li>
</ul>
<p>
记录框架的细分方式.
</p>

<p>
"window configuration" (窗口配置) 保存的是一个框架中窗口的位置,大小和内容相关的
信息,因此,可以随后重新创建相同的窗口排列.
</p>

<p>
窗口配置没有读取语法;他们的打印语法就像 <code>#&lt;window-configuration&gt;</code> 这样. 关于窗口
配置相关的几个函数的描述,请参见 <a href="#org8509ca3">窗口配置(Window Configurations)</a>.
</p>
</div>
</li>

<li><a id="org32be9c2"></a><span class="done DONE">DONE</span> 框架配置类型(Frame Configuration Type)<br />
<div class="outline-text-5" id="text-org32be9c2">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-22 Wed 14:54]</span></span></li>
</ul>
<p>
记录所有框架的状态.
</p>

<p>
"frame configuration" (框架配置) 储存的是所有框架中窗口的位置,大小和内容相关的信
息. 它不是一个原始类型,实际上它是一个列表,其 CAR 是 <code>frame-configuration</code> 其 CDR
是一个关联列表.关联列表中的每个元素都描述一个框架,作为该元素的 CAR 出现.
</p>

<p>
对几个框架配置相关的函数的描述,请参见 <a href="#org784167d">框架配置(Frame Configurations)</a>.
</p>
</div>
</li>

<li><a id="orgec5ff27"></a><span class="done DONE">DONE</span> 进程类型(Process Type)<br />
<div class="outline-text-5" id="text-orgec5ff27">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-22 Wed 15:07]</span></span></li>
</ul>
<p>
运行在底层操作系统上的子进程.
</p>

<p>
"process" (进程)一词通常指的是一个正在运行的程序. Emasc 其自身就运行在这样一个进
程中. 然而,在 Emacs Lisp 中,一个进程,是一个用来指定由 Emacs 进程创建的子进程的
Lisp 对象. 运行在 Emacs 的子进程中的程序,例如 shell, GDB, ftp 和编译器,扩展了
Emacs 的功能. Emacs 子进程接受来自 Emacs 的文本输入,并将文本输出返回给 Emacs 以
供进一步操作. Emacs 也可以给子进程发送信号.
</p>

<p>
进程对象没有读取语法. 他们以哈希表示法打印,给出进程的名称:
</p>

<pre class="example" id="orgdea3ae9">
     (process-list)
          ⇒ (#&lt;process shell&gt;)
</pre>

<p>
关于创建,删除,返回有关信息,向进程发送输入或发送信号以及从进程接受输出的函数的相
关信息, 请参见 <a href="#org301788e">进程(Processes)</a>.
</p>
</div>
</li>

<li><a id="orge2dfc78"></a><span class="done DONE">DONE</span> 线程类型(Thread Type)<br />
<div class="outline-text-5" id="text-orge2dfc78">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-22 Wed 15:42]</span></span></li>
</ul>
<p>
Emacs Lisp 执行的线程.
</p>

<p>
"thread" (线程) 在 Emcas 表示的是一个 Emacs Lisp 执行的单独线程. 它运行它自己的
Lisp 程序,有其自己的当前缓冲区,并且可以拥有锁定的子进程,即,只有该线程能接收这个
子进程的输出. 参见 <a href="#orgb624181">线程(Threads)</a>.
</p>

<p>
线程对象没有读取语法. 他们以哈希表示法打印,给出线程的名称(如果其有名称的话)或其
在内核/核心中的地址:
</p>
<pre class="example" id="org515dfa0">
     (all-threads)
         ⇒ (#&lt;thread 0176fc40&gt;)
</pre>
</div>
</li>

<li><a id="orgb971864"></a><span class="done DONE">DONE</span> 互斥锁类型(Mutex Type)<br />
<div class="outline-text-5" id="text-orgb971864">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-22 Wed 15:49]</span></span></li>
</ul>
<p>
线程同步的独占锁.
</p>

<p>
"mutex" (互斥锁) 是一种独占锁,线程可以拥有和解除它,以便在进程之间同步.
参见 <a href="#org899103b">互斥锁(Mutexes)</a>.
</p>

<p>
互斥锁对象没有读取语法. 他们以哈希表示法打印,给出互斥锁的名称(如果已为其指定了名
称)或其核心/内核地址:
</p>

<pre class="example" id="org34c53bd">
     (make-mutex "my-mutex")
         ⇒ #&lt;mutex my-mutex&gt;
     (make-mutex)
         ⇒ #&lt;mutex 01c7e4e0&gt;
</pre>
<p>
第一个有名字,打印表示会显示名字,第二个没有名字,显示地址.
</p>
</div>
</li>

<li><a id="org41d3dcf"></a><span class="done DONE">DONE</span> 条件变量类型(Condition Variable Type)<br />
<div class="outline-text-5" id="text-org41d3dcf">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-22 Wed 15:53]</span></span></li>
</ul>
<p>
线程同步的条件变量.
</p>

<p>
"condition variable"(条件变量) 是用于比互斥锁支持的同步操作更复杂的同步操作的方
法/设备?.
</p>

<p>
一个线程可以等待某个条件变量,以便在其他进程通知该条件时被唤醒.
</p>

<p>
条件变量对象没有读取语法. 他们以哈希表示法打印,给出条件变量的名称(如果给定了名称
的话)或是其在核心/内核中的地址:
</p>

<pre class="example" id="orgf0355f8">
     (make-condition-variable (make-mutex))
         ⇒ #&lt;condvar 01c45ae8&gt;
</pre>
</div>
</li>

<li><a id="org779b82c"></a><span class="done DONE">DONE</span> 流类型(Stream Type)<br />
<div class="outline-text-5" id="text-org779b82c">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-22 Wed 16:25]</span></span></li>
</ul>
<p>
发送或接收字符.
</p>

<p>
"stream" (流),是一个可以用作字符源或字符池的对象,既可以提供字符用作输入,也可以接
受字符作为输出. 多种不同的类型都可以以这种方式使用: 标记(markers), 缓冲区
(buffers), 字符串(strings) 和函数(functions). 最常见的是,输入流(字符源)从键盘,缓
冲区或文件中获取字符,输出流(字符池)发送字符到缓冲区或是回显区,例如 <code>*Help*</code> 缓冲
区.
</p>

<p>
对象 <code>nil</code>, 除了其他含义之外,还可以用作流. 它代表变量 <code>standard-input</code> 或
<code>standard-output</code> 的值. 此外, 对象 <code>t</code> 用作流,则指定使用minibuffer(迷你缓冲区,参
见 <a href="#orga1c7a88">迷你缓冲区(Minibuffers)</a>)作为输入,或是在回显区输出(
参见 <a href="#org90be08c">回显区(The Echo Area)</a>).
</p>

<p>
流没有特殊的打印表示或读取语法, 并且会打印为任意他们属于的原始类型.
</p>

<p>
与流相关的函数的描述,包括解析和打印函数,请参见 <a href="#orgf8513c7">读取和打印(Read and Print)</a>.
</p>
</div>
</li>

<li><a id="org708dbf9"></a><span class="done DONE">DONE</span> 按键映射类型(Keymap Type)<br />
<div class="outline-text-5" id="text-org708dbf9">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-22 Wed 16:31]</span></span></li>
</ul>
<p>
敲击按键会调用什么函数.
</p>

<p>
"keymap" (按键映射) 将用户按下的按键映射到命令. 这个映射控制拥护的命令输入是如何
被执行的. 一个按键映射实际上就是一个列表,其 CAR 是符号 <code>keymap</code>.
</p>

<p>
有关创建按键映射,处理前置按键,局部以及全局按键映射,还有改变按键绑定的信息,
请参见 <a href="#orgad5bc8b">按键映射(Keymaps)</a>.
</p>
</div>
</li>

<li><a id="orgc45251f"></a><span class="done DONE">DONE</span> 覆盖层类型(Overlay Type)<br />
<div class="outline-text-5" id="text-orgc45251f">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-22 Wed 17:20]</span></span></li>
</ul>
<p>
一个 Overlay(覆盖层) 是如何表示的.
</p>

<p>
"overlay" (覆盖层)指定应用于缓冲区某一部分的属性.
</p>

<p>
每个覆盖层应用缓冲区中指定的范围,并包含一个属性列表(其元素是交替的属性名和属性
值).覆盖层属性是用来以不同的显示样式临时显示缓冲区的部分内容的. 覆盖层没有读取语
法,以哈希表示法打印,给出缓冲区名和位置的范围.
</p>

<p>
关于如何创建和使用覆盖层的信息,请参见 <a href="#org562b087">覆盖层(Overlays)</a>.
</p>
</div>
</li>

<li><a id="orgc284687"></a><span class="done DONE">DONE</span> 字体类型(Font Type)<br />
<div class="outline-text-5" id="text-orgc284687">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-22 Wed 17:36]</span></span></li>
</ul>
<p>
用于显示文本的字体.
</p>

<p>
"font" (字体) 指定在图形终端中如何显示文本.
</p>

<p>
实际上有三种不同的字体类型, "字体对象", "字体规格" 和 "字体实体",每种类型的属性
都略有不同. 它们都没有读取语法; 他们的打印语法分别是: <code>#&lt;font-object&gt;</code> ,
<code>#&lt;font-spec&gt;</code> 和 <code>#&lt;font-entity&gt;</code>.
</p>

<p>
关于这些 Lisp 对象的描述,参见 <a href="#orge1aca0a">低层字体(Low-Level Font)</a>.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org208487c" class="outline-4">
<h4 id="org208487c"><span class="done DONE">DONE</span> 循环对象(Circular Objects)</h4>
<div class="outline-text-4" id="text-org208487c">
<p>
circular 结构的读取语法.
</p>

<p>
要在一个对象的复合体中表达一个共享或循环的结构,你可以使用读取器构造 <code>#N=</code> 和
<code>#N#</code>.
</p>

<p>
在一个对象前面使用 <code>#N=</code> 来标记这个对象以供后面引用;随后,你可以使用 <code>#N#</code> 来在其
他地方引用同一的对象. 这里的 N 是整数. 例如,下面是一个列表的创建过程,在这个列表
中第一个元素作为第三个元素重复出现了:
</p>
<pre class="example" id="orgb5f7e90">
     (#1=(a) b #1#)
</pre>
<p>
这与普通的语法不同,例如:
</p>
<pre class="example" id="org3d93b33">
     ((a) b (a))
</pre>
<p>
普通语法也会生成一个列表,其第一个元素和第三个元素看起来一样,但不是同一个 Lisp 对
象. 下面的示例显示出它们的区别:
</p>
<pre class="example" id="orgd167c67">
     (prog1 nil
       (setq x '(#1=(a) b #1#)))
     (eq (nth 0 x) (nth 2 x))
          ⇒ t
     (setq x '((a) b (a)))
     (eq (nth 0 x) (nth 2 x))
          ⇒ nil
</pre>
<blockquote>
<p>
(nth n LIST) 返回 LIST 中索引为 n 的元素. 使用循环/共享结构语法生成的列表中,第一
个元素和第三个元素是同一个对象,而普通语法生成的列表中,第一个元素和第三个元素只能
说是具有相同内容的不同对象.
</p>
</blockquote>

<p>
你也可以使用同样的语法来生成一个循环/共享结构,该结构本身作为自身的一个元素出现,
下面是一个例子:
</p>
<pre class="example" id="org2bc6c1e">
     #1=(a #1#)
</pre>
<p>
这将生成一个列表,这个列表的第二个元素是它自身.在下面你可以看到它是如何真正运作
的:
</p>
<pre class="example" id="orgd325e21">
     (prog1 nil
       (setq x '#1=(a #1#)))
     (eq x (cadr x))
          ⇒ t
</pre>
<blockquote>
<p>
列表中每个元素都是 cons cell( 构造单元),每个元素的 CAR 指向/存放数据, CDR 则指向
列表中下一个元素,因此,列表的元素可以是列表自身,它是指向,而不是存放.
</p>
</blockquote>

<p>
如果你将 <code>print-circle</code> 变量绑定为一个非 <code>nil</code> 值,那么 Lisp 打印器就能够生成这种
语法来记录一个 Lisp 对象中的循环和共享结构. 参见 <a href="#orgb1bf5b1">输出变量(Output Variables)</a>
</p>
</div>
</div>

<div id="outline-container-orgc2fc5ac" class="outline-4">
<h4 id="orgc2fc5ac"><span class="done DONE">DONE</span> 类型断言(Type Predicates)</h4>
<div class="outline-text-4" id="text-orgc2fc5ac">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-23 Thu 11:08]</span></span></li>
</ul>
<p>
类型相关的测试. Predicates 断言?
</p>

<p>
当函数被调用时, Emacs Lisp 解释器自身不会对传递给函数的实际参数执行类型检查. 它
不能这样做,因为 Lisp 中的函数参数没有像其他编程语言中那样声明的数据类型. 因此,要
靠单个函数来测试实际的参数是否属于函数可以使用的类型.
</p>

<p>
所有的内置函数都会在适当的时候检查其实际参数的类型,如果参数的类型错误,则会发出
一个 <code>wrong-type-argument</code> 的错误信号. 例如,如果你向 "+" 传递一个它无法处理的参
数,会发生以下情况:
</p>
<pre class="example" id="orge2c00d0">
(+ 2 'a)
     error→ Wrong type argument: number-or-marker-p, a
</pre>
<p>
如果你想要你的程序对不同类型进行不同的处理,你必须执行显式类型检查. 检查一个对象
的类型最常用的方法是调用一个 "类型断言" 函数. Emacs 为每种类型都有一个类型断言,
以及一些用于组合类型的断言.
</p>

<p>
一个类型断言函数接受一个参数;如果参数属于适当的类型则返回 <code>t</code> ,反之则返回
<code>nil</code>. 遵循断言函数的一个通用的 Lisp 管理,大多数的类型断言的名称都以 <code>p</code> 结尾.
</p>

<p>
下面这个例子中使用了断言 <code>listp</code> 来测试列表,使用了 <code>symbolp</code> 来测试符号:
</p>
<pre class="example" id="org9489bcc">
     (defun add-on (x)
       (cond ((symbolp x)
              ;; If X is a symbol, put it on LIST.
              (setq list (cons x list)))
             ((listp x)
              ;; If X is a list, add its elements to LIST.
              (setq list (append x list)))
             (t
              ;; We handle only symbols and lists.
              (error "Invalid argument %s in add-on" x))))
</pre>
<blockquote>
<p>
cond 函数会执行每一个子句,直到有一个成功, 它的前两个子句都是用来测试参数 x 的类
型的,如果全失败了,就会执行第三个子句,返回错误信息.
</p>
</blockquote>

<p>
下面是一个预定义类型断言的列表,以字母表顺序排列,还带有进一步信息的引用.
</p>
<ul class="org-ul">
<li><code>atom</code> : 参见 <a href="#org622036f">atom</a> .</li>
<li><code>arrayp</code> : 参见 <a href="#orga12e3af">arrayp</a>.</li>
<li><code>bignump</code> : 参见 <a href="#org12871ce">floatp</a> .</li>
<li><code>bool-vector-p</code> : 参见 <a href="#org4b3540d">bool-vector-p</a>.</li>
<li><code>booleanp</code>: 参见 <a href="#org0464d25">booleanp</a></li>
<li><code>bufferp</code>: 参见 <a href="#orgfac7b85">bufferp</a> .</li>
<li><code>byte-code-function-p</code>: 参见 <a href="#org1c22079">byte-code-function-p</a> .</li>
<li><code>case-table-p</code>: 参见 <a href="#org50fbb35">case-table-p</a> .</li>
<li><code>char-or-string-p</code>: 参见 <a href="#org98774e8">char-or-string-p</a> .</li>
<li><code>char-table-p</code>: 参见 <a href="#org74ce9c3">char-table-p</a>.</li>
<li><code>commandp</code>: 参见 <a href="#org30f4580">commandp</a> .</li>
<li><code>condition-variable-p</code>: 参见 <a href="#orgb3c45a9">condition-variable-p</a>  .</li>
<li><code>consp</code>: 参见 <a href="#org622036f">consp</a> .</li>
<li><code>custom-variable-p</code>: 参见 <a href="#orga9166ed">custom-variable-p</a> .</li>
<li><code>fixnump</code>: 参见 <a href="#org12871ce">floatp</a> .</li>
<li><code>floatp</code>: 参见 <a href="#org12871ce">floatp</a>.</li>
<li><code>fontp</code>: 参见 <a href="#orge1aca0a">低层字体(Low-Level Font)</a> .</li>
<li><code>frame-configuration-p</code>: 参见 <a href="#org784167d">frame-configuration-p</a> .</li>
<li><code>frame-live-p</code>: 参见 <a href="#org6c473c3">frame-live-p</a> .</li>
<li><code>framep</code>: 参见 <a href="#org718863b">framep</a> .</li>
<li><code>functionp</code>: 参见 <a href="#org5921345">functionp</a> .</li>
<li><code>hash-table-p</code>: 参见 <a href="#orgdc3fd16">hash-table-p</a> .</li>
<li><code>integer-or-marker-p</code>: 参见 <a href="#org8194aed">interger-or-marker-p</a> .</li>
<li><code>integerp</code>: 参见 <a href="#org12871ce">integerp</a> .</li>
<li><code>keymapp</code>: 参见 <a href="#org799bd20">keymapp</a>  .</li>
<li><code>keywordp</code>: 参见 <a href="#orgde44202">常量(Constant Variable)</a> .</li>
<li><code>listp</code>: 参见 <a href="#org622036f">listp</a> .</li>
<li><code>markerp</code>: 参见 <a href="#org8194aed">markerp</a> .</li>
<li><code>mutexp</code>: 参见 <a href="#org899103b">mutexp</a> .</li>
<li><code>nlistp</code>: 参见 <a href="#org622036f">nlistp</a> .</li>
<li><code>number-or-marker-p</code>: 参见 <a href="#org8194aed">number-or-marker-p</a> .</li>
<li><code>numberp</code>: 参见 <a href="#org12871ce">numberp</a> .</li>
<li><code>overlayp</code>: 参见 <a href="#org562b087">overlayp</a> .</li>
<li><code>processp</code>: 参见 <a href="#org301788e">processp</a> .</li>
<li><code>recordp</code>: 参见 <a href="#org1df8e41">recordp</a> .</li>
<li><code>sequencep</code>: 参见 <a href="#org6f6c0f4">sequencep</a> .</li>
<li><code>string-or-null-p</code>: 参见 <a href="#org98774e8">string-or-null-p</a> .</li>
<li><code>stringp</code>: 参见 <a href="#org98774e8">stringp</a> .</li>
<li><code>subrp</code>: 参见 <a href="#org86bef4b">subrp</a> .</li>
<li><code>symbolp</code>: 参见 <a href="#orgf14e561">symbolp</a> .</li>
<li><code>syntax-table-p</code>: 参见 <a href="#org78c3e54">syntax-table-p</a> .</li>
<li><code>threadp</code>: 参见 <a href="#org3a73c7a">threadp</a> .</li>
<li><code>vectorp</code>: 参见 <a href="#org8139b11">vectorp</a>.</li>
<li><code>wholenump</code>: 参见 <a href="#org12871ce">wholenump</a> .</li>
<li><code>window-configuration-p</code>: 参见 <a href="#org8509ca3">window-configuration-p</a> .</li>
<li><code>window-live-p</code>: 参见 <a href="#orgb0b9038">window-live-p</a>.</li>
<li><code>windowp</code>: 参见 <a href="#org3ece239">windowp</a> .</li>
</ul>


<p>
检查一个对象的类型最常用的方法是调用 <code>type-of</code> 函数. 回想一下,每个对象都属于且仅
属于一个原始类型; <code>type-of</code> 则会告诉你是哪种原始类型(参见
<a href="#org9659351">Lisp 数据类型(Lisp Data Types)</a>). 但是 <code>type-of</code> 对非原始类型一无所知. 在大多数情
况下,使用类型断言比使用 <code>type-of</code> 更方便.
</p>

<dl class="org-dl">
<dt>函数: <code>(type-of OBJECT)</code></dt><dd><p>
这个函数返回一个命名 OBJECT 的原始类型的符号. 返回
的值可以是这些符号之一: <code>bool-vector</code>, <code>buffer</code>, <code>char-table</code>,
<code>compiled-function</code>, <code>condition-variable</code>, <code>cons</code>, <code>finalizer</code>, <code>float</code>,
<code>font-entity</code>, <code>font-object</code>, <code>font-spec</code>, <code>frame</code>, <code>hash-table</code>, <code>integer</code>,
<code>marker</code>, <code>mutex</code>, <code>overlay</code>, <code>process</code>, <code>string</code>, <code>subr</code>, <code>symbol</code>, <code>thread</code>,
<code>vector</code>, <code>window</code> 或 <code>window-configuration</code>. 然而,如果 OBJECT  是一个记录
(record), 则返回由其第一个插槽指定的类型; 参见 <a href="#org0dc4d87">记录(Records)</a>.
</p>
<pre class="example" id="orga5b086b">
	    (type-of 1)
		 ⇒ integer
	    (type-of 'nil)
		 ⇒ symbol
	    (type-of '())    ; ‘()’ is ‘nil’.
		 ⇒ symbol
	    (type-of '(x))
		 ⇒ cons
	    (type-of (record 'foo))
		 ⇒ foo
</pre></dd>
</dl>
</div>
</div>

<div id="outline-container-org9fe4c9b" class="outline-4">
<h4 id="org9fe4c9b"><span class="done DONE">DONE</span> 相等断言(Equality Predicates)</h4>
<div class="outline-text-4" id="text-org9fe4c9b">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-23 Thu 12:17]</span></span></li>
</ul>
<p>
两个对象之间的相等测试.
</p>

<p>
这部分我们讨论用来测试两个对象之间相等性的函数. 其他的这类函数是用来测试特定类型
的对象的内容的相等性,对于这些断言函数,请参阅描述数据类型的相应章节.
</p>

<dl class="org-dl">
<dt>函数: <code>(eq object1 object2)</code></dt><dd><p>
如果 object1 和 object 2 是同一个对象,则返回
<code>t</code> 反之,则返回 <code>nil</code> .
</p>

<p>
如果 object1 和 object2 是具有相同名字的符号,他们通常就是相等的对象,但也有例外,参
见 <a href="#org5f3730c">创建符号(Creating Symbols)</a>. 对于其他非数字类型(例如, 列表,向量,字符串),具有
相同内容或元素的两个参数不一定彼此相等:只有当他们是相同对象时才相等,这意味着一
个参数的内容改变将反应为另一个参数内容的相同变化.
</p>

<p>
如果 object1 和 object2 是不同类型或值的数字,他们就不可能是相同的变量, <code>eq</code> 会
返回 <code>nil</code>. 如果它们是值相同的小整数类型(fixnum), 则它们是相同的对象, <code>eq</code> 返
回 <code>t</code>. 如果它们是分开计算但是碰巧具有相同值并且同样是非小整数类型,那它们可能
是,也可能不是相同的对象, <code>eq</code> 会返回 <code>t</code> 或 <code>nil</code> ,这取决于 Lisp 解释器是创建
了一个对象还是两个对象.
</p>
<pre class="example" id="orgc04a9b9">
	    (eq 'foo 'foo)
		 ⇒ t

	    (eq ?A ?A)
		 ⇒ t

	    (eq 3.0 3.0)
		 ⇒ t or nil
	    ;; Equal floats may or may not be the same object.

	    (eq (make-string 3 ?A) (make-string 3 ?A))
		 ⇒ nil

	    (eq "asdf" "asdf")
		 ⇒ t or nil
	    ;; Equal string constants or may not be the same object.

	    (eq '(1 (2 (3))) '(1 (2 (3))))
		 ⇒ nil

	    (setq foo '(1 (2 (3))))
		 ⇒ (1 (2 (3)))
	    (eq foo foo)
		 ⇒ t
	    (eq foo '(1 (2 (3))))
		 ⇒ nil

	    (eq [(1 2) 3] [(1 2) 3])
		 ⇒ nil

	    (eq (point-marker) (point-marker))
		 ⇒ nil
</pre>

<p>
<code>make-symbol</code> 函数返回一个非内部符号,与在 Lisp 表达式中编写名称时使用的符号不
同.名字相同的不同符号是不相等的. 参见 <a href="#org5f3730c">创建符号(Creating Symbols)</a>.
</p>
<pre class="example" id="orge177708">
	    (eq (make-symbol "foo") 'foo)
		 ⇒ nil
</pre>

<p>
Emacs Lisp 字节编译器可能会将相同的字面值对象(例如,字符串字面值)折叠为对同一对
象的引用,其效果是字节编译的代码会将这些这样的对象视为相等的,而解释器版本的相同
代码则不会视为相等. 因此,你的代码永远不应该依赖于具有相同字面量内容的对象是否
相等,而是应该使用比较对象的内容的函数,例如下面会讲解的 <code>equal</code> 函数. 同样,你的
代码也不应该修改字面值对象(例如,为字面量字符串设置文本属性),因为这样做可能会影
响具有相同内容的其他字面量对象(如果字节编译器对它们进行了折叠).
</p>

<p>
这里的字面量对象,我的理解是,对象的内容是字面量,字面量本身是无法修改的,但是一个
对象存放/指向哪个字面量是可以修改的,例如对象 a 原本存放的是字符串 "123", "123"
本身是不能修改的,但是可以将 a 设置为存放带属性的字符串字面量 "123"
<code>#("123" 0 3 (face bold))</code>
</p></dd>

<dt>函数: <code>(equal object1 object2)</code></dt><dd><p>
如果 object1 和 object2 具有相同的内容,则返
回 <code>t</code> ,否则返回 <code>nil</code>. <code>eq</code> 测试其参数是否为相同对象,而 <code>equal</code> 则查看非相同
参数的内部元素或内容是否相等.因此,如果两个参数是 <code>eq</code> 的,那他们就是 <code>equal</code> 的,但
反过来不一定正确.
</p>
<pre class="example" id="orgdddac1b">
	    (equal 'foo 'foo)
		 ⇒ t

	    (equal 456 456)
		 ⇒ t

	    (equal "asdf" "asdf")
		 ⇒ t
	    (eq "asdf" "asdf")
		 ⇒ nil

	    (equal '(1 (2 (3))) '(1 (2 (3))))
		 ⇒ t
	    (eq '(1 (2 (3))) '(1 (2 (3))))
		 ⇒ nil

	    (equal [(1 2) 3] [(1 2) 3])
		 ⇒ t
	    (eq [(1 2) 3] [(1 2) 3])
		 ⇒ nil

	    (equal (point-marker) (point-marker))
		 ⇒ t

	    (eq (point-marker) (point-marker))
		 ⇒ nil
</pre>

<p>
字符串的比较是区分大小写的,但是不区分文本属性,只会比较字符串中的字符.
参见 <a href="#org05aca52">文本属性(Text Properties)</a>. 使用 <code>equal-including-properties</code> 函数来同时也
对文本属性进行比较. 由于技术原因, 当且仅当包含相同的字符编码序列,且所有字符编
码都在0到127(ASCII) 范围之内时,单字节字符串和多字节字符串是相等的.
</p>
<pre class="example" id="org5610a29">
	    (equal "asdf" "ASDF")
		 ⇒ nil
</pre>

<p>
,如果对象是整数,字符串,标记,向量,布尔向量,字节码函数对象,字符表,记录或字体对
象, <code>equal</code> 函数会递归地比较对象的内容. 其他对象只有在他们是 <code>eq</code> 时才会被视作
<code>equal</code>, 即使他们的文本内容相同.例如,两个不同的缓冲区即使具有相同的文本内容,也
永远不会被认为是 <code>equal</code> 的.
</p>

<p>
对于 <code>equal</code> 函数,相等性是递归定义的;例如,给定两个 cons cell, X 和 Y, 当且仅当下
面两个表达式都返回 <code>t</code> 时  <code>(equal X Y)</code> 才返回 <code>t</code>:
</p>
<pre class="example" id="orge0590e9">
  (equal (car X) (car Y))
  (equal (cdr X) (cdr Y))
</pre>
<p>
比较循环列表可能会发生深度递归,这种递归会引发错误,并且这可能会产生反直觉的行为,
例如 <code>(equal a b)</code> 返回 <code>t</code> 而 <code>(equal b a)</code> 则发出错误信号.
</p></dd>

<dt>函数: (equal-including-properties object1 object2)</dt><dd><p>
这个函数在所有情况下都与
<code>equal</code> 函数类似,但在比较两个字符串是否相等时,要求它们具有相同的文本属性:
</p>
<pre class="example" id="orge92dcd8">
	    (equal "asdf" (propertize "asdf" 'asdf t))
		 ⇒ t
	    (equal-including-properties "asdf"
					(propertize "asdf" 'asdf t))
		 ⇒ nil
</pre>
<p>
第一个表达式使用 equal ,它不比较文本属性,只比较字符串的字符序列是否相等,因此返
回 <code>t</code> , 第二个表达式还会比较文本属性,因此返回 <code>nil</code>
</p></dd>
</dl>
</div>
</div>

<div id="outline-container-org73c2bd1" class="outline-4">
<h4 id="org73c2bd1"><span class="done DONE">DONE</span> 易变性(Mutability)</h4>
<div class="outline-text-4" id="text-org73c2bd1">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-23 Thu 13:07]</span></span></li>
</ul>
<p>
不应该被修改的对象.
</p>

<p>
有些 Lisp 对象永远不应该更改. 例如, Lisp 表达式 <code>"aaa"</code> 生成一个字符串,但是你不
应该更改其内容.而有些对象不能被更改;例如,尽管你可以通过计算创建一个新的数字,但
Lisp 没有提供任何操作来修改一个已有的数字的值.
</p>

<p>
其他的 Lisp 对象是 "mutable" (可变的): 通过涉及副作用的破坏性操作来改变他们的值
也是安全的.例如,一个已有的标记可以通过移动标记指向别处来进行更改.
</p>

<p>
尽管数字永远不会更改,而所有的标记都是可变的, 但有些类型的成员中,有的是可变的,
有的是不可变的.这些类型包括 cons,vector 和 string. 例如,尽管 <code>"cons"</code> 和
<code>(symbol-name 'cons)</code> 都生成一个不应该更改的字符串,但 <code>(copy-sequence)</code> 和
<code>(make-strings 3 ?a)</code> 都生成的是可变的字符串,它们可以通过随后对 <code>aset</code> 的调用来
更改.
</p>

<p>
如果一个可变对象是一个被求值的表达式的一部分,则该对象就不再可变了,例如:
</p>
<pre class="example" id="org27221d5">
     (let* ((x (list 0.5))
            (y (eval (list 'quote x))))
       (setcar x 1.5) ;; The program should not do this.
       y)
</pre>
<p>
尽管列表 <code>(0.5)</code> 在创建时是可变的,但它应该不会被 <code>setcar</code> 更改,因为它已经被用在
<code>eval</code> 里了. 相反的情况则不会发生: 一个不应该被更改的对象在之后也永远不会变为可
变的.
</p>

<p>
如果一个程序试图更改不应该被更改的对象,则产生的行为是不确定的: Lisp 解释器可能发
送错误信号,也可能崩溃,或是表现为其他不可预测的行为.<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>
</p>

<p>
当类似的常量作为程序的一部分出现时, Lisp 解释器可通为了节省时间或空间而重用已有
的常量或它们的组件. 例如,表达式 <code>(eq "abc" "abc")</code> , 如果解释器只创建了字符串字
面量 <code>"abc"</code> 的一个实例,则返回 <code>t</code>, 如果创建了两个实例,则返回 <code>nil</code>. 因此,应该编
写这样的 Lisp 程序:无论是否使用了这种优化,都不会影响程序运行.
</p>
</div>
</div>
</div>

<div id="outline-container-orgf4cc629" class="outline-3">
<h3 id="orgf4cc629"><span class="done DONE">DONE</span> 数字(Numbers)</h3>
<div class="outline-text-3" id="text-orgf4cc629">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-26 Sun 14:08]</span></span></li>
</ul>
<p>
数字和算术函数.
</p>

<p>
GNU Emacs 支持两种数字数据类型: "integers"(整型) 和 "floating-poing numbers" (浮
点型数). 整型是整数,例如,-3,0,7,13 和 511. 浮点数是带小数部分的数字,例如 -4.5,
0.0 和 2.71828. 它们也可以用指数记数法表示: <code>1.5e2</code> 等价于 <code>150.0</code>; 这里的 <code>e2</code>
表示的是10 的 2 次幂, 然后乘以 1.5 . 整数的计算是精确的. 浮点数的计算通常涉及舍
入误差,因为数字具有固定的精度.
</p>
</div>

<div id="outline-container-orgd30d351" class="outline-4">
<h4 id="orgd30d351"><span class="done DONE">DONE</span> 整型基础(Integer Basic)</h4>
<div class="outline-text-4" id="text-orgd30d351">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-23 Thu 15:36]</span></span></li>
</ul>
<p>
整型的表示和范围.
</p>

<p>
Lisp 读取器将一个带有可选的起始符号和可选的结尾句号的十进制数的非空序列读取为一
个整型数:
</p>
<pre class="example" id="org17fd6a5">
      1               ; The integer 1.
      1.              ; The integer 1.
     +1               ; Also the integer 1.
     -1               ; The integer -1.
      0               ; The integer 0.
     -0               ; The integer 0.
</pre>

<p>
基数不是10 的整型的语法由 <code>#</code> 后面跟一个基数/进制指示符,再加上一个或多个数字组成.二
进制的进制指示符是 <code>b</code> (binary),八进制的是 <code>o</code> (octal), 十六进制的是 <code>x</code> (hex)
以及进制 RADIX 的进制指示符是 <code>RADIXr</code>. 因此, <code>#bINTEGER</code> 以二进制读取 INTEGER,
<code>#RADIXrINTEGER</code> 以进制 RADIX 读取INTEGER. RADIX 的可选值为从 2 到 36, 允许的数
字为从0 到 0-9, A-Z 中的第 RADIX 个值(例如,11 进制,就是允许 0-A, A 是 0-9, A-Z
中的第11 个数). 忽略字母的大小写,也没有起始符号和结尾的句号.例如:
</p>
<pre class="example" id="org389b249">
 二进制:    #b101100 ⇒ 44
 八进制:    #o54 ⇒ 44
 16进制:    #x2c ⇒ 44
 24进制:    #24r1k ⇒ 44
</pre>

<p>
要理解各种函数是如何与整数工作的,特别是位运算符(参见
<a href="#org000a652">位运算(BitWise Operations)</a>), 通常查看它们的二进制形式会很有帮助.
</p>

<p>
在二进制中,十进制数 5 是这样的:
</p>
<pre class="example" id="orgd14d588">
     ...000101
</pre>
<p>
(省略号 <code>...</code> 表示的是概念上与前面的位匹配的无限位数;这里表示无限位数的0.后面的
例子中也会使用这种 <code>...</code> 表示法.)
</p>

<p>
整数 <code>-1</code> 的二进制表示是这样的:
</p>
<pre class="example" id="org79daf4f">
     ...111111
</pre>
<p>
<code>-1</code> 的二进制表示全为1,(这叫 2 的补码表示法 "two's Complement")
</p>
<blockquote>
<p>
学过补码表示法,正数的补码是本身加上一个最高比特 0,表示符号,负数的补码,绝对值取反
加一.但是没有听说过 2 的补码表示法这种说法. -1 的补码,将 -1 的绝对值1的二进制
(&#x2026;001)取反(&#x2026;110)再加上1(&#x2026;111) 刚好全是1.
</p>

<p>
搜了下百科,"补码" 这个名词,就是 "2's complement" 的中文翻译&#x2026;
</p>
</blockquote>

<p>
这个章节中描述的许多函数都接受用标记代替数字作为参数.(参见 <a href="#orga7bfbe8">标记(Markers)</a>.) 因为
这种函数的实际参数可能是数字或标记,所以我们通常将这种参数取名叫做
NUMBER-OR-MARKER. 但参数值是标记(marker) 时,其位置值会被使用,而缓冲区值会被忽略.
</p>

<p>
在 Emacs Lisp 中,文本字符是作为整数表示的. 在 0 到 <code>(max-char)</code> 的值(含)之间的所有整
数,都被认为是一个有效的字符. 参见 <a href="#org65793c7">字符编码(Character Codes)</a>.
</p>

<p>
在 Emacs Lisp 中,整数不是限制为计算机信息元的大小.不过,在底层有两种整型:较小的称
为 "fixnum" 较大的称为 "bignums". 尽管 Emacs Lisp 代码通常不应该取决于整数是一个
小整型数还是大整型数,但比较旧的版本的 Emacs 只支持小整型数, Emacs 中的有些函数仍
然只支持小整型数.当给定一个大整型数时,更老的 Emacs Lisp 代码可能会遇到问题.例如,
虽然较老的 Emacs Lisp 代码可以安全地使用 <code>eq</code> 比较整数的数值是否相等,但大整型数
的存在,意味着现在应该使用像 <code>eql</code> 和 <code>=</code> 这样的相等断言来比较整数.
</p>

<p>
大整型的数值范围是受到内存大小,机器特性(例如用来表示大整型数的指数的信心元大小)
以及变量 <code>integer-with</code> 限制. 这些限制通常比小整型数的限制要宽松的多. 一个大整型
数在数值上永远不会等于一个小整型数;因为Emacs 总是会将一个在小整型数范围内的整数
表示为一个小整型数,而不是大整型数.(这意味着两者的实际可用值范围都不一样,所以不可
能相等.)
</p>

<p>
小整型的取值范围取决于机器.最小的范围是 -536870912 到 536870911 (30 比特;也就是
-2**29 到 2**29-1),但是许多机器都提供了更大的取值范围.
</p>

<dl class="org-dl">
<dt>变量: <code>most-positive-fixnum</code></dt><dd>这个变量的值是 Emacs Lisp 可以处理的最大的小整
型数.通常这个值是 2**29-1(32位平台) 和 2**61-1 (64位平台).</dd>
<dt>变量: <code>most-negative-fixnum</code></dt><dd>这个变量的值是 Emacs Lisp 可以处理的数值上最小
的小整型数. 它是一个负数.这个值通常为 -2**29 (32位平台)和 -2**61(64位平台)</dd>
<dt>变量: <code>integer-width</code></dt><dd>这个变量的值是一个非负整数,它用于控制在计算大的整数时,
Emasc 是否发出范围错误的信号.绝对值小于 2**N 的整数不会发出范围错误的信号,这里
的 N 就是这个变量的值.尝试创建一个更大的整数通常会发出范围错误信号,尽管如果能
很容易就创建一个更大的数,那么可能也不会发出信号.如果计算产生了巨大的整数,那么
将这个变量设置为一个大的数值可能会带来较大的计算成本.</dd>
</dl>
</div>
</div>

<div id="outline-container-orgeefbeee" class="outline-4">
<h4 id="orgeefbeee"><span class="done DONE">DONE</span> 浮点型基础(Float Basics)</h4>
<div class="outline-text-4" id="text-orgeefbeee">
<p>
浮点型的表示和范围.
</p>

<p>
浮点数在表示非整数时很有用. 浮点数的范围和你正在使用的计算机上 C 语言的 <code>double</code>
数据类型的范围是一样的. 在 Emacs 支持的所有计算机中,浮点数是 IEEE binary64 浮点
格式,这种格式是由 IEEE Std 754-2019 标准化的,并在 David Goldberg 的论文 "What
Every Computer Scientist Should Know About Floating-Point
Arithmetic(<a href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html</a>)" 中
做了进一步讨论.在现代平台中,浮点操作严格遵循 IEEE-754 标准;然而,在一些过时的平台
上,结果并不总是正确地四舍五入,尤其是在 32位 x86 平台.
</p>

<p>
浮点数的读取语法需要一个小数点或一个指数或两者都有.数字及指数前面有可选符号("+"
或 "-"). 例如, <code>1500.0</code> , <code>+15e2</code>, <code>15.0e+2</code>, <code>1500000e-3</code> 和 <code>1.5e4</code> 是值为
1500 的浮点数的五种不同写法. 它们都是相等的. 与 Common Lisp 类似, Emacs Lisp 也
要求在没有指数的浮点数的小数点后至少有一位数字; <code>1500.</code> 是一个整型数,而不是浮点
型数.
</p>

<p>
对于像 <code>=</code> 这样的数值比较, Emacs Lisp 将 <code>-0.0</code> 视为与普通 0 在数值上是相等的.这
遵循了 IEEE 浮点标准,即, <code>-0.0</code> 和 <code>0.0</code> 在数值上是相等的,即使在其他运算中它们是
不同的.
</p>

<p>
IEEE 浮点标准支持正无穷和负无穷作为浮点值.也提供了一类值叫做 "NaN" 意思是"not a
number"; 在没有正确答案的情况下,数值函数会返回这样的值. 例如, <code>(/ 0.0 0.0)</code> 会返
回 NaN. NaN 永远不会在数值上等于任何值,即使是它本身. NaN 有符号位和有效位,当符号
位和有效位相等时,非数值函数就会将它们视为相等. NaN 的有效位取决于计算机,它们的字
符串表示中的数字也是如此.
</p>

<p>
当涉及 NaN 和带符号的0 时,非数值函数(<code>eql</code>, <code>equal</code>, <code>sxhash-eql</code>,
<code>sxhash-equal</code> 和 <code>gethash</code>) 会确定他们的值是否可以区分,而不是它们是否在数值上相
等. 例如,当 X 和 Y 是同一个 NaN 时, <code>(equal X Y)</code> 返回 <code>t</code>, 而 <code>(= X Y)</code> 使用的
是数值比较,返回 <code>nil</code>. 相反的, <code>(equal 0.0 -0.0)</code> 返回 <code>nil</code> 而 <code>(= -0.0 0.0)</code>
返回 <code>t</code>.
</p>

<p>
下面是一些特殊的浮点值的读取语法:
</p>

<dl class="org-dl">
<dt>infinity(无穷)</dt><dd><code>1.0e+INF</code> 和 <code>-1.0e+INF</code></dd>
<dt>not-a-number(非数值)</dt><dd><code>0.0e+NaN</code> 和 <code>-0.0e+NaN</code></dd>
</dl>


<p>
下面这些函数是专门用来处理浮点数的:
</p>
<dl class="org-dl">
<dt>函数: <code>(isnan X)</code></dt><dd>如果浮点参数是 NaN ,这个断言函数返回 <code>t</code>, 否则返回 <code>nil</code>.</dd>
<dt>函数: <code>(frexp X)</code></dt><dd><p>
这个函数返回一个 cons cell <code>(S . E)</code>, 其中 S 和 E 分别是
浮点数 X 的有效数字和指数.
</p>

<p>
如果 X 是有穷的,那么 S 就是一个 0.5(含)到1.0(不含)之间的浮点数, E 是一个整数,
且 X = S * 2**E. 如果 X 是0或是无穷数, S 就和 X 一样. 如果 X 是一个 NaN, 那么
S 也是 Nan. 如果 X 是 0, E 就是 0.
</p></dd>
<dt>函数: <code>(ldexp s e)</code></dt><dd>给定一个有效数字 s 和一个指数 e, 这个函数就会返回浮点数
S * 2**E.</dd>
<dt>函数: <code>(copysign X1 X2)</code></dt><dd>这个函数会将 X2 的符号复制给 X1 的值,并返回结果,
X1 和 X2 都必需是浮点数.
<code>(copysign -1.0 1.0)</code> 返回 1.0</dd>
<dt>函数: <code>(logb X)</code></dt><dd><p>
这个函数返回 X 的二进制指数.更精确地讲,如果 X 是有穷数和
非0数, 返回值是 |X| 的以二为底的对数,并四舍五入为整数的结果. 如果 X 是0或无穷
的,返回值也是无穷的; 如果 X 是 NaN, 则返回值是 NaN.
</p>
<pre class="example" id="org8b6231d">
	    (logb 10)
		 ⇒ 3
	    (logb 10.0e20)
		 ⇒ 69
	    (logb 0)
		 ⇒ -1.0e+INF
</pre></dd>
</dl>
</div>
</div>

<div id="outline-container-org12871ce" class="outline-4">
<h4 id="org12871ce"><span class="done DONE">DONE</span> 数字的断言(Predicates on Numbers)</h4>
<div class="outline-text-4" id="text-org12871ce">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-24 Fri 15:06]</span></span></li>
</ul>
<p>
测试数字.
</p>

<p>
这一节里的函数都是用来测试数字或用于特定类型的数字的. 函数 <code>integerp</code> 和
<code>floatp</code> 可以接收任意类型的 Lisp 对象作为参数(否则它们就没什么用了),但 <code>zerop</code>
这个断言函数要求参数是数字. 另请参阅 <a href="#org8194aed">标记的断言(Predicates on Markers)</a> 中的
<code>integer-or-marker-p</code> 和 <code>number-or-marker-p</code>.
</p>

<blockquote>
<p>
前面提过,大整型数有精度,也就是说大整型数其实跟浮点数一样,都不是计算机能完全表示
的,都是近似的表示,所以大整型数的比较就不能用 eq 了.
</p>
</blockquote>

<dl class="org-dl">
<dt>函数: <code>(bignump object)</code></dt><dd>这个断言用来测试其参数是否为一个大整型数,如果是返
回 <code>t</code>, 否则返回 <code>nil</code>. 与小整型数不同,大整型数可以是 <code>=</code> 或 <code>eql</code> 的,即使他们
不是 <code>eq</code> 的. 意思就是,它们在数值上是可以相等的,即使它们不是同一个对象.</dd>
<dt>函数: <code>(fixnump object)</code></dt><dd>这个断言测试其参数是否是一个小整型数,如果是,返回
<code>t</code>, 否则,返回 <code>nil</code>. 小整型数可以用 <code>eq</code> 比较.</dd>
<dt>函数: <code>(floatp object)</code></dt><dd>这个断言测试其参数是否为浮点数,如果是,返回 <code>t</code>, 否
则,返回 <code>nil</code>.</dd>
<dt>函数: <code>(integerp object)</code></dt><dd>这个断言测试其参数是否为整型,如果是,返回 <code>t</code>, 否
则,返回 <code>nil</code>.</dd>
<dt>函数: <code>(numberp object)</code></dt><dd>这个断言测试其参数是否为数值(整数或浮点数),如果是,
返回 <code>t</code>, 否则,返回 <code>nil</code>.</dd>
<dt>函数: <code>(natnump object)</code></dt><dd><p>
这个断言(断言的名字来自于短语 "natural number" 自
然数)测试其参数是否为一个非负整数,如果是,返回 <code>t</code>, 否则, 返回 <code>nil</code>. 0 被认为
是非负的.
</p>

<p>
<code>wholenump</code> 是 <code>natnump</code> 的同义词(也就是说同一个函数的不同名字).
</p></dd>
<dt>函数: <code>(zerop number)</code></dt><dd>这个断言测试其参数是否为 0 ,如果是,返回 <code>t</code>, 否则,
返回 <code>nil</code>. 其参数必须是数字. <code>(zerop x)</code> 等价于 <code>(= x 0)</code>.</dd>
</dl>
</div>
</div>

<div id="outline-container-org8d901a6" class="outline-4">
<h4 id="org8d901a6"><span class="done DONE">DONE</span> 数字的比较(Comparison of Numbers)</h4>
<div class="outline-text-4" id="text-org8d901a6">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-25 Sat 21:40]</span></span></li>
</ul>
<p>
相等和不等的断言.
</p>

<p>
要测试数字的数值相等性,你通常应该使用 <code>=</code> 而不是像 <code>eq</code>, <code>eql</code> 和 <code>equal</code> 这样的
非数值比较断言, 有区别的浮点数和大整型数对象在数值上可以是相等的. 如果你使用
<code>eq</code> 来比较他们,你测试的是他们是否为同一对象; 如果你使用 <code>eql</code> 或 <code>equal</code> ,你测
试的是他们的值是否可以区分开来. 相反的, <code>=</code> 使用的是数值比较,而且当非数值比较返
回 <code>nil</code> 时, <code>=</code> 有时会返回 <code>t</code> ,反之亦然. 参见 <a href="#orgeefbeee">浮点型基础(Float Basics)</a>.
</p>

<p>
在 Emacs Lisp 中,如果两个小整型数在数值上相等,他们就是同一个的 Lisp 对象. 也就是
说,对于小整型数, <code>eq</code> 等价于 <code>=</code>. 有时使用 <code>eq</code> 来比较一个未知值和一个小整型数是
很方便的,因为如果未知值不是一个数字 <code>eq</code> 也不会报告错误(<code>eq</code> 接收任何类型的参数).然
而,如果可以的话,使用 <code>=</code> 是更好的编程实践,即使是在比较整数时也应该如此.
</p>

<p>
有时使用 <code>eql</code> 或 <code>equal</code> 也很有用, 如果数字具有相同的数据类型(都是整型,或都是浮
点型)和相同的值,它们就会将两个数字视为相等的. 相比之下, <code>=</code> 可以将一个整型和一个
浮点型数视为相等. 参见 <a href="#org9fe4c9b">相等断言(Equality Predicates)</a>.
</p>

<p>
还有一个问题:因为浮点数算术是不精确的,所以检查浮点值的相等性通常是一个坏主意.通
常,最好是测试近似相等性.下面是一个执行近似相等比较的函数:
</p>

<pre class="example" id="orga312103">
     (defvar fuzz-factor 1.0e-6)              ;; 定义一个浮点数类型的变量 fuzz-factor
     (defun approx-equal (x y)
       (or (= x y)
           (&lt; (/ (abs (- x y))
                 (max (abs x) (abs y)))
              fuzz-factor)))
</pre>

<dl class="org-dl">
<dt><code>(= number-or-marker &amp;rest number-or-markers)</code></dt><dd>这个函数测试其所有参数是否在
数值上相等,如果相等则返回 <code>t</code> ,否则返回 <code>nil</code>.</dd>
<dt><code>(eql value1 value2)</code></dt><dd>这个函数与 <code>eq</code> 的行为类似,除了当两个参数都是数值时不
同. 它会通过类型和数值比较数字,所以 <code>(eql 1.0 1)</code> 会返回 <code>nil</code>, 但是
<code>(eql 1.0 1.0)</code> 和 <code>(eql 1 1)</code> 都返回 <code>t</code>. 这可以用来比较大整型数和小整型数.
有着相同符号,指数和小数的浮点数也是 <code>eql</code> 的. 这与数值比较有所区别:
<code>(eql 0.0 -0.0)</code> 返回 <code>nil</code>, <code>(eql 0.0e+NaN 0.0e+NaN)</code> 返回 <code>t</code>, 然而 <code>=</code> 的比
较结果正好相反.</dd>
<dt><code>(/= number-or-marker1 number-or-marker2)</code></dt><dd>这个函数测试其两个参数是否在数值
上是相等的,如果是则返回 <code>t</code>, 否则返回 <code>nil</code>.</dd>
<dt><code>(&lt; number-or-marker &amp;rest number-or-markers)</code></dt><dd>这个函数测试测试其每个参数是
否严格小于后面的参数,如果是,则返回 <code>t</code>, 否则返回 <code>nil</code>.</dd>
<dt><code>(&lt;= number-or-marker &amp;rest number-or-markers)</code></dt><dd>这个函数测试其每个参数是否
小于或等于后面的参数,如果是,则返回 <code>t</code>, 否则返回 <code>nil</code>.</dd>
<dt><code>(&gt; number-or-marker &amp;rest number-or-markers)</code></dt><dd>这个函数测试其每个参数是否严
格大于后面的参数, 如果是,则返回 <code>t</code>, 否则返回 <code>nil</code>.</dd>
<dt><code>(&gt;= number-or-marker &amp;rest number-or-markers)</code></dt><dd>这个函数测试其每个参数是否
大于或等于后面的参数, 如果是,则返回 <code>t</code>, 否则返回 <code>nil</code>.</dd>
<dt><code>(max number-or-marker &amp;rest number-or-markers)</code></dt><dd><p>
这个函数返回参数中最大的
一个.
</p>
<pre class="example" id="org954509a">
	    (max 20)
		 ⇒ 20
	    (max 1 2.5)
		 ⇒ 2.5
	    (max 1 3 2.5)
		 ⇒ 3
</pre></dd>
<dt><code>(min number-or-marker &amp;rest number-or-markers)</code></dt><dd><p>
这个函数返回参数中最小的一
个.
</p>
<pre class="example" id="org79a94dc">
	    (min -4 1)
		 ⇒ -4
</pre></dd>
<dt><code>(abs number)</code></dt><dd><p>
这个函数返回 number 的绝对值.
</p>
<pre class="example" id="org773ae14">

  (abs -1)
	⇒ 1
</pre></dd>
</dl>
</div>
</div>

<div id="outline-container-org1e0eb75" class="outline-4">
<h4 id="org1e0eb75"><span class="done DONE">DONE</span> 数字转换(Numeric Conversions)</h4>
<div class="outline-text-4" id="text-org1e0eb75">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-25 Sat 21:59]</span></span></li>
</ul>
<p>
将浮点型转为整型,反之亦然.
</p>

<p>
要将一个整型数转换乘一个浮点数,请使用 <code>float</code> 函数.
</p>

<dl class="org-dl">
<dt><code>(float number)</code></dt><dd>这个函数返回 number 转换乘的浮点数. 如果 number 已经是一个
浮点数了, <code>float</code> 返回它自身,不会有变化.</dd>
</dl>


<p>
有两种将浮点数转换成整型数的函数,它们在舍入上有所不同. 它们都接收一个参数 NUMBER
和一个可选参数 DIVISOR. 两个参数都可以是整型或浮点型数. DIVISOR 也可以是
<code>nil</code>. 如果 DIVISOR 是 <code>nil</code> 或省略了, 这些函数会将 NUMBER 转换成一个整数,如果其
已经是整数了,就直接返回没有变化的值. 如果 DIVISOR 是非 <code>nil</code>, 它们会用 NUMBER 除
以 DIVISOR 然后将结果转换成整型数. 如果 DIVISOR 是 0(不管是整型还是浮点型的0),
Emacs 都会发出一个 <code>arith-error</code> 的错误信号.
</p>

<dl class="org-dl">
<dt><code>(truncate NUMBER &amp;optional divisor)</code></dt><dd><p>
这个函数返回向0取整后转换乘整数的
NUMBER.
</p>
<pre class="example" id="org3e4aba1">
	    (truncate 1.2)
		 ⇒ 1
	    (truncate 1.7)
		 ⇒ 1
	    (truncate -1.2)
		 ⇒ -1
	    (truncate -1.7)
		 ⇒ -1
</pre></dd>
<dt><code>(floor NUMBER &amp;optional divisor)</code></dt><dd><p>
这个函数返回向下(向负无穷)取整后转换成
整型的 NUMBER.
</p>

<p>
如果指定了 DIVISOR, 则使用与 <code>mod</code> (取模)类似的除法运算(得到商和余数),然后将商
将向下取整.
</p>
<pre class="example" id="orgb5ca79e">
	    (floor 1.2)
		 ⇒ 1
	    (floor 1.7)
		 ⇒ 1
	    (floor -1.2)
		 ⇒ -2
	    (floor -1.7)
		 ⇒ -2
	    (floor 5.99 3)
		 ⇒ 1
</pre></dd>
<dt><code>(ceiling number &amp;optional divisor)</code></dt><dd><p>
这个函数返回向上(向正无穷)取整后转换成
整型的 NUMBER.
</p>
<pre class="example" id="org3f4fcb4">
	    (ceiling 1.2)
		 ⇒ 2
	    (ceiling 1.7)
		 ⇒ 2
	    (ceiling -1.2)
		 ⇒ -1
	    (ceiling -1.7)
		 ⇒ -1
</pre></dd>
<dt><code>(round number &amp;optional divisor)</code></dt><dd><p>
这个函数返回向最近的整数取整后转换成整型
的 NUMBER. 将两个整数之间等距的值取整,会返回偶数值.
</p>
<pre class="example" id="orgb6168f5">
  (round 1.2)
       ⇒ 1
  (round 1.7)
       ⇒ 2
  (round -1.2)
       ⇒ -1
  (round -1.7)
       ⇒ -2
  (round 1.5)
       ⇒ 2
</pre></dd>
</dl>
</div>
</div>


<div id="outline-container-org5c7d3e5" class="outline-4">
<h4 id="org5c7d3e5"><span class="done DONE">DONE</span> 算术运算(Arithmetic Operations)</h4>
<div class="outline-text-4" id="text-org5c7d3e5">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-26 Sun 02:24]</span></span></li>
</ul>
<p>
如何加减乘除.
</p>

<p>
Emacs Lisp 提供了传统的四种算术运算(加减乘除),也提供了取余和取模函数,还有加一减
一的函数. 除了 <code>%</code> 之外,其他的这些函数都接受整型和浮点型参数,如果任意参数是浮点
型,则会返回一个浮点型数.
</p>

<dl class="org-dl">
<dt><code>(1+ number-or-marker)</code></dt><dd><p>
这个函数返回 NUMBER-OR-MARKER 加一.例如:
</p>
<pre class="example" id="org29f8d1c">
	    (setq foo 4)
		 ⇒ 4
	    (1+ foo)
		 ⇒ 5
</pre>
<p>
这个函数与 C 语言的操作符 <code>++</code> 不同,它不递增变量,它只是计算一个和,因此,如果我
们继续上面例子的操作:
</p>
<pre class="example" id="orgfc073ea">
          foo
               ⇒ 4
</pre>
<p>
如果你想要一个变量递增,你必须像这样使用 <code>setq</code>:
</p>
<pre class="example" id="org292f236">
          (setq foo (1+ foo))
               ⇒ 5
</pre></dd>
<dt><code>(1- NUMBER-OR-MARKER)</code></dt><dd>这个函数返回 NUMBER-OR-MARKER 减一.</dd>
<dt><code>(+ &amp;rest numbers-or-markers)</code></dt><dd><p>
这个函数将其所有参数相加,并返回和,当给定0个
参数时, <code>+</code> 返回 0.
</p>
<pre class="example" id="org4a6d891">
	    (+)
		 ⇒ 0
	    (+ 1)
		 ⇒ 1
	    (+ 1 2 3 4)
		 ⇒ 10
</pre></dd>
<dt><code>(- &amp;optional number-or-marker &amp;reset more-numbers-or-markers)</code></dt><dd><p>
<code>-</code> 函数有
两个用途: 减法和负数. 当 <code>-</code> 只有一个参数时,返回值是参数的负数.当有多个参数时,
<code>-</code> 将从 number-or-marker 中累计减去每个 more-numbers-or-markers . 如果没有参
数,则返回值为0.
</p>
<pre class="example" id="org16568f1">
	    (- 10 1 2 3 4)
		 ⇒ 0
	    (- 10)
		 ⇒ -10
	    (-)
		 ⇒ 0
</pre></dd>
<dt><code>(* &amp;rest numbers-or-markers)</code></dt><dd><p>
这个函数将其参数相乘,并返回乘积. 当给定0个参
数时,~*~ 返回1 .
</p>
<pre class="example" id="orgae33fbe">
          (*)
               ⇒ 1
          (* 1)
               ⇒ 1
          (* 1 2 3 4)
               ⇒ 24
</pre></dd>
<dt><code>(/ number &amp; rest divisors)</code></dt><dd><p>
当有一个或多个 divisors 时,这个函数用 number
去依次除以 divisors 中每个除数,然后返回商. 当没有 divisors 时,这个函数返回
1/number, 也就是 number 的乘法逆(也叫乘法逆元,就是我们说的倒数). 每个参数可以
是一个数字或标记.
</p>

<p>
如果所有参数都是整型,返回值就是一个整型数,返回值的整数是通过将每次除法后得到的
商向0四舍五入后得到的.
</p>
<pre class="example" id="org4a108e4">
	    (/ 6 2)
		 ⇒ 3
	    (/ 5 2)
		 ⇒ 2
	    (/ 5.0 2)
		 ⇒ 2.5
	    (/ 5 2.0)
		 ⇒ 2.5
	    (/ 5.0 2.0)
		 ⇒ 2.5
	    (/ 4.0)
		 ⇒ 0.25
	    (/ 4)
		 ⇒ 0
	    (/ 25 3 2)
		 ⇒ 4
	    (/ -17 6)
		 ⇒ -2
</pre>
<p>
如果你将一个整数除以0, Emacs 会发出一个 <code>arith-error</code> 的错误信号(参见
 <a href="#org060e07a">错误(Errors)</a>). 用非零值除以零的浮点数除法会产生无穷大或无穷小.(参见
  <a href="#orgeefbeee">浮点型基础(Float Basics)</a>)
</p></dd>
<dt><code>(% dividend divisor)</code></dt><dd><p>
这个函数返回 dividend 除以 divisor 后的整型余数.参数
必须是整数或标记.这个返回余数的操作也叫模运算.
</p>

<p>
对于任意的两个被除数和除数,如果除数非0,则下面的表达式总是等于被除数.
</p>
<pre class="example" id="orge4ecb1c">
	    (+ (% DIVIDEND DIVISOR)
	       (* (/ DIVIDEND DIVISOR) DIVISOR))
</pre>
<p>
一些用例:
</p>
<pre class="example" id="org6005713">
	    (% 9 4)
		 ⇒ 1
	    (% -9 4)
		 ⇒ -1
	    (% 9 -4)
		 ⇒ 1
	    (% -9 -4)
		 ⇒ -1
</pre></dd>
<dt><code>(mod dividend divisor)</code></dt><dd><p>
这个函数返回 dividend 模 divisor 的值;也就是说
dividend 除以 divisor 后的余数,但是符号与 divisor 相同. 参数必须是数字或标记.
</p>

<p>
与 <code>%</code> 不同, <code>mod</code> 允许浮点型参数; 它会将商向下(向负无穷)取整为一个整数,并且用
取整后的商来计算余数.
</p>

<p>
如果 divisor 是 0,且两个参数都是整型, <code>mod</code> 会发出 <code>arith-error</code> 错误信号, 否
则,就会返回 <code>NaN</code>. (mod 1 0) 会发出错误信号, (mod 2 0.0) 会返回 <code>NaN</code>.
</p>

<p>
用例:
</p>
<pre class="example" id="orgf7ca0c8">
	    (mod 9 4)
		 ⇒ 1    ;; 9 除以4等于2.25, 向下取整为2,然后用 2 计算余数,9-4*2=1
	    (mod -9 4)
		 ⇒ 3	 ;; 余数与除数符号相等,-9/4=-2.25 向下取整,得到 -3, -9-(4*-3) = 3.
	    (mod 9 -4)
		 ⇒ -3   ;; -2.25 向下取整为 -3, 9-(-3*-4)=-3.
	    (mod -9 -4)
		 ⇒ -1
	    (mod 5.5 2.5)
		 ⇒ .5
</pre>
<p>
对于任意数字 dividend 和 divisor, 下面的表达式总等于 dividend:
</p>
<pre class="example" id="orgff2299d">
	    (+ (mod DIVIDEND DIVISOR)
	       (* (floor DIVIDEND DIVISOR) DIVISOR))
</pre>
<p>
如果其中一个参数是浮点值,则会出现舍入错误,如果 dividend 是一个整数,且 divisor
是0,则会发出 <code>arith-error</code> 的错误信号. 对于 <code>floor</code> 函数,参见
<a href="#org1e0eb75">数字转换(Numeric Conversions)</a>.
</p></dd>
</dl>
</div>
</div>

<div id="outline-container-org8bf1e68" class="outline-4">
<h4 id="org8bf1e68"><span class="done DONE">DONE</span> 舍入运算(Rounding Operations)</h4>
<div class="outline-text-4" id="text-org8bf1e68">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-26 Sun 02:34]</span></span></li>
</ul>
<p>
显式地舍入浮点数.
</p>

<p>
函数 <code>ffloor</code>, <code>fceiling</code>, <code>fround</code> 和 <code>ftruncate</code> 接受一个浮点型参数并返回一个
值为附近整数的浮点型结果. <code>ffloor</code> 返回向下(负无穷)最近的整数; <code>fceiling</code> 返回向
上(正无穷)最近的整数, <code>ftruncate</code> 返回向0取整的最近的整数; <code>fround</code> 返回最近的整
数.
</p>

<blockquote>
<p>
ffloor , fceiling, fround  和 ftruncate 就是 <a href="#org1e0eb75">数字转换(Numeric Conversions)</a> 中取
整函数的浮点数版本.
</p>
</blockquote>

<dl class="org-dl">
<dt><code>(ffloor float)</code></dt><dd>这个函数将 float 向负无穷方向取整为整数,并返回值为该整数的
浮点数值.</dd>
<dt><code>(fceiling float)</code></dt><dd>这个函数将 float 下正无穷方向取整为整数,并返回值为该整数
的浮点数值.</dd>
<dt><code>(ftruncate float)</code></dt><dd>这个函数将 float 向0的方向取整为整数,并返回值为该整数的
浮点数值.</dd>
<dt><code>(fround float)</code></dt><dd>这个函数将 float 取整为最近的整数,返回值为该整数的浮点数值.取
整一个值与最近的两个整数等距的值,会返回最近的偶数值.</dd>
</dl>
</div>
</div>

<div id="outline-container-org000a652" class="outline-4">
<h4 id="org000a652"><span class="done DONE">DONE</span> 位运算(BitWise Operations)</h4>
<div class="outline-text-4" id="text-org000a652">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-26 Sun 11:32]</span></span></li>
</ul>
<p>
逻辑与,或,非,位移/移位?.
</p>

<p>
在一台计算机中,整数是表示为一个二进制数字的,是一个"bits"(比特,位)的序列(数字为0
或1). 在概念上,比特/位序列的左边是无穷的, 最高有效比特/位是全0或全1. 一个位操作
就是作用于这样一个序列的各个位/比特的. 例如, "shifting"(移位)操作将整个序列向左
或向右移动一位或多位,复制相同的移动模式.
</p>

<p>
位运算在 Emacs Lisp 中仅适用于整数.
</p>

<dl class="org-dl">
<dt><code>(ash integer1 count)</code></dt><dd><p>
<code>ash</code> ("arithmetic shift") 会将 integer1 的比特/位向
左移动 count 个位置,或是向右移动(如果 count 是负数). 左移会在右边产生0比特/位,
右移会丢弃最右边的比特/位. <code>ash</code> 被视为一个整数运算,它将 integer1 乘以
2**count 然后将结果向下(负无穷)取整为一个整数.
</p>

<p>
下面有一些 <code>ash</code> 的用例, 将比特/位模式向左或向右移动一个位置. 这些例子只显示了
二进制模式的低位比特. 前面省略的比特都与显示的最高为比特相同.正如你所见的,左移
一位等价于乘以2,而右移一位相当于除以2然后向负无穷取整.
</p>
<pre class="example" id="orgbb05f1e">
	    (ash 7 1) ⇒ 14
	    ;; Decimal 7 becomes decimal 14.
	    ...000111
		 ⇒
	    ...001110

	    (ash 7 -1) ⇒ 3
	    ...000111
		 ⇒
	    ...000011

	    (ash -7 1) ⇒ -14
	    ...111001
		 ⇒
	    ...110010

	    (ash -7 -1) ⇒ -4
	    ...111001
		 ⇒
	    ...111100
</pre>
<p>
下面是一些左移或右移两个比特/位的例子:
</p>
<pre class="example" id="org2850f37">
			      ;         binary values
	    (ash 5 2)         ;   5  =  ...000101
		 ⇒ 20         ;      =  ...010100
	    (ash -5 2)        ;  -5  =  ...111011
		 ⇒ -20        ;      =  ...101100
	    (ash 5 -2)
		 ⇒ 1          ;      =  ...000001
	    (ash -5 -2)
		 ⇒ -2         ;      =  ...111110
</pre></dd>

<dt><code>(lsh integer1 count)</code></dt><dd><p>
<code>lsh</code>, 是 "logical shift" (逻辑位移) 的缩写,会将
integer1 的比特/位序列向左移动 count 个位置,或是向右移动 count 个位置(如果
count 是负数),空出的位用0补齐. 如果 count 是负数,那么 integer1 必须是小整型数
或是一个正的大整型数, <code>lsh</code> 通过在移位前通过减去两倍的 <code>most-negative-fixnum</code>
来将负的小整型数当作是无符号的,从而产生一个非负结果. 这种离奇的行为可以追溯到
Emacs 只支持小整型数的时候,现在, <code>ash</code> 函数是一个更好的选择.
</p>

<p>
因为 <code>lsh</code> 与 <code>ash</code> 类似,除了当 integer1 和 count 都是负数时不同,所以下面的例
子只关注这些不同的情况. 这些例子都假定是 30位/比特的小整型数.
</p>
<pre class="example" id="org5bfb3da">
		   ;      binary values
  (ash -7 -1)      ; -7 = ...111111111111111111111111111001
       ⇒ -4        ;    = ...111111111111111111111111111100
  (lsh -7 -1)
       ⇒ 536870908 ;    = ...011111111111111111111111111100
  (ash -5 -2)      ; -5 = ...111111111111111111111111111011
       ⇒ -2        ;    = ...111111111111111111111111111110
  (lsh -5 -2)
       ⇒ 268435454 ;    = ...001111111111111111111111111110
</pre></dd>

<dt><code>(logand &amp;rest ints-or-markers)</code></dt><dd><p>
这个函数返回参数的位与: 当且仅当所有参数
的第 N 位/比特全为 1, 则结果的第 N 位/比特才是 1.( logical and 逻辑与,位与)
</p>

<p>
例如,使用4位二进制数,13和12 的位与结果是12: 1101 和 1100 位与产生 1100.在两个
二进制数中,最左边的两个比特都是1,因此结果的最左边两位也都是1, 最右边的两位/比
特,每个都至少有一个是0,因此结果最右边的两个比特都是0.
因此:
</p>
<pre class="example" id="org912ea58">
	    (logand 13 12)
		 ⇒ 12
</pre>
<p>
如果 <code>logand</code> 没有传递任何参数,它会返回一个值 <code>-1</code>. 这个数字是 <code>logand</code> 的恒等
元(单位元,中立元),因为其二进制表示全由1组成. 如果 <code>logand</code> 只传递了一个参数,它
就会返回该参数(因为它与一个全为 1 的二进制数进行了位与操作.).
</p>
<pre class="example" id="org9f513b3">
			       ;        binary values

	    (logand 14 13)     ; 14  =  ...001110
			       ; 13  =  ...001101
		 ⇒ 12         ; 12  =  ...001100

	    (logand 14 13 4)   ; 14  =  ...001110
			       ; 13  =  ...001101
			       ;  4  =  ...000100
		 ⇒ 4          ;  4  =  ...000100

	    (logand)
		 ⇒ -1         ; -1  =  ...111111
</pre></dd>

<dt><code>(logior &amp;rest ints-or-markers)</code></dt><dd><p>
这个函数返回其参数的按位或运算: 当且仅当
其所有参数的第 N 位至少有一个是 1 时,结果的第 N 位才是 1. 如果未给定参数,结果
就是0,也是这个操作的单位元. 如果 <code>logior</code> 只给定一个参数,则返回该参数(与一个全
为 0 的二进制数进行按位或运算.).
</p>
<pre class="example" id="org62f0c43">
			       ;        binary values

	    (logior 12 5)      ; 12  =  ...001100
			       ;  5  =  ...000101
		 ⇒ 13         ; 13  =  ...001101

	    (logior 12 5 7)    ; 12  =  ...001100
			       ;  5  =  ...000101
			       ;  7  =  ...000111
		 ⇒ 15         ; 15  =  ...001111
</pre></dd>

<dt><code>(logxor &amp;rest ints-or-markers)</code></dt><dd><p>
这个函数返回其参数的按位异或运算: 当且仅
当其所有参数的第 N 位有奇数个 1 时,其结果的第 N 位才为1. 如果未给定参数,结果就
是0,也是这个操作的恒等元.如果 <code>logxor</code> 只给定一个参数,则返回该参数(与一个全为
0 的二进制数进行按位异或).
</p>
<pre class="example" id="orgeb0e5b2">
			       ;        binary values

	    (logxor 12 5)      ; 12  =  ...001100
			       ;  5  =  ...000101
		 ⇒ 9          ;  9  =  ...001001

	    (logxor 12 5 7)    ; 12  =  ...001100
			       ;  5  =  ...000101
			       ;  7  =  ...000111
		 ⇒ 14         ; 14  =  ...001110
</pre></dd>

<dt><code>(lognot integer)</code></dt><dd><p>
这个函数返回其参数的按位补码: 当且仅当 integer 的第 N 位
是0 时,其结果的第 N 位才是 1, 反之亦然.其结果等于 -1-integer 的值.
</p>
<pre class="example" id="org0ee8412">
  (lognot 5)
       ⇒ -6
  ;;  5  =  ...000101
  ;; becomes
  ;; -6  =  ...111010
</pre>
<p>
负数在计算机中的二进制形式是取其绝对值然后取反再加一得到的.减一取反再加上符号
位可以将 &#x2026;111010 转换成人类可读的二进制了 1&#x2026;000110, 第一位的1 是符号位,表
示负数.
</p></dd>

<dt><code>(logcount integer)</code></dt><dd><p>
这个函数返回 integer 的汉明权重: integer 的二进制表示
中,1 的个数. 如果 integer 是负数,则返回其二进制补码表示的0的个数.结果总是非负
的.
</p>
<pre class="example" id="org41be305">
	    (logcount 43)     ;  43 = ...000101011
		 ⇒ 4
	    (logcount -43)    ; -43 = ...111010101
		 ⇒ 3
</pre></dd>
</dl>
</div>
</div>

<div id="outline-container-org4c9e8f2" class="outline-4">
<h4 id="org4c9e8f2"><span class="done DONE">DONE</span> 数学函数(Math Functions)</h4>
<div class="outline-text-4" id="text-org4c9e8f2">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-26 Sun 12:16]</span></span></li>
</ul>
<p>
三角函数,指数函数和对数函数.
</p>

<p>
下面这些数学函数允许整数和浮点数作为参数.
</p>

<dl class="org-dl">
<dt><code>(sin arg)</code></dt><dd></dd>

<dt><code>(cos arg)</code></dt><dd></dd>

<dt><code>(tan arg)</code></dt><dd>这些是基本的三角函数,参数 arg 以弧度作为测量单位.</dd>
<dt><code>(asin arg)</code></dt><dd><code>(asin arg)</code> 的值是一个位于 -pi/2(含) 到 pi/2(含) 之间的,且其
sine(正弦)值为 arg 的数字. 如果 arg 的值超出了范围(在 [-1, 1] 之外),则 <code>asin</code>
会返回一个 NaN.</dd>
<dt><code>(acos arg)</code></dt><dd><code>(acos arg)</code> 的值是一个位于 0(含) 到 pi(含) 之间的,且其
cos(余弦)值为 arg 的数字. 如果 arg 的值超出了范围(在 [-1, 1] 之外),则 <code>acos</code>
会返回一个 NaN.</dd>

<dt><code>(atan y &amp;optional x)</code></dt><dd><code>(actan Y)</code> 的值是一个位于 -pi/2(不含) 到 pi/2 (不含)
之间的,且其 tangent (正切值) 为 Y 的数字. 如果给定了第二个可选参数 X, 则
<code>(atan y x)</code> 的值是向量 <code>[X, Y]</code> 与 X 轴之间的角度(以弧度为单位).</dd>
<dt><code>(exp arg)</code></dt><dd>这是一个指数函数,返回 e 的 arg 次幂.</dd>
<dt><code>(log arg &amp;optional base)</code></dt><dd>这个函数返回以 base 为底的 arg 的对数.如果你不指
定 base, 则会使用自然基数 e. 如果 arg 或 base 是负数,则 <code>log</code> 返回一个 NaN.</dd>
<dt><code>(expt x y)</code></dt><dd>这个函数返回 X 的 Y 次幂. 如果两个参数都是整数,且 Y 是非负数,
则结果是一个整数; 在这种情况下,溢出会发出错误信号,所以要小心. 如果 X 是一个有
穷的负数,且 Y 是一个有穷的非数数,则 <code>expt</code> 会返回一个 NaN.</dd>
<dt><code>(sqrt arg)</code></dt><dd>这个函数返回 arg 的平方根. 如果 arg 是有穷的,且小于0,则 <code>sqrt</code>
会返回一个 NaN.</dd>
</dl>


<p>
此外, Emacs 还定义了下面常见的数学常量:
</p>
<dl class="org-dl">
<dt><code>float-e</code></dt><dd>数学常量 e (2.71828&#x2026;).</dd>
<dt><code>float-pi</code></dt><dd>数学常量 pi (3.14159&#x2026;).</dd>
</dl>
</div>
</div>


<div id="outline-container-org09faeb9" class="outline-4">
<h4 id="org09faeb9"><span class="done DONE">DONE</span> 随机数(Random Numbers)</h4>
<div class="outline-text-4" id="text-org09faeb9">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-26 Sun 14:08]</span></span></li>
</ul>
<p>
生成可预测或不可预测的随机数.
</p>

<p>
一个确定性的计算机程序不可能生成真正的随机数. 对于大多数用途来说 "pseudo-random
numbers" (伪随机数)就够用了. 一系列的伪随机数是以确定性方式生成的. 这些数字不是
真正随机的,但是他们具有模仿随机序列的某些特性. 例如,在伪随机序列中,所有可能的值
出现的频率相同.
</p>

<p>
伪随机数是由 "种子值" 生成的. 由任意给定的种子值开始, <code>random</code> 函数总是会生成相
同的数字序列. 默认情况下, Emacs 在启动时会初始化随机数种子值, 以这样的方式,每次
Emacs 运行时 <code>random</code> 的值序列都会不同(是具有极大可能性,不是一定).
</p>

<p>
有时你希望随机数序列是可重复的.例如当调试一个行为取决于随机数序列的程序时,在每个
程序运行中得到相同的行为是很有帮助的. 要让序列重复,请执行 <code>(random "")</code>. 这将会
把你运行的特定的 Emacs 种子值设置为一个常量值(尽管不同的 Emacs 版本可能会有所不
同).你也可以使用其他字符串来选择各种种子值.
</p>

<dl class="org-dl">
<dt><code>(random &amp;optional limit)</code></dt><dd><p>
这个函数返回一个伪随机整数. 重复调用会返回一系列
的 伪随机整数.
</p>

<p>
如果 limit 是一个正整数,返回值就从小于 limit 的非负数中选择. 否则,该值可能会是
任意小整型数,也就是任意从 <code>most-negative-fixnum</code> 到 <code>most-positive-fixnum</code> 中
选取的整数(参见 <a href="#orgd30d351">整型基础(Integer Basic)</a>).
</p>

<p>
如果 limit 是 <code>t</code>, 这意味着会选取一个新的种子值,就像 Emacs 重启了一样,种子值通
常是来自系统熵. 在缺乏熵池的系统熵,会从随机性更小的数据(例如当前时间)中选取种
子值.
</p>

<p>
如果 limit 是一个字符串,它意味着基于字符串的内容选取一个新的种子值.
</p></dd>
</dl>
</div>
</div>
</div>


<div id="outline-container-orgb4aecb8" class="outline-3">
<h3 id="orgb4aecb8"><span class="done DONE">DONE</span> 字符串和字符(Strings and Characters)</h3>
<div class="outline-text-3" id="text-orgb4aecb8">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-05 Tue 13:08]</span></span></li>
</ul>
<p>
字符串和字符串相关的函数
</p>

<p>
Emcas Lisp 中的字符串是一个包含字符的有序序列的数组.字符串用来作为符号,缓冲区和
文件的名字;用作发送给用户的消息;用来保存从缓冲区间复制的文本;以及许多其他的用途.
因为字符串是如此重要, Emacs Lisp 有着许多专门用于操作字符串的函数. Emacs Lisp 程
序使用字符串的频率高于单个字符.
</p>

<p>
关于键盘字符事件字符串的特殊注意事项请参见 <a href="#orgad73c35">事件字符串(Strings of Events )</a>.
</p>
</div>

<div id="outline-container-org2931f49" class="outline-4">
<h4 id="org2931f49"><span class="done DONE">DONE</span> 基础(Basics)</h4>
<div class="outline-text-4" id="text-org2931f49">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-26 Sun 15:45]</span></span></li>
</ul>
<p>
字符串和字符的基本属性.
</p>

<p>
字符是表示文本中单个字符的 Lisp 对象. 在 Emacs Lisp 中字符只是整数; 一个整数是否
为一个字符只取决于它是如何被使用的. 关于 Emacs 中字符表示的细节请参见
<a href="#org65793c7">字符编码(Character Codes)</a>.
</p>

<p>
字符串是固定的字符序列. 这是一种叫做 "array" (数组)的序列类型,意味着它的长度是固
定的,而且一旦创建就不能被更改了(参见
<a href="#orgc0e0dcf">序列 数组 向量(Sequences Arrays Vectors)</a>). 与 C 语言不同, Emacs Lisp 的字符串不
是由一个可区分的字符编码结束的.
</p>
<blockquote>
<p>
C 语言是以 '\0' 字符作为字符串的结束标志符的. 而 Emacs Lisp 的字符串不是以 '\0'
作为字符串的结束标识.
</p>
</blockquote>

<p>
由于字符串是数组,因此它也是序列,你可以使用在
<a href="#orgc0e0dcf">序列 数组 向量(Sequences Arrays Vectors)</a> 中记录的常规数组和序列函数来操作他们.
例如,你可以使用 <code>aref</code> 来访问一个字符串中的单个字符(参见
<a href="#orga12e3af">数组函数(Array Functions)</a>).
</p>

<p>
Emacs 字符串(以及缓冲区)中非 ASCII 字符有两种表示法: 单字节和多字节. 对于大多数
Lisp 变成来说,你不需要考虑这两种表示法. 更多细节请参见
<a href="#org263a727">文本表示(Text Representations)</a>.
</p>

<p>
有时按键序列会表示为单字节字符串. 就是当一个单字节字符串是一个按键序列,且位于
128 到255 之间的字符串元素表示的是元字符(meta 字符)(大整数类型数)而不是128到255
之间的字符时. 字符串中不能包含有着 hyper, super 或 alt 修饰符的字符编码;他们可以
包含 ASCII 控制字符,但是不能有其他控制字符. 如果你想要在序列中储存这样的字符,例
如作为一个按键序列, 你必需使用一个向量而不是一个字符串.更多关于键盘输入字符的信
息请参见 <a href="#orga65fe6b">字符类型(Character Type)</a>.
</p>

<p>
字符串对于保存正则表达式很有用. 你还可以使用 <code>string-match</code> (参见
<a href="#org8dfde4e">正则搜索(Regexp Search)</a>) 来将字符串与正则表达式进行匹配. 函数 <code>match-string</code> (参
见 <a href="#org52dda59">简单匹配数据(Simple Match Data)</a>) 和 <code>replace-match</code> (参见
<a href="#orga390081">替换匹配(Replacing Match)</a>) 对于在将字符串与正则表达式匹配后分解和修改字符串很有
用.
</p>

<p>
和缓冲区类似,一个字符串可以包含字符串的文本属性,也可以包含字符串本身. 参见
<a href="#org05aca52">文本属性(Text Properties)</a>. 所有从字符串中复制文本到缓冲区或到其他字符串的原始函
数也会复制被复制的字符的属性.
</p>

<p>
关于显示字符串或是将它们复制到缓冲区的相关函数的信息,请参见 <a href="#org3ec44e9">文本(Text)</a>. 有关字符
和字符串语法的信息,请参见 <a href="#orga65fe6b">字符类型(Character Type)</a> 和
<a href="#org3fe47cb">字符串类型(String Type)</a>. 有关文本表示和字符编码的编码解码之间的相互转换,请参见
<a href="#org9ab52af">非 ASCII 字符(Non-ASCII Characters)</a>. 另外,请注意, <code>length</code> 函数不应该被用来计算
一个用于显示的字符串的宽度;而应该使用 <code>string-width</code> (参见
<a href="#org09acbcb">显示的文本的大小(Size of Displayed Text)</a>).
</p>
<blockquote>
<p>
我猜测是因为文本属性的原因,用于显示的文本总会有大小,颜色等各种属性,因此,大小不能
用 length 函数计算.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org98774e8" class="outline-4">
<h4 id="org98774e8"><span class="done DONE">DONE</span> 字符串的断言(Predicates for Strings)</h4>
<div class="outline-text-4" id="text-org98774e8">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-26 Sun 15:49]</span></span></li>
</ul>
<p>
测试一个对象是否为字符串或字符.
</p>

<p>
关于常规的序列和数组断言的更多信息,请参见
<a href="#orgc0e0dcf">序列 数组 向量(Sequences Arrays Vectors)</a>  和 <a href="#orga89d466">数组(Arrays)</a>.
</p>

<dl class="org-dl">
<dt><code>(stringp object)</code></dt><dd>如果 object 是一个字符串,则返回 <code>t</code>, 否则,返回 <code>nil</code>.</dd>
<dt><code>(string-or-null-p object)</code></dt><dd>如果 object 是一个字符串或是 <code>nil</code> ,则该函数返
回 <code>t</code>, 否则,返回 <code>nil</code>.</dd>
<dt><code>(char-or-string-p object)</code></dt><dd>如果 object 是一个字符串或是一个字符(也就是一个
整数), 则该函数返回 <code>t</code>, 否则,返回 <code>nil</code>.</dd>
</dl>
</div>
</div>

<div id="outline-container-orgd539f64" class="outline-4">
<h4 id="orgd539f64"><span class="done DONE">DONE</span> 创建字符串(Creating Strings)</h4>
<div class="outline-text-4" id="text-orgd539f64">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-27 Mon 16:55]</span></span></li>
</ul>
<p>
用来分配新字符串的函数.
</p>

<p>
下面的函数用于创建字符串,可以从头开始,也可以将字符串组合在一起,或是将他们拆
开.(关于基于其他字符串的修改过的内容创建字符串的函数,例如 <code>string-replace</code> 和
<code>replace-regexp-in-string</code> ,请参见 <a href="#org42e5cd6">搜索和替换(Search and Replace)</a>.)
</p>

<dl class="org-dl">
<dt><code>(make-string count character &amp;optional multibyte)</code></dt><dd><p>
这个函数返回一个由
cahracter 重复 count 次组成的字符串. 如果 count 是一个负数,则会发出错误信号.
</p>
<pre class="example" id="org6dec383">
	    (make-string 5 ?x)
		 ⇒ "xxxxx"
	    (make-string 0 ?x)
		 ⇒ ""
</pre>
<p>
通常来讲,如果 character 是一个 ASCII 字符,结果就是一个单字节字符串. 但是如果可
选参数 multibyte 是非 <code>nil</code> 的,该函数就会生成一个多字节字符串. 当你后续需要将
结果与非 ASCII 字符串拼接或用非 ASCII 字符替换其中的某些字符时会很有用.
</p>

<p>
与次函数向比较的其他函数包括 <code>make-vector</code> (参见 <a href="#org8139b11">向量(Vectors)</a>) 和 <code>make-list</code>
(参见 <a href="#org2213f78">构建列表(Building Lists)</a>).
</p></dd>

<dt><code>(string &amp;rest characters)</code></dt><dd><p>
这个函数返回一个由 characters 组成的字符串.
</p>
<pre class="example" id="org2aec099">
	    (string ?a ?b ?c)
		 ⇒ "abc"
</pre></dd>

<dt><code>(substring string &amp;optional start end)</code></dt><dd><p>
这个函数返回一个新的字符串,该字符
串由 string 中的字符组成, 这些字符位于 string 中索引从 start(含) 到 end (不含)
的范围. 第一个字符是位于索引0位置的.只有一个参数时,这个函数只是复制 string.
</p>

<pre class="example" id="orge6e8051">
  (substring "abcdefg" 0 3)
       ⇒ "abc"
</pre>
<p>
在上面这个例子中, <code>a</code> 的索引是0, <code>b</code> 的索引是1, <code>c</code> 的是2. 索引3,字符串的第四
个字符,标记 <code>substring</code> 函数复制的最高索引位置(不含). 因此 <code>abc</code> 从字符串
<code>abcdefg</code> 中复制出来了.
</p>

<p>
负数则从字符串的尾部开始计数,所以 <code>-1</code> 意味着字符串的最后一个字符的索引.例如:
</p>
<pre class="example" id="org4b25790">
	    (substring "abcdefg" -3 -1)
		 ⇒ "ef"
</pre>
<p>
在这个例子中, <code>e</code> 的索引是 -3, <code>f</code> 的是 -2, <code>g</code> 的是 -1. 因此 e 和 f 是包含的,
g 是不包含的.
</p>

<p>
当 end 是 <code>nil</code> 时,这表示的是字符串的长度,因此:
</p>
<pre class="example" id="org86f92ba">
  (substring "abcdefg" -3 nil)
       ⇒ "efg"

  (length "abcdefg")
       ⇒ 7

  (substring "abcdefg" -3 7)
       ⇒ "efg"
</pre>
<p>
省略参数 end 等价于将其指定为 <code>nil</code>. 因此, <code>(substring STRING 0)</code> 返回整个
STRING 的副本.
</p>
<pre class="example" id="org111e80f">
	    (substring "abcdefg" 0)
		 ⇒ "abcdefg"
</pre>
<p>
但这个用法我们推荐使用 <code>copy-sequence</code> 函数(参见
<a href="#org6f6c0f4">序列函数(Sequence Functions)</a>).
</p>

<p>
如果从 string 中复制的字符有着文本属性,其文本属性也会被复制到新的字符串中. 参
见 <a href="#org05aca52">文本属性(Text Properties)</a>.
</p>

<p>
<code>substring</code> 也接受向量作为第一个参数,例如:
</p>
<pre class="example" id="org39a44fc">
	    (substring [a b (c) "d"] 1 3)
		 ⇒ [b (c)]
</pre>

<p>
如果 start 不是整数或者 end 不是整数或 <code>nil</code>, 则会发出一个
<code>wrong-type-argument</code> 的错误信号. 如果 start 指示的是 end 后面的字符,或者其中
一个整数超出了 string 的范围,则会发出一个 <code>args-out-of-range</code> 的错误信号.
</p>

<p>
次函数与 <code>buffer-substring</code> 函数(参见
 <a href="#org72b73c0">缓冲区内容(Buffer Contents)</a>)相比,后者返回一个字符串,包含了当前缓冲区中的一部
分文本.字符串的开始位于索引0处,但缓冲区的开头位于索引 1 处.
</p></dd>

<dt><code>(substring-no-properties string &amp;optional start end)</code></dt><dd>这个函数与
<code>substring</code> 类似,但是会丢弃掉所有的文本属性. 此外, start 也可以省略或为 <code>nil</code>,
等价于设置为 0. 因此 <code>(substring-no-properties string)</code> 返回一个移除了所有文本
属性的 string 的副本.</dd>

<dt><code>(concat &amp;rest sequences)</code></dt><dd><p>
这个函数返回一个由传递给它的参数的字符组成的字符
串(如果有的话,也包括参数的文本属性). 参数可以是字符串,数字的列表或数字的向量;
这些参数自身是没有改变的. 如果 <code>concat</code> 接收了 0 个参数,它会返回一个空的字符串.
</p>
<pre class="example" id="orgd1a1574">
	    (concat "abc" "-def")
		 ⇒ "abc-def"
	    (concat "abc" (list 120 121) [122])
		 ⇒ "abcxyz"
	    ;; ‘nil’ is an empty sequence.
	    (concat "abc" nil "-def")
		 ⇒ "abc-def"
	    (concat "The " "quick brown " "fox.")
		 ⇒ "The quick brown fox."
	    (concat)
		 ⇒ ""
</pre>
<p>
这个函数也不总是分配一个新的字符串.建议该函数的调用者不要依赖与结果是一个新的
字符串或是依赖于它和已有的字符串 <code>eq</code> (eq 是相同对象)
</p>

<p>
特别的,更改其返回值可能会无意中更改另一个字符串,修改程序中的常量字符串,甚至是
引发一个错误.想要获得一个你可以安全地更改的字符串,请对结果使用
<code>copy-sequence</code>.
</p>

<p>
关于其他的拼接函数的信息,请参见 <a href="#orgd2781b6">映射函数(Mapping Functions)</a> 中的 <code>mapconcat</code>
函数, <a href="#org714d4f3">向量函数(Vectors Functions)</a> 中的 <code>vconcat</code> 函数以及
<a href="#org2213f78">构建列表(Building Lists)</a>  中 <code>append</code> 函数的相关描述. 对于拼接单个命令行参数到
一个字符串中以便用在一个 shell 命令中,参见 <a href="#orga93600a">Shell 参数(Shell Arguments)</a> .
</p></dd>

<dt><code>(split-string string &amp;optional separators omit-nulls trim)</code></dt><dd><p>
这个函数基于正
则表达式 separators (参见 <a href="#org3c6463d">正则表达式(Regular Expressions)</a>) 将 string 分隔为子
字符串. separators 的每个匹配项都会定义一个分隔点;分隔点之间的子字符串会被放进
一个列表中,这个列表就是函数的返回值.
</p>

<p>
如果 separators 是 <code>nil</code> (或者省略),其默认值就为
<code>split-string-default-separators</code>  的值,并且函数的行为就像 omit-nulls 是 <code>t</code>
一样.
</p>

<p>
如果 omit-nulls 是 <code>nil</code> (或者省略),只要分隔符有两个连续匹配项,或是与字符串的
开头或结尾相邻,则该位置就会有一个空字符串. 如果 omit-nulls 是 <code>t</code>, 这些空字符
串就会从结果中省略.
</p>

<p>
如果你需要将一个字符串分隔成适用于 <code>call-process</code> 或 <code>start-process</code> 的单个命
令行参数列表,请参阅 <a href="#orga93600a">Shell 参数(Shell Arguments)</a>.
示例:
</p>
<pre class="example" id="orgfb7b7d7">
          (split-string "  two words ")
               ⇒ ("two" "words")
</pre>
<p>
返回值不是 <code>("" "two" "words" "")</code>, 这很少有用. 如果你需要这样的结果,请使用一
个显式值作为 separators:
</p>
<pre class="example" id="org570a61f">
	    (split-string "  two words "
			  split-string-default-separators)
		 ⇒ ("" "two" "words" "")

	    (split-string "Soup is good food" "o")
		 ⇒ ("S" "up is g" "" "d f" "" "d")
	    (split-string "Soup is good food" "o" t)
		 ⇒ ("S" "up is g" "d f" "d")
	    (split-string "Soup is good food" "o+")
		 ⇒ ("S" "up is g" "d f" "d")
</pre>
<p>
空匹配项也有效,但 <code>split-string</code> 在达到字符串的末尾或当 string 为空时使用一个
非空匹配的情况下不会查找最后一个空匹配项:
</p>
<pre class="example" id="org669c8f0">
	    (split-string "aooob" "o*")
		 ⇒ ("" "a" "" "b" "")
	    (split-string "ooaboo" "o*")
		 ⇒ ("" "" "a" "b" "")
	    (split-string "" "")
		 ⇒ ("")
</pre>

<p>
然而, 当 seperators 可以匹配空字符串时, omit-nulls 通常为 <code>t</code>, 因此上面三个例
子中的微妙之处很少相关:
</p>
<pre class="example" id="org80e1ac3">
	    (split-string "Soup is good food" "o*" t)
		 ⇒ ("S" "u" "p" " " "i" "s" " " "g" "d" " " "f" "d")
	    (split-string "Nice doggy!" "" t)
		 ⇒ ("N" "i" "c" "e" " " "d" "o" "g" "g" "y" "!")
	    (split-string "" "" t)
		 ⇒ nil
</pre>
<p>
separators 中的某些"非贪婪"值可能会出现一些奇怪但是可预测的行为,这些行为可能更
喜欢空匹配而不是非空匹配.再一次强调,这样的值很少出现在实践中:
</p>
<pre class="example" id="org7af14c1">
	    (split-string "ooo" "o*" t)
		 ⇒ nil
	    (split-string "ooo" "\\|o+" t)
		 ⇒ ("o" "o" "o")
</pre></dd>

<dt>变量 <code>split-string-default-separators</code></dt><dd><code>split-string</code> 的 separators 参数的
默认值. 通常为 <code>"[ \f\t\n\r\v]+"</code>.</dd>

<dt><code>(string-clean-whitespace string)</code></dt><dd>通过将空格折叠为一个空格字符,并删除
string 前后的所有空格,来清理 string 中的空格.</dd>

<dt><code>(string-trim-left string &amp;optional regexp)</code></dt><dd>从 string 中删除与 regexp 匹配
的前导文本. regexp 默认为 <code>[ \t\n\r]+</code></dd>

<dt><code>(string-trim-right string &amp;optional regexp)</code></dt><dd>从 string 中删除与 regexp 匹
配的尾部文本. regexp 默认为 <code>[ \t\n\r]+</code></dd>

<dt><code>(string-trim string &amp;optional trim-left trim-right)</code></dt><dd>从 string 中删除与
trim-left 匹配的前导文本以及与 trim-right 匹配的尾部文本. 两个正则表达式都默认
为 <code>[ \t\n\r]+</code>.</dd>

<dt><code>(string-fill string length)</code></dt><dd>尝试将 string 自动换行,这样就不会有超过
length 长度的行了.填充仅在空白的边界上完成. 如果有个别单词的长度超过了 length,
则这些地方不会被缩短.</dd>

<dt><code>(string-limit string length &amp;optional end coding-system)</code></dt><dd><p>
如果 string 比
length 个字符短,会原样返回 string. 否则,会返回由 string 的前 length 个字符组成
的子字符串. 如果给定了可选参数 end, 则返回 string 的最后 length 个字符组成的子
字符串.
</p>

<p>
如果 coding-system 是非 <code>nil</code>, string 会在限制之前先被编码,然后结果会返回一个
小于 length 个字节的单字节字符串. 如果 string 包含会被编码为多字节的字符(例如,
当使用了 <code>utf-8</code> 编码的字符时), 返回的单字节字符串永远不会在一个字符表示的中间
截断.
</p>

<p>
这个函数会测量字符串的字符长度或字节长度,因此如果你想要让一个用于显示的字符串
缩短,通常这个函数是不合适的; 你应该使用 <code>truncate-string-to-width</code> 或
<code>window-text-pixel-size</code> (参见 <a href="#org09acbcb">显示的文本的大小(Size of Displayed Text)</a>).
</p></dd>

<dt><code>(string-lines string &amp;optional omit-nulls)</code></dt><dd><p>
以换行符为边界将 string 分隔为
一个字符串的列表. 如果给定了 omit-nulls 值,则从结果中移除空的行.
</p>
<pre class="example" id="org3acf611">
  (string-lines "123
  123
  123")
	       ⇒ ("123" "123" "123")
  (string-lines "123
  123

  123 ")

	       ⇒ ("123" "123" "" "123")
</pre></dd>

<dt><code>(string-pad string length &amp;optional padding start)</code></dt><dd><p>
使用 padding 作为填充
字符将 string 填充为给定的 length 长度. padding 的默认值是空格字符. 如果
string 比 length 长,则不会进行填充. 如果 start 是 <code>nil</code> 或是省略,则在字符串的
字符后面填充,如果其不是 <code>nil</code> , 则在字符串字符的前面填充.
</p>
<pre class="example" id="org41ebff3">
  (string-pad "123" 5)
	       ⇒ ("123  ")
  (string-pad "123" 5 ?\s t)
	       ⇒ ("  123")
</pre></dd>

<dt><code>(string-chop-newline string)</code></dt><dd>从 string 中移除最后的一个换行符,如果有的话.</dd>
</dl>
</div>
</div>


<div id="outline-container-org2a04154" class="outline-4">
<h4 id="org2a04154"><span class="done DONE">DONE</span> 修改字符串(Modifying Strings)</h4>
<div class="outline-text-4" id="text-org2a04154">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-27 Mon 18:32]</span></span></li>
</ul>
<p>
修改已有字符串的内容.
</p>

<p>
你可以通过这一小节描述的操作来修改一个可变字符串的内容. 参见
<a href="#org73c2bd1">易变性(Mutability)</a>.
</p>

<p>
修改一个已有字符串中内容的最基本的方式是使用 <code>aset</code> 函数(参见
<a href="#orga12e3af">数组函数(Array Functions)</a>). <code>(aset STRING INDEX CHAR)</code> 会将 CHAR 储存到 STRING
中位于字符索引 INDEX 的位置. 如果有必要,这个函数会自动将一个纯 ASCII 字符串转换
成一个多字节字符串(参见 <a href="#org263a727">文本表示(Text Representations)</a>) ,但如果 CHAR 是一个非
ASCII 字符,而不是原始字节. 我们建议始终确保 STRING 是多字节的(例如,使用
<code>string-to-multibyte</code> 函数, 参见
<a href="#orgfbaf65b">转换表示形式(Converting Representations)</a>.).
</p>

<p>
一个更强大的函数是 <code>store-substring</code>:
</p>

<dl class="org-dl">
<dt><code>(store-substring string index object)</code></dt><dd><p>
这个函数通过将 object 储存到字符索
引为 index 的位置来修改指定的 string 中的部分内容. object 参数可以是一个字符
(这种情况下,该函数和 <code>aset</code> 的效果一样)或是一个(更小的)字符串. 如果 object 是
一个多字节字符串, 我们建议确保 string 也是多字节的, 即使它是纯 ASCII 编码的.
</p>

<p>
因为修改一个已有的字符串的字符数量(也就是数组长度)是不可能的,所以如果 object
的字符数超过了 string 中从字符索引 index 开始的字符数,则会发出一个错误信号.
</p></dd>
</dl>


<p>
要清空一个包含有密码信息的字符串,请使用 <code>clear-string</code>:
</p>

<dl class="org-dl">
<dt><code>(clear-string string)</code></dt><dd><p>
这个函数会将 string 转换成单字节字符串,并将其内容清
零. 这也可能会改变 string 的长度.
</p>
<blockquote>
<p>
说实话,这里的可能改变 string 的长度我是不理解的, (clear-string "123") 的返回值
为 nil. (setq var_1 "123") (clear-string var_1) 之后 var_1 的值变为了
"   ",因为 var_1 的内容都清零了, 字符编码0 表示的是 <code>C-@</code>. 可能是这个清零的
操作会在某种情况改变字符串的长度? 按理说,字符串是属于数组,数组的长度是不可以改
变的啊.
</p>
</blockquote></dd>
</dl>
</div>
</div>

<div id="outline-container-org3bcdb05" class="outline-4">
<h4 id="org3bcdb05"><span class="done DONE">DONE</span> 文本比较(Text Comparison)</h4>
<div class="outline-text-4" id="text-org3bcdb05">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-27 Mon 22:11]</span></span></li>
</ul>
<p>
比较字符或字符串.
</p>

<dl class="org-dl">
<dt><code>(char-equal character1 character2)</code></dt><dd><p>
如果参数代表相同字符,则返回 <code>t</code>, 否则,
返回 <code>nil</code>. 如果 <code>case-fold-search</code> 是非 <code>nil</code> 的,那这个函数会忽视大小写.
</p>
<pre class="example" id="org868e0d0">
  (char-equal ?x ?x)
       ⇒ t
  (let ((case-fold-search nil))
    (char-equal ?x ?X))
       ⇒ nil
</pre></dd>
<dt><code>(string= string1 string2)</code></dt><dd><p>
如果两个字符串中的每个字符都精确匹配,则返回
<code>t</code>. 符号也可以作为参数,在这种情况下,就是使用符号名来比较. 不管
<code>case-fold-search</code> 设置为何值,该函数都是区分大小写的.
</p>

<p>
这个函数等价于专门比较两个字符串的 <code>equal</code> 函数(参见
<a href="#org9fe4c9b">相等断言(Equality Predicates)</a>). 特别的地方是,两个字符串的文本属性也都会被忽略;
如果你想区分两个只在文本属性向不同的字符串,请使用 <code>equal-including-properties</code>
函数. 然而,与 <code>equal</code> 不同的是,如果参数不是字符串或符号, <code>string=</code> 就会发出错
误信号.
</p>
<pre class="example" id="org3440537">
	    (string= "abc" "abc")
		 ⇒ t
	    (string= "abc" "ABC")
		 ⇒ nil
	    (string= "ab" "ABC")
		 ⇒ nil
</pre>
<p>
由于技术原因,一个单字节字符串和一个多字节字符串在当且仅当它们有着相同的字符编
码序列且这些编码都是在 0-127(ASCII) 或 160-255(<code>eight-bit-graphic</code>) 范围内时才
是相等的. 但是,当一个单字节字符串被转换成多字节字符串时,所有编码位于 160-255
范围内的字符会被转换成更高编码的字符,而 ASCII 字符会保持不变.因此,一个单字节字
符串和它转换后的多字节字符串只有在当它全是 ASCII 字符时才会 <code>equal</code>. ,即使能够
出现在多字节文本中,但字符编码在 160-255 的字符在多字节文本中并不完全正确.因此,
一个单字节字符串和一个多字节字符串 <code>equal</code>,但不都是全 ASCII 字符的情况是一个技
术上的奇怪现象,很少或有 Emacs Lisp 程序员遇到这种问题. 参见
<a href="#org263a727">文本表示(Text Representations)</a>.
</p></dd>

<dt><code>(string-equal string1 string2)</code></dt><dd><code>string-equal</code> 就是 <code>string=</code> 的另一个名字.</dd>

<dt><code>(string-collate-equalp string1 string2 &amp;optional locale ignore-case)</code></dt><dd><p>
如果
string1 和 string2 的排序规则是相等的,则该函数返回 <code>t</code>. 排序规则不仅由 string1
和 string2 中的字符的字典顺序决定,还由这些字符之间的关系的深层规则决定. 通常来
讲,这个排序规则是由 Emacs 运行的 locale 环境和 Emacs 链接的标准 C 语言库决定的
<sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup>.
</p>

<p>
例如,在某些本地环境中,具有不同代码但含义相同的字符,比如带有不同重音的 Unicode
字符,是可能被视为相等的(这个例子我本地环境中是不等的):
</p>
<pre class="example" id="org2ad6b12">
	    (string-collate-equalp (string ?\uFF40) (string ?\u1FEF))
		 ⇒ t
</pre>

<p>
可选参数 locale 是一个字符串,用来重写你当前本地环境的排序标识符.其值取决于操作
系统; POSIX 系统上可以用 <code>"en_US.UTF-8"</code> , 而在 MS-Windows 系统上,可能是
<code>"enu_USA.1252"</code> .
</p>

<p>
如果 ignore-case 是非 <code>nil</code> 的,在进行比较之前,字符会全部转换成小写形式.
</p>

<p>
要在 MS-Windows 上模拟符合 Unicode 的排序规则,请将
<code>w32-collate-ignore-punctuation</code> 设置为一个非 <code>nil</code> 值,因为 MS-Windows 上的本
地环境字符集不能是 <code>"UTF-8"</code>
</p>

<p>
如果你的系统不支持本地环境,那这个函数就会表现得像 <code>string-equal</code> 一样.
</p>

<p>
请 <b>不要</b> 用这个函数来比较文件名的相等性,因为文件系统通常不遵循排序规则实现的
字符串的语言等效性.
</p></dd>

<dt><code>(string&lt;  string1 string2)</code></dt><dd><p>
这个函数一次比较一个字符来比较两个字符串. 它会
同时扫描两个字符串来找到第一对不匹配的对应字符. 如果这对字符中较少的字符是来自
string1, 那么 string 1 就是较小的,函数返回 <code>t</code>. 如果更少的字符来自于 string2
那么 string1 就是更大的,函数返回 <code>nil</code>. 如果两个字符串完全匹配,返回值就是 <code>nil</code>.
</p>

<p>
这对字符是根据它们的字符编码来比较的. 请注意,在 ASCII 字符集中,小写字母比它们
的大写字母的数值要高;数字和许多标点符号的数值比大写字母要低. 一个 ASCII 字符比
任何非 ASCII 字符要低;一个单字节非 ASCII 字符总是要比任意多字节非 ASCII 字符的
数值要低.(参见 <a href="#org263a727">文本表示(Text Representations)</a>).
</p>
<pre class="example" id="orgef92d27">
	    (string&lt; "abc" "abd")
		 ⇒ t (第一对不匹配的字符是 c 和 d, c 较小,来自第一个,所以返回 t)
	    (string&lt; "abd" "abc")
		 ⇒ nil (d 和 c , c 来自第二个string, 返回 nil)
	    (string&lt; "123" "abc")
		 ⇒ t (1 和 a, 1 较小,来自第一个,小于,返回 t)
</pre>

<p>
当字符串有不同长度,且他们匹配到了 string1 长度时,结果就是 <code>t</code>. 如果他们匹配到
了 string2 的长度,那结果就是 <code>nil</code>. 没有字符的字符串比任何其他字符串都要小:
</p>
<pre class="example" id="org2727692">
	    (string&lt; "" "abc")
		 ⇒ t
	    (string&lt; "ab" "abc")
		 ⇒ t
	    (string&lt; "abc" "")
		 ⇒ nil
	    (string&lt; "abc" "ab")
		 ⇒ nil
	    (string&lt; "" "")
		 ⇒ nil
</pre>
<p>
符号也可以作为其参数,这种情况下会比较符号的打印名(也就是符号的名称呗).
</p></dd>

<dt><code>(string-lessp string1 string2)</code></dt><dd><code>string-lessp</code> 是 <code>string&lt;</code> 的别名.</dd>

<dt><code>(string-greaterp string1 string2)</code></dt><dd>这个函数返回 string1 和 string2 按相反
顺序比较的结果,也就是说,它等价于 <code>(string-lessp string2 string1)</code>.</dd>

<dt><code>(string-collate-lessp string1 string2 &amp;optional locale ignore-case)</code></dt><dd><p>
如果
在排序规则上, string1 小于 string2 ,则该函数返回 <code>t</code>. 排序规则不仅由 string1
和 string2 中的字符的字典顺序决定,还由这些字符之间的关系的深层规则决定.通常来
讲,这个排序规则是由 Emacs 运行的 locale 环境决定的.
</p>

<p>
例如,标点符号和空白字符可能在排序中被忽略(参见 <a href="#org6f6c0f4">序列函数(Sequence Functions)</a>):
</p>
<pre class="example" id="orgd4f2b5f">
  (sort (list "11" "12" "1 1" "1 2" "1.1" "1.2") 'string-collate-lessp)
       ⇒ ("11" "1 1" "1.1" "12" "1 2" "1.2")
</pre>
<p>
这种行为是取决于系统的;例如, 在 Cygwin 上,不管本地环境如何, 标点符号和空白字符
都永远不会被忽略.
</p>

<p>
可选参数 locale 是一个字符串,用来重写你当前的用于排序的本地环境标识符设置.其值
也是取决于系统的; POSIX 系统上可以用 <code>"en_US.UTF-8"</code> , 而在 MS-Windows 系统上,
可能是 <code>"enu_USA.1252"</code> . <code>POSIX</code> 或 <code>C</code> 作为 locale 值,则会让
<code>string-collate-lessp</code> 表现得像 <code>string-lessp</code> 一样:
</p>
<pre class="example" id="org85d9d95">
  (sort (list "11" "12" "1 1" "1 2" "1.1" "1.2")
	(lambda (s1 s2) (string-collate-lessp s1 s2 "POSIX")))
       ⇒ ("1 1" "1 2" "1.1" "1.2" "11" "12")
</pre>

<p>
如果 ignore-case 是非 <code>nil</code> 值,字符会在比较前转换成小写形式.
</p>

<p>
要在 MS-Windows 上模拟符合 Unicode 的排序规则,请将
<code>w32-collate-ignore-punctuation</code> 设置为一个非 <code>nil</code> 值,因为 MS-Windows 上的本
地环境字符集不能是 <code>"UTF-8"</code>
</p>

<p>
如果你的系统不支持本地环境,那这个函数就会表现得像 <code>string-lessp</code> 一样.
</p></dd>

<dt><code>(string-version-lessp string1 string2)</code></dt><dd><p>
这个函数按字典顺序比较两个字符串,
只是它将数字的字符序列视为他们是基于10 的数字,然后比较这些数字. 所以,根据这个
断言,即使 <code>12</code> 按照字典顺序是比 <code>2</code> 小的,但 <code>foo2.png</code> 也比 <code>foo12.png</code> 要小.
</p>
<blockquote>
<p>
字典顺序就是字符顺序,0-9,a-z,A-Z 是从小到大的,字符 <code>12</code> 与字符 <code>2</code> 比较,因为
<code>12</code> 的第一个字符是1 所以字符 <code>12</code> 的字典顺序是要比 <code>2</code> 小的,但由于这个函数会
把数字序列当作数值比较,因此 2 会比 12 小.
</p>
</blockquote></dd>

<dt><code>(string-prefix-p string1 string2 &amp;optional ignore-case)</code></dt><dd>如果 string1 是
string2 的前缀(也就是 string2 是以 string1 开头的),则该函数返回非 <code>nil</code> 值.如
果可选参数 ignore-case 是非 <code>nil</code> 的, 则进行的比较会忽略大小写.</dd>

<dt><code>(string-suffix-p suffix string &amp;optional ignore-case)</code></dt><dd>如果 suffix 是
string 的后缀(string 以 suffix 结尾),则该函数返回一个非 <code>nil</code> 值.如果可选参数
ignore-case 是非 <code>nil</code> 的, 则进行的比较会忽略大小写.</dd>

<dt><code>(string-search needle haystack &amp;optional start-pos)</code></dt><dd>返回 haystack 中
needle 的第一个实例的位置,这两个参数都是字符串. 如果 start-pos 是非 <code>nil</code> 值,
则从 haystack 的 start-pos 处开始查找. 如果没找到匹配项,则返回 <code>nil</code>. 这个函数
在作比较时只考虑字符串中的字符,忽略文本属性. 匹配过程总是区分大小写的.</dd>

<dt>(no term)</dt><dd><p>
<code>(compare-strings string1 start1 end1 string2 start2 end2 &amp;optional
  ignore-case)</code> :: 这个函数用 string1 的特定部分去和 string2 的特定部分比较.
string1 的特定部分从索引 start1 (含) 开始到索引 end1 (不含) 结束; start1 为
<code>nil</code> 表示以字符串的开头开始,而 end1 为 <code>nil</code> 则表示以字符串的长度为结尾.同样
地, string2 的指定部分也是从索引 start2 (含) 到索引 end2 (不含).
</p>

<p>
字符串是通过他们的字符的数值进行比较的.例如, 如果 string1 的第一个不同的字符有
着一个较小的数值,那么 string1 就会被认定是比 string2 要小. 如果 ignore-case 是
非 <code>nil</code>, 在进行比较前,字符会使用当前缓冲区的 case-table (参见
<a href="#org50fbb35">Case Tables</a>)转换成大写. 单字节字符串会转换成多字节进行比较(参见
<a href="#org263a727">文本表示(Text Representations)</a>), 所以单字节字符串和其转换后的多字节形式总是被
视为相等的.
</p>

<p>
如果连个字符串的指定部分匹配,则返回值为 <code>t</code>, 否则,返回值就是一个整数,用来表示
有多少前导字符是匹配的,以及哪个字符串更短.返回值的绝对值是1加上两个字符串开头
的匹配的字符个数. 如果 string1(或其指定的部分)更短的话, 则返回值的符号就是负的.
</p></dd>

<dt><code>(string-distance string1 string2 &amp;optional bytecompare)</code></dt><dd><p>
这个函数返回源字
符串 string1 和目标字符串 string2 之间的 "Levenshtein distance"(Levenshtein 距
离). Levenshtein 距离就是将源字符串转换成目标字符串所需要的字符更改(删除,插入
或替换)的数量. 这是字符串之间的 "编辑距离" 的一种可能的定义.
</p>

<p>
字符串的字母大小写是计算在距离之内的,但是它们的文本属性不算. 如果可选参数
bytecompare 是非 <code>nil</code> 的, 那么函数会计算它们字节之间的距离,而不是字符的距离.按
字节比较使用的是字符在 Emaccs 中的内部表示,因此,对于包含有原始字节的多字节字符
串(参见<a href="#org263a727">文本表示(Text Representations)</a>),它可能会产生不确定的结果; 如果你需要使
用了原始字符的精确结果,请通过对字符串编码(参见 <a href="#org4ebd9de">显式编码(Explicit Encoding)</a> ),
让其成为单字节字符串
</p></dd>

<dt><code>(assoc-string key alist &amp;optional case-fold)</code></dt><dd>这个函数与 <code>assoc</code> 类似,但
key 必需是字符串或符号,并且比较是通过使用 <code>compare-strings</code> 进行的. 符号在比较
前会转换成字符串. 如果 case-fold 是非 <code>nil</code> 的, 那么在比较前, key 和 alist 中
的元素都会被转换成大写形式. 与 <code>assoc</code> 不同的是,这个函数可以匹配 alist 中是字
符串或符号的元素,而不是 cons cell. 特别的, alist 可以是一个字符串或符号的列表,
而不是一个真正的关联列表("alist") 参见 <a href="#orgaf2e615">关联表(Association Lists)</a> .</dd>
</dl>


<p>
对于比较缓冲区中文本的方式,也可以参阅 <a href="#org1889664">比较文本(Comparing Text)</a> 中的
<code>compare-buffer-substrings</code> 函数. 函数 <code>string-match</code>, 它使用正则表达式来匹配字
符串,可以用来做各种字符串匹配,参见 <a href="#org8dfde4e">正则搜索(Regexp Search)</a>.
</p>
</div>
</div>

<div id="outline-container-org5727e33" class="outline-4">
<h4 id="org5727e33"><span class="done DONE">DONE</span> 字符串转换(String Conversion)</h4>
<div class="outline-text-4" id="text-org5727e33">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-11-28 Tue 20:06]</span></span></li>
</ul>
<p>
字符串和字符的相互转换.
</p>

<p>
这一节描述用于在字符,字符串和整数之间转换的函数. <code>format</code> (参见
<a href="#org993d6e9">格式化字符串(Formatting Strings)</a> )和 <code>prin1-to-string</code> (参见
<a href="#orge0896d7">输出函数(Output Functions)</a>) 函数也可以将 Lisp 对象转换成字符串. <code>read-from-string</code>
(参见 <a href="#orgdd8af85">输入函数(Input Functions)</a>) 函数可以将一个 Lisp 对象的字符串表示转换成一个
对象. <code>string-to-myltibyte</code> 函数和 <code>string-to-unibyte</code> 函数可以转换字符串的文本
表示形式(参见 <a href="#orgfbaf65b">转换表示形式(Converting Representations)</a>).
</p>

<p>
关于生成文本字符和常规输入事件的函数(<code>single-key-description</code> 和
<code>text-char-description</code>), 请参见 <a href="#orgb14dd88">文档(Documentation)</a>.
这类函数主要是用来生成帮助消息的.
</p>

<dl class="org-dl">
<dt><code>(number-to-string number)</code></dt><dd><p>
这个函数返回由 number 的十进制打印表示形式组成
的字符串. 如果参数是负的,则返回的字符串值也会以负号作为开头.
</p>
<pre class="example" id="org0be3ccf">
  (number-to-string 256)
       ⇒ "256"
  (number-to-string -23)
       ⇒ "-23"
  (number-to-string -23.5)
       ⇒ "-23.5"
</pre>
<p>
<code>int-to-string</code> 是该函数的半废弃的别名.
</p>

<p>
另外,请参见 <a href="#org993d6e9">格式化字符串(Formatting Strings)</a> 中的 <code>format</code> 函数.
</p></dd>

<dt><code>(stirng-to-number string &amp;optional base)</code></dt><dd><p>
这个函数返回 string 中字符的数值.
如果 base 是非 <code>nil</code> 的,则 base 的值必需是 2 到 16(含)之间的整数,返回的整数值
会被转换成 base 进制. 如果 base 是 <code>nil</code> 则使用十进制. 浮点数的转换只在十进制
的情况下生效; Emacs 开发者并没有实现浮点数的其他进制的转换,因为那需要更大的工
作量而且并不是很有用处.
</p>

<p>
解析过程会跳过字符串开头的空格和制表符,然后以给定的进制尽可能多的读取 string
中可以作为数字的内容.(在某些系统中,该函数会跳过开头的其他空白字符,而不仅仅是空
格和制表符.) 如果 string 不能作为数字理解,那该函数就会返回一个 0 值.
</p>
<pre class="example" id="orgb2ec30b">
  (string-to-number "256")
       ⇒ 256
  (string-to-number "25 is a perfect square.")
       ⇒ 25
  (string-to-number "X256")
       ⇒ 0
  (string-to-number "-4.5")
       ⇒ -4.5
  (string-to-number "1e5")
       ⇒ 100000.0
</pre>
<p>
<code>string-to-number</code> 是该函数的一个废弃的别名.
</p></dd>

<dt><code>(char-to-string character)</code></dt><dd>这个函数返回一个包含有一个字符 character 的新
字符串. 该函数是半废弃的,因为函数 <code>string</code> 更通用. 参见
<a href="#orgd539f64">创建字符串(Creating Strings)</a>.</dd>

<dt><code>(string-to-char string)</code></dt><dd>这个函数返回 string 中的第一个字符.这个函数与
<code>(aref string 0)</code> 大致一样,只不过,如果 string 是空字符串,那么该函数会返回0.(当
字符串 string 的第一个字符是空字符串的时候,也会返回0,因为空字符串的 ASCII 编码
是0).如果这个函数看起来不是特别有用,将来可能会被取消.</dd>
</dl>


<p>
下面是一些字符串相关的转换函数:
</p>
<dl class="org-dl">
<dt><code>(concat)</code></dt><dd>这个函数将一个向量或列表转换成一个字符串. 参见
<a href="#orgd539f64">创建字符串(Creating Strings)</a>.</dd>
<dt><code>(vconcat)</code></dt><dd>这个函数间一个字符串转换成一个向量. 参见
<a href="#org714d4f3">向量函数(Vectors Functions)</a>.</dd>
<dt><code>(append)</code></dt><dd>这个函数将字符串转换成列表. 参见
<a href="#org2213f78">构建列表(Building Lists)</a>.</dd>
<dt><code>(byte-to-string)</code></dt><dd>这个函数将字符数据的一个字节转换成一个单字节字符串. 参
见 <a href="#orgfbaf65b">转换表示形式(Converting Representations)</a>.</dd>
</dl>
</div>
</div>

<div id="outline-container-org993d6e9" class="outline-4">
<h4 id="org993d6e9"><span class="done DONE">DONE</span> 格式化字符串(Formatting Strings)</h4>
<div class="outline-text-4" id="text-org993d6e9">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-04 Mon 17:55]</span></span></li>
</ul>
<p>
<code>format</code> : Emacs 中的 <code>printf</code> (C 语言的格式化输出/打印函数)
</p>

<p>
"格式化" 意味着通过在一个常量字符串的各个位置替换要计算的值来构造一个字符串. 这
个常量字符串控制着其他值的打印方式和它们出现的位置;因此它也被称为 "格式字符串".
</p>

<p>
格式化对计算要显示的消息来说通常都是很有用的.事实上, 函数 <code>message</code> 和 <code>error</code>
都提供了这里描述的相同格式化功能; 他们与 <code>format-message</code> 的不同仅仅在于它们使用
格式化结果的方式.
</p>

<dl class="org-dl">
<dt><code>(format string &amp;rest objects)</code></dt><dd><p>
这个函数返回一个字符串,该字符串等于用相应的
objects 的编码替换了格式规范后的 string. 参数 objects 是要被格式化的计算值.
</p>

<p>
string 中除了格式规范之外的字符,会直接被复制到输出结果中,也包括了它们的文本属
性(如果有的话).格式规范的文本属性则会复制给参数 objects 生成的字符串表示中.
</p>

<p>
输出的字符串不需要是新分配的字符串. 例如,如果, <code>x</code> 是一个字符串 <code>"foo"</code>, 表达
式 <code>(eq x (format x))</code> 以及 <code>(eq x (format "%s" x))</code> 都可能产生结果 <code>t</code>.
</p></dd>

<dt><code>(format-message string &amp;rest objects)</code></dt><dd><p>
这个函数与 <code>format</code> 类似,但是它会将
string 中的每个重读号 <code>`</code> 和撇号 <code>'</code> 都转换成 <code>text-quoting-style</code> 的值.
</p>

<p>
格式规范中的重度符号和撇号通常会被转换为一个匹配的弯曲引号,例如:
<code>"Missing `%s'"</code>  会被转换成 <code>"Missing ‘foo’"</code>. 关于如何影响或阻止这个转换,请
参见 <a href="#orgb8798d2">文本引用格式(Text Quoting Style)</a>.
</p></dd>
</dl>



<p>
一个格式规范就是以 <code>%</code> 开头的一个字符序列. 因此,如果 string 中有 <code>%d</code>, <code>format</code>
函数会使用一个要格式化的值(objects 中的一个参数)的打印表示来将其替换. 例如:
</p>
<pre class="example" id="org0718cd0">
(format "The value of fill-column is %d." fill-column)
     ⇒ "The value of fill-column is 72."
</pre>
<p>
因为 <code>format</code> 会将 <code>%</code> 字符解释为格式规范,因此,你永远不应该将一个任意的字符串作
为第一个参数.当这个字符串是由某些 Lisp 代码生成的时候尤其需要注意这一点.除非已知
字符串绝对不含任何 <code>%</code> 字符,才可以将 <code>"%s"</code> 作为第一个参数,字符串作为第二个参数:
</p>
<pre class="example" id="org3ea482e">
(format "%s" ARBITRARY-STRING)
</pre>
<p>
某些格式规范需要特定类型的值.如果你提供的值不符合要求,就会发出一个错误信号.
</p>

<p>
下面是有效的格式规范的表:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">格式规范</td>
<td class="org-left">用法</td>
</tr>

<tr>
<td class="org-left"><code>%s</code></td>
<td class="org-left">将该格式规范替换成 object 的打印表示,不带引号(也就是使用 <code>princ</code> 函数而不是 <code>prin1</code> 的打印结果参见 <a href="#orge0896d7">输出函数(Output Functions)</a>). 因此字符串只会打印他们的内容,不带 <code>"</code>, 符号不带 <code>\</code> 字符.如果 object 是一个字符串,其文本属性也会复制到输出结果中. 事实上 <code>%s</code> 自身的文本属性也会被复制,但是来自 object 的文本属性具有更高优先级.</td>
</tr>

<tr>
<td class="org-left"><code>%S</code></td>
<td class="org-left">将该格式规范替换成 object 的打印表示,带引号(使用 <code>prin1</code> 的打印结果,参见 <a href="#orge0896d7">输出函数(Output Functions)</a>). 因此,字符串会被 <code>"</code> 字符包围, 在有必要的地方,特殊字符的前面会出现 <code>\</code> 字符.</td>
</tr>

<tr>
<td class="org-left"><code>%o</code></td>
<td class="org-left">将该格式规范替换成一个整数的八进制表示.负整数会根据平台的不同进行格式化. object 也可以是一个要被格式化为整数的浮点数(去掉所有小数)</td>
</tr>

<tr>
<td class="org-left"><code>%x</code> 和 <code>%X</code></td>
<td class="org-left">将该格式规范替换成一个整数的十六进制表示,负整数会根据平台不同进行格式化. object 也可以是一个要被格式化为整数的浮点数(去掉所有小数)</td>
</tr>

<tr>
<td class="org-left"><code>%c</code></td>
<td class="org-left">将该格式规范替换成一个给定的字符.</td>
</tr>

<tr>
<td class="org-left"><code>%e</code></td>
<td class="org-left">将该格式规范替换成一个浮点数的指数表示形式</td>
</tr>

<tr>
<td class="org-left"><code>%f</code></td>
<td class="org-left">将该格式规范替换成一个浮点数的十进制小数点形式</td>
</tr>

<tr>
<td class="org-left"><code>%g</code></td>
<td class="org-left">将该格式规范替换成一个浮点数的表示形式,可以是十进制小数点表示法也可以是指数表示法.如果指数小于 -4 或是大于等于精度(默认为6),则会使用指数形式. 默认情况下,结果中小数部分结尾的零会被删除,而且小数点字符只会在小数点后面有数字时出现.</td>
</tr>

<tr>
<td class="org-left"><code>%%</code></td>
<td class="org-left">将该格式规范替换成一个单个字符 <code>%</code> . 这个格式规范的特殊之处在于它的唯一形式就是 <code>%%</code> ,而且它不会使用其他值作为替换,例如, <code>(format "%% %d" 30)</code> 会返回 <code>"% 30"</code></td>
</tr>
</tbody>
</table>

<p>
任意其他的格式规范字符都会导致一个 <code>Invalid format operation</code> 的错误.
</p>

<p>
下面是一些示例,假设使用的都是典型(默认)的 <code>text-quoting-style</code> 设置:
</p>
<pre class="example" id="orgb7c998c">
(format "The octal value of %d is %o,
         and the hex value is %x." 18 18 18)
     ⇒ "The octal value of 18 is 22,
         and the hex value is 12."

(format-message
 "The name of this buffer is ‘%s’." (buffer-name))
     ⇒ "The name of this buffer is ‘strings.texi’."

(format-message
 "The buffer object prints as `%s'." (current-buffer))
     ⇒ "The buffer object prints as ‘strings.texi’."
</pre>

<p>
默认情况下, 格式规范对应于 objects 中的连续值. 因此, string 中第一个格式规范会使
用 objects 中的第一个值,第二个格式规范使用第二个值,以此类推.任意额外的格式规范
(没有对应值的格式规范)都会导致错误. 任意额外要格式化的值(没有对应格式规范的值)都
会被忽略.
</p>

<p>
格式规范可以有 "字段编号",是一个跟在初始 <code>%</code> 后面的十进制数字,后面还跟上一个美元
符号 <code>$</code>. 这会让格式规范去转换给定的编号的参数,而不是下一个参数. 字段编号从 1 开
始. 格式规范中可以有字段编号,也可以有未编号的格式规范,但是不能同时都有,除了 <code>%%</code>
例外,它可以与编号的格式规范混合.
</p>
<pre class="example" id="org6a080fe">
(format "%2$s, %3$s, %%, %1$s" "x" "y" "z")
     ⇒ "y, z, %, x"
</pre>
<p>
在 <code>%</code> 和任意字段编号之后,你可以放置特定的 "标志字符".
</p>

<p>
标志 <code>+</code> 会在非负数前面插入一个加号,让它永远都会有符号. 一个空格字符作为标志字符
会在非负数前面插入一个空格.(不加标志字符的话,非负数就会从第一位开始.)这些标志在
保证负数和非负数使用相同的列数时非常有用.除了 <code>%d</code>, <code>%e</code>, <code>%f</code>, <code>%g</code> 之外的其他
格式规范都会忽略这两个标志字符,如果它们被同时使用了,则 <code>+</code> 优先.
</p>

<p>
<code>#</code> 标志指定一个候补,候补值取决于使用的格式规范. 对于 <code>%o</code>, 它会保证结果以 <code>0</code>
开头. 对于 <code>%x</code> 和 <code>%X</code>, 它在非0的结果前面加上前缀 <code>0x</code> 或 <code>0X</code>. 对于 <code>%e</code> 和
<code>%f</code>, <code>#</code> 标志意味着即使精度是0,也会在结果中加上小数点. 对于 <code>%g</code>, 它会一直保证
有小数点,并且会强制保留本该会被删除的结尾的0.
</p>

<p>
标志 <code>0</code> 会保证填充是由0组成而不是空格. 这个标志对于非数字的规范字符来说会被忽略,例
如 <code>%s</code>, <code>%S</code> 和 <code>%c</code>, 这些规范字符接受 <code>0</code> 标志,但是仍然会以空格作为填充.
</p>

<p>
标志 <code>-</code> 会让填充根据宽度(如果给定了宽度)插入到右边而不是左边. 如果 <code>-</code> 和 <code>0</code>
同时出现, <code>0</code> 标志会被忽略.
</p>
<pre class="example" id="orgcd10799">
(format "%1$06d is padded on the left with zeros" 123)
     ⇒ "000123 is padded on the left with zeros"

(format "'%-6d' is padded on the right" 123)
     ⇒ "'123   ' is padded on the right"

(format "The word '%-7s' actually has %d letters in it."
        "foo" (length "foo"))
     ⇒ "The word 'foo    ' actually has 3 letters in it."
</pre>

<p>
格式规范可以有 "宽度", 它是一个出现在任意字段编号和标志之后的十进制数.如果
object 的打印表示包含的字符比这个宽度少,那 <code>format</code> 就会将其用填充来扩展到该宽度.
由宽度引入的填充通常是由插入在左边的空格组成:
</p>
<pre class="example" id="org34daaec">
(format "%5d is padded on the left with spaces" 123)
     ⇒ "  123 is padded on the left with spaces"
</pre>

<p>
如果宽度值太小, <code>format</code> 不会截断 object 的打印表示. 因此,你可以使用宽度来指定两
列之间的最小空间而不用担心丢失数据.在下面两个例子中, <code>%7s</code> 指定最低宽度为 7. 在
第一个例子中, 插入到 <code>%7s</code> 位置的字符串只有 3 个字母,因此需要 4 个空格作为填充.
在第二个例子中,字符串 <code>"specification"</code> 有 13 个字母,但是也没有被截断:
</p>
<pre class="example" id="org8f0ccb8">
(format "The word '%7s' has %d letters in it."
        "foo" (length "foo"))
     ⇒ "The word '    foo' has 3 letters in it."
(format "The word '%7s' has %d letters in it."
        "specification" (length "specification"))
     ⇒ "The word 'specification' has 13 letters in it."
</pre>

<p>
所有的规格字符允许在字段编号后有一个可选的 "精度",标志和宽度. 精度是一个小数点后
跟一个数字字符串.对于浮点数的格式规格(<code>%e</code> 和 <code>%f</code> ), 精度指定了小数点后显示多少
位数字;如果小数点后没有数字,则小数点也会被省略. 对于 <code>%g</code> 来说,精度指定显示多少
位有效数字(有效数字是小数点前面的第一位非0数字到小数点后面最后一位非0数字). 如果
<code>%g</code> 的精度是0或没有指定,则会视为精度为1 (显示有1位有效数字). 对于 <code>%s</code> 和 <code>%S</code>
来说,精度就是将字符串截断到指定宽度,因此 <code>%.3s</code> 只会显示 object 的打印表示的前三
个字符. 对于其他的格式字符,精度的效果就是本地库函数 <code>printf</code> 产生的效果.
</p>

<p>
如果你计划在之后对格式化的字符串使用 <code>read</code> 函数来获得一份格式化的值的副本,请使
用能让 <code>read</code> 函数重新构造值的格式规范.要用这种可逆的方式格式化数字,你可以使用
<code>%s</code> 和 <code>%S</code>, 只需要格式整数,你也可以使用 <code>%d</code>, 只格式化非负数,你也可以使用
<code>#x%x</code> 和 <code>#0%0</code>, 其他的格式规范可能会有问题;例如, <code>%d</code> 和 <code>%g</code> 会错误地处理 NaN
值,并且可能丢失精度和类型,还有 <code>#x%x</code> 和 <code>#o%o</code> 会错误处理负整数. 参见
<a href="#orgdd8af85">输入函数(Input Functions)</a>.
</p>

<p>
这一小节描述的函数都接受一套混合的规格字符. 下一节描述的函数 <code>format-spec</code> 可以
接受自定义的规格字符,例如 <code>%a</code> 或 <code>%z</code>
</p>
</div>
</div>

<div id="outline-container-org489125c" class="outline-4">
<h4 id="org489125c"><span class="done DONE">DONE</span> 自定义格式字符串(Custom Format Strings)</h4>
<div class="outline-text-4" id="text-org489125c">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-04 Mon 20:42]</span></span></li>
</ul>
<p>
格式化自定义的 <code>format</code> 规格.
</p>

<p>
通过自定义格式控制值字符串来让用户和 Lisp 程序同样能控制是特定文本是如何生成的有
时也是非常有用的. 例如, 一个格式字符串可以控制如何显示某人的名字,姓氏和电子邮件
地址. 使用上一小节的 <code>format</code> 函数,格式化字符串可能像这样 <code>"%s %s &lt;%s&gt;"</code>. 然而这
种方法很快就变得不太明智,因为不清楚哪个规格字符对应哪个信息.
</p>

<p>
对于这样的例子,一个更方便的格式字符串可能像这样 <code>"%f %l &lt;%e&gt;"</code> ,这个字符串的每个
规格字符都带有语义信息,并且相对于其他规格字符,可以很容易的重新排列,这使得这种格
式化字符串更容易由用户定义.
</p>

<p>
这一节描述的函数 <code>format-spec</code> 的运行与 <code>format</code> 类似,但是它可以操作使用任意规格
字符的格式化控制字符串.
</p>

<dl class="org-dl">
<dt>(format-spec template spec-alist &amp;optional ignore-missing split)</dt><dd><p>
这个函数返
回一个由格式化字符串 templatge 生成的字符串,格式化规则由 spec-alist 指定,它是
一个 <code>(LETTER . REPLACEMENT)</code> 格式的关联列表(参见
 <a href="#orgaf2e615">关联表(Association Lists)</a>).在格式化结果字符串时, template 中的每一个
<code>%LETTER</code> 规格都会被 REPLACEMENT 替换.
</p>

<p>
template 中的普通字符(非格式规格字符),会被直接复制到输出中,也包括它们的文本属
性(如果有的话). 格式规格中的任意文本属性也会被复制到它们的替换者中(如果替换的
文本也有文本属性,那替换的文本的文本属性优先).
</p>

<p>
使用关联表来指定转换规则会导致一些有用的属性:
</p>
<ul class="org-ul">
<li>如果 spec-alist 包含着比 template 中的唯一规格字符更多的唯一 LETTER 键,那么
未使用的键会被忽略.</li>
<li>如果 spec-alist 中包含着多个有着相同 LETTER 的联系,那里列表的开始最近的一个
会被使用.</li>
<li>如果 template 包含着多个相同的规格字符,那么在 spec-alist 中找到的相同的
REPLACEMENT 会作为该字符的所有替换的基础.</li>
<li>template 中规格的顺序不需要与 spec-alist 中的联系的顺序相同.</li>
</ul>

<p>
可选参数 ignore-missing 表明如何处理在 spec-alist 中没有找到的对应的 template
中的规格字符. 如果是 <code>nil</code> 或是省略,那么函数会发出一个错误信号,如果值是
<code>ignore</code> ,那么这些格式规格会保留原样到输出结果中,包括它们的文本属性(如果有的话);
如果值是 <code>delete</code>, 这些格式化规格会从输出中移除;其他的任意非 <code>nil</code> 值都会当作
<code>ignore</code> 一样处理,但是 <code>%%</code> 也会保留原样输出到结果中.
</p>

<p>
如果可选参数 split 是非 <code>nil</code> 的,则 <code>format-spec</code> 会将结果拆分成一个字符串的列
表,而不是返回单个字符串,拆分是基于替换发生的位置进行的.例如:
</p>
<pre class="example" id="org4e888a0">
  (format-spec "foo %b bar" '((?b . "zot")) nil t)
       ⇒ ("foo " "zot" " bar")
</pre></dd>
</dl>


<p>
<code>format-spec</code> 接受的格式化规格的语法跟 <code>format</code> 的很相似,但不是完全相同. 在这两
个函数中,格式化字符串都是以 <code>%</code> 开头的字符序列而且都以字母表的字母结尾例如 <code>%s</code>.
</p>

<p>
与 <code>format</code>  将特定的含义分配给固定的规格字符集不同的是, <code>format-spec</code> 接受任意
的规格字符并且都做相同处理. 例如:
</p>
<pre class="example" id="org16d4d7c">
(setq my-site-info
      (list (cons ?s system-name)
            (cons ?t (symbol-name system-type))
            (cons ?c system-configuration)
            (cons ?v emacs-version)
            (cons ?e invocation-name)
            (cons ?p (number-to-string (emacs-pid)))
            (cons ?a user-mail-address)
            (cons ?n user-full-name)))

(format-spec "%e %v (%c)" my-site-info)
     ⇒ "emacs 27.1 (x86_64-pc-linux-gnu)"

(format-spec "%n &lt;%a&gt;" my-site-info)
     ⇒ "Emacs Developers &lt;emacs-devel@gnu.org&gt;"
</pre>

<p>
一个格式化规格可以在 <code>%</code> 后面包括下面的任意数量的标志字符来修改替换的某些细节:
</p>
<dl class="org-dl">
<dt><code>0</code></dt><dd>这个标志字符会让所有由宽度指定的填充都由 <code>0</code> 组成,而不是空格.</dd>
<dt><code>-</code></dt><dd>这个标志字符会让所有由宽度指定的填充都被插入到右边而不是左边.</dd>
<dt><code>&lt;</code></dt><dd>这个标志字符会截断替换的左边直到剩下的字符达到给定的宽度或精度(如果指定
了宽度和精度).</dd>
<dt><code>&gt;</code></dt><dd>这个标志字符会截断替换的右边直到剩下的字符达到给定的宽度或精度(如果指定
了宽度和精度).</dd>
<dt><code>^</code></dt><dd>这个标志字符会将替换的文本转换成大写形式(参见
<a href="#org6cc59f3">大小写转换(Case Conversion)</a> ).</dd>
<dt><code>_</code></dt><dd>这个标志会将替换的文本转换成小写形式(参见 <a href="#org6cc59f3">大小写转换(Case Conversion)</a>).</dd>
</dl>


<p>
使用矛盾的标志的结果是未定义的(例如,同时使用大写和小写标志)
</p>

<p>
和 <code>format</code> 一样,格式化规格可以包含一个宽度,是出现在任意标志后面的十进制数字,可
以包含精度,是出现在标志和宽度后的一个小数点后面加上一个十进制数字 .
</p>

<p>
如果替换的文本包含着比规格指定的宽度更少的字符,那么会在左边填充:
</p>
<pre class="example" id="orga6da682">
(format-spec "%8a is padded on the left with spaces"
             '((?a . "alpha")))
     ⇒ "   alpha is padded on the left with spaces"
</pre>

<p>
如果替换的文本包含比规格指定的精度更多的字符,那就会从右边开始截断:
</p>
<pre class="example" id="org0253f88">
(format-spec "%.2a is truncated on the right"
             '((?a . "alpha")))
     ⇒ "al is truncated on the right"
</pre>

<p>
下面是一个结合前面提到的几个功能的更复杂的例子:
</p>
<pre class="example" id="org2c44eba">
(setq my-battery-info
      (list (cons ?p "73")      ; Percentage
            (cons ?L "Battery") ; Status
            (cons ?t "2:23")    ; Remaining time
            (cons ?c "24330")   ; Capacity
            (cons ?r "10.6")))  ; Rate of discharge

(format-spec "%&gt;^-3L : %3p%% (%05t left)" my-battery-info)
     ⇒ "BAT :  73% (02:23 left)"

(format-spec "%&gt;^-3L : %3p%% (%05t left)"
             (cons (cons ?L "AC")
                   my-battery-info))
     ⇒ "AC  :  73% (02:23 left)"

</pre>

<p>
就像是这小节中的例子展示的一样, <code>format-spec</code> 通常用来有选择性地格式化各种各样不
同的信息.提供用户可定制的格式化字符串在程序中是很有用的,因为用户可以选择以任意规
则的语法进行格式化,并且可以以任意顺序仅对程序提供的可用信息的子集进行格式化.
</p>
</div>
</div>

<div id="outline-container-org6cc59f3" class="outline-4">
<h4 id="org6cc59f3"><span class="done DONE">DONE</span> 大小写转换(Case Conversion)</h4>
<div class="outline-text-4" id="text-org6cc59f3">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-05 Tue 12:05]</span></span></li>
</ul>
<p>
大小写转换函数.
</p>

<p>
字符的大小写函数可以改变字符串内容中单个字符的大小写形式. 这些函数通常只转换字母
表的字符(字母 A 到 Z, a 到 z, 以及非 ASCII 字符);其他的字符不会被改变.你可以通过
指定一个事例表(参见 <a href="#org50fbb35">Case Tables</a> )来指定一种不同的大小写转换映射.
</p>

<p>
这些函数不会修改作为参数传递给它们的字符串,而是返回一个新的字符串.
</p>

<p>
下面的例子中使用了 <code>X</code> 和 <code>x</code> 字符,他们的 ASCII 编码分别是 88 和 120.
</p>

<dl class="org-dl">
<dt><code>(doncase string-or-char)</code></dt><dd><p>
这个函数会将 string-or-char (应该是一个字符或字
符串) 转换成小写. 当 string-or-char 是一个字符串时,这个函数会返回一个新的字符
串,参数中的每个字母都会被转换成小写形式. 当 string-or-char 是一个字母时,这个函
数会返回该字符相应的小写形式字符(以整数形式返回); 如果最初的字符是小写形式,或
不是一个字母,那返回值就等于最初的字符.
</p>
<pre class="example" id="org6dd3ced">
  (downcase "The cat in the hat")
       ⇒ "the cat in the hat"

  (downcase ?X)
       ⇒ 120
</pre></dd>

<dt><code>(upcase string-or-char)</code></dt><dd><p>
这个函数将 string-or-char 转换乘大写形式.
</p>

<p>
当 string-or-char 是一个字符串时,这个函数返回一个新的字符串,参数中每个小写形式
的字符都会转换成大写形式. 当 string-or-char 是一个字符时,这个函数会返回字符的
相应的大写字符(以整数形式);如果最初的字母是大写形式,或者不是一个字母,返回值就
等于最初的字符.
</p>
<pre class="example" id="org95c7283">
  (upcase "The cat in the hat")
       ⇒ "THE CAT IN THE HAT"

  (upcase ?x)
       ⇒ 88
</pre></dd>

<dt><code>(capitalize string-or-char)</code></dt><dd><p>
这个函数会将字符串或字母的首字母大写. 如果
string-or-char 是一个字符串,该函数返回一个新的字符串,其内容是 string-or-char
的副本,且每个单词都被首字母大写化了. 这意味着每个单词的第一个字符会被转换成大
写,剩下的则会转换成小写形式.
</p>

<p>
一个单词的定义就是任意连续字符的序列,这些字符是当前的语法表中分配给单词构成语
法类的字符 (参见 <a href="#org1658a25">语法类表(Syntax Class Table)</a>).
</p>

<p>
当 string-or-char 是一个字符时,这个函数与 <code>upcase</code> 做一样的事情.
</p>
<pre class="example" id="org0d331b5">
  (capitalize "The cat in the hat")
       ⇒ "The Cat In The Hat"

  (capitalize "THE 77TH-HATTED CAT")
       ⇒ "The 77th-Hatted Cat"

  (capitalize ?x)
       ⇒ 88
</pre></dd>

<dt>(upcase-initials string-or-char)</dt><dd><p>
如果 string-or-char 是一个字符串,这个函数
会将 string-or-char 中单词的首字母大写,但不改变首字母之外的字母. 它会返回一个
新的字符串,其内容是 string-or-char 的副本,在这个副本中,每个单词的首字母被转换
成了大写形式.
</p>

<p>
一个单词的定义就是任意连续字符的序列,这些字符是当前的语法表中分配给单词构成语
法类的字符 (参见 <a href="#org1658a25">语法类表(Syntax Class Table)</a>).
</p>

<p>
当传递给 <code>upcase-initials</code> 的参数是一个字符时, <code>upcase-initials</code> 与 <code>upcase</code>
产生一样的结果.
</p>
<pre class="example" id="org1463141">
  (upcase-initials "The CAT in the hAt")
       ⇒ "The CAT In The HAt"
</pre></dd>
</dl>


<p>
请注意,大小写转换不是代码点的一对一映射,而且转换结果的长度可能与原参数有所不同.进
一步讲,因为传递一个字符会强制返回的类型是一个字符,函数不能正确处理一个单字符的字
符串,结果可能会有所不同.例如:
</p>
<pre class="example" id="org735f200">
(upcase "ﬁ")  ; note: single character, ligature "fi"
     ⇒ "FI"  ; 返回的是一个
(upcase ?ﬁ)
     ⇒ 64257  ; i.e. ?ﬁ
</pre>
<p>
要避免这种事发生,在传递给大小写转换函数作为参数之前,字符必须先使用 <code>string</code> 函数
转换成字符串, 当然,结果的长度就无法预测了.
</p>

<p>
这种特殊的大小写转换的映射是来自于 <code>special-uppercase</code>, <code>special-lowercase</code> 和
<code>special-titlecase</code> 函数,参见 <a href="#org52ed95a">字符属性(Character Properties)</a>.
</p>

<p>
关于比较字符串的函数,请参见 <a href="#org3bcdb05">文本比较(Text Comparison)</a>; 它们中有些忽视大小写的差
别,或是可以选择性的忽略大小写的差别.
</p>
</div>
</div>
<div id="outline-container-org50fbb35" class="outline-4">
<h4 id="org50fbb35"><span class="done DONE">DONE</span> Case Tables</h4>
<div class="outline-text-4" id="text-org50fbb35">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-05 Tue 13:08]</span></span></li>
</ul>
<p>
自定义大小写转换.
</p>

<p>
你可以通过设置一个特殊的 "case table" 来自定义大小写转换.
</p>

<p>
case table 制定了大写形式和小写形式字母之间的映射.它同时影响着 Lisp 对象的大小写
转换函数(上一小节)以及那些应用到缓冲区文本的转换函数(参见
<a href="#orgc009e1c">大小写转换(Case Changes)</a> ). 每个缓冲区都有一个 case table; 还有一个标准 case
table, 用来初始化新缓冲区的 case table.
</p>

<p>
一个 case table 就是一个字符表(参见 <a href="#org74ce9c3">字符表(Char-Tables)</a>), 其子类型是
<code>case-table</code>. 这个字符表将每个字符映射到相应的小写形式字符. 它有三个额外插槽,用
来保存相关表格:
</p>
<dl class="org-dl">
<dt>UPCASE</dt><dd>大写表将每个字符映射到相应的大写形式字符.</dd>
<dt>CANONICALIZE</dt><dd>规范化表将所有与大小写相关的字符集映射到该集的特定成员中.</dd>
<dt>EQUIVALENCES</dt><dd>等价表将与大小写相关的字符集中的每一个都映射到该字符集的下一个
字符.</dd>
</dl>


<p>
在简单的例子中,你需要做的仅仅是指定到小写形式的映射,上面三个相关的表格会自动从该
映射中计算出来.
</p>

<p>
对于有些语言来说,大写和小写字母不是一一对应的.可能会有两种不同的小写形式字母与相
同的大写形式等价.在这些例子中,你需要同时为小写形式和大写形式指定映射.
</p>

<p>
额外的表格 CANONICALIZE 将每个字符映射到一个标准的等价; 任意两个与大小写转换相关
的字符有着相同的标准等价字符. 例如, 因为 <code>a</code> 和 <code>A</code> 与大小写转换相关,他们应该有
着相同的标准等价字符(应该是都用 <code>a</code> 作为标准等价字符或是都用 <code>A</code> 作为标准等价字
符).
</p>

<p>
额外的表格 EQUIVALENCES 是一个循环交换每个等价类(具有相同标准等价的字符)的映
射.(对于普通的 ASCII 字符, 它会将 <code>a</code> 映射到 <code>A</code>, 将 <code>A</code> 映射到 <code>a</code>, 对每组等价
字符都是如此.)
</p>

<p>
当构造一个 case table 时,你可以为 CANONICALIZE 提供一个 <code>nil</code> 值; 那么 Emacs 就
会根据小写和大写的映射来填充这个插槽. 你也可以为 EQUIVALENCES 提供一个 <code>nil</code> 值;
那么 Emacs 就会根据 CANONICALIZE 来填充这个插槽. 不要试图在没有指定 CANONICALIZE
的情况下去指定 EQUIVALENCES.
</p>

<p>
下面是一些 case tables 相关的函数:
</p>
<dl class="org-dl">
<dt><code>(case-table-p object)</code></dt><dd>如果 object 是一个有效的 case table, 这个断言会返回
非 <code>nil</code> 值.</dd>
<dt><code>(set-standard-case-table table)</code></dt><dd>这个函数将 table 设置成标准的 case
table, 以便其能在后续创建的任意缓冲区中使用.</dd>
<dt><code>(standard-case-table)</code></dt><dd>这个函数返回标准的 case table.</dd>
<dt><code>(current-case-table)</code></dt><dd>这个函数返回当前缓冲区的 case table.</dd>
<dt><code>(set-case-table table)</code></dt><dd>这个函数将当前缓冲区的 case table 设置为参数 table.</dd>
<dt>宏 <code>(with-case-table table body)</code></dt><dd><code>wit-case-table</code> 宏保存当前的 case table
然后将参数 table 设置为当前的case table, 然后执行 body 里的表达式,最后恢复原来
的 case table. 返回值是 body 的最后一个表达式的值. 即使是通过 <code>throw</code> 或错误异
常退出的情况下(参见 <a href="#org61d300d">非局部退出(Nonlocal Exits)</a>), case table 也会恢复到原来.</dd>
</dl>


<p>
有些语言环境会修改 ASCII 字符的大小写转换;例如在 Turkish 语言环境下, ASCII 字符
I 是 Turkish 的无点i(<code>ı</code>)的小写形式. 这可能会干扰那些需要普通的 ASCII 大小写转换
的代码,例如, 基于 ASCII 的网络端口的实现. 在这种情况下,可以结合变量
<code>ASCII-CASE-TABLE</code> 使用 <code>wit-case-table</code> , 变量 <code>ASCII-CASE-TABLE</code> 储存着 ASCII
字符集的未经修改的 case table.
</p>

<dl class="org-dl">
<dt>变量 <code>ascii-case-table</code></dt><dd>ASCII 字符集的 case table. 其在任何语言环境设置下都
不应该被修改.</dd>
</dl>


<p>
下面三个函数对于定义了非 ASCII 字符集的包来说是很方便的子程序. 它们会修改指定的
case table CASE-TABLE; 它们也会修改标准的语法表. 参见 <a href="#org78c3e54">语法表(Syntax Tables)</a>. 通
常来讲,你会使用这些函数来修改标准的 case table.
</p>

<dl class="org-dl">
<dt><code>(set-case-syntax-pair UC LC CASE-TABLE)</code></dt><dd>这个函数指定一对相应的字母,一个是
大写形式,一个是小写形式.</dd>
<dt><code>(set-case-syntax-delims L R CASE-TABLE)</code></dt><dd>这个函数让字符 L 和字符 R 成为一
对匹配的大小写恒定的分隔符.</dd>
<dt><code>(set-case-syntax CHAR SYNTAX CASE-TABLE)</code></dt><dd>这个函数让 CHAR 大小写恒定, 使用
语法 SYNTAX.</dd>
<dt><code>命令: describe-buffer-case-table</code></dt><dd>这个命令显示当前缓冲区的 case table 的内
容描述.</dd>
</dl>
</div>
</div>
</div>


<div id="outline-container-orgaeae923" class="outline-3">
<h3 id="orgaeae923"><span class="done DONE">DONE</span> 列表(Lists)</h3>
<div class="outline-text-3" id="text-orgaeae923">
<p>
列表, cons cell 和相关函数.
</p>

<p>
一个"列表" 表示的是一个0元素或多个元素的序列(元素可以是任意 Lisp 对象). 列表和向
量之间的重要区别是两个或多个列表可以共享它们的结构; 此外,你可以不用复制整个列表
就在列表中插入或删除元素.
</p>
</div>

<div id="outline-container-org0f39bb9" class="outline-4">
<h4 id="org0f39bb9"><span class="done DONE">DONE</span> Cons Cells</h4>
<div class="outline-text-4" id="text-org0f39bb9">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-05 Tue 18:11]</span></span></li>
</ul>
<p>
cons cell 是如何构成列表的.
</p>


<p>
Lisp 中的列表不是一个原始数据类型;他们是由"构造单元"(参见
<a href="#org31f8654">Construction of Cell 类型(Cons Cell Type)</a>)建立的. 一个 cons cell 是一个表示有序
对的数据对象. 也就是说,它有两个插槽,每个插槽 "储存"或"指向" 某个 Lisp 对象. 一个
插槽被叫做 CAR, 另一个叫做 CDR. (命名是根据历史原因得来的, 参见
<a href="#org31f8654">Construction of Cell 类型(Cons Cell Type)</a> ) CDR 的发音是 "could-er"
</p>

<p>
我们说 "这个 cons cell 的 CAR 是" 的意思是 CAR 插槽当前储存的对象,对于 CDR 也是
一样的.
</p>

<p>
一个列表是一系列的 cons cell 链接在一起,因此,每个 cell 都指向下一个 cell. 列表的
每个元素都有(是)一个 cons cell. 根据惯例, cons cell 的 CAR 插槽储存的是列表的元
素, CDR 插槽用来链接列表(这种 CAR 和 CDR 之间的不对称完全是出于惯例原因; 在 cons
cell 的层面上, CAR 和 CDR 有着相似的特性). 因此,列表中每个 cons cell 的 CDR 插槽
指向后面的 cons cell.
</p>

<p>
同样是出于惯例,列表中最后一个 cons cell 的 CDR 是 <code>nil</code>. 我们把这种以 <code>nil</code> 结尾
的结构叫做 "正确列表" <sup><a id="fnr.4" class="footref" href="#fn.4" role="doc-backlink">4</a></sup>. 在 Emacs Lisp 中, <code>nil</code> 符号既是一个符号也是一个没有元素的
列表. 为了方便, <code>nil</code> 符号被认为是一个 CDR 和 CAR 都是 <code>nil</code> 的列表.
</p>

<p>
因此, 正确列表的 CDR 总是一个正确列表. 一个非空的正确列表的 CDR 是一个包含有除了
第一个元素之外的所有元素的正确列表.
</p>

<p>
如果一个列表的最后一个 cons cell 的 CDR 是非 <code>nil</code> 值, 我们称这种结构为一个
"点列表"(dotted list), 因为其打印表示会使用点对表示法(参见
<a href="#orge3c05bd">点对表示法(Dotted Pair Notation)</a>). 还有一种其他的可能性: 某些 cons cell 的 CDR
会打印为一个该列表中前面的 cons cell. 我们称该结构为 "循环列表".
</p>

<p>
对于某些用途,列表是何种类型都不重要.如果一个程序不会查询到列表的足够深度,来查看
列表的最后一个 cons cell 的 CDR ,那就没有关系. 然而,有些操作列表的函数要求使用 "
正确列表"而且如果给定的是 "点列表"(dotted list) 就会发出错误信号.如果给定的是一
个 "循环列表",那么大部分试图查找到一个列表的结尾的函数会进入一个无限循环.
</p>

<p>
因为大部分的 cons cell 都是用作列表的一部分,所以我们把任何由 cons cell 构成的结
构称为 "列表结构"
</p>
</div>
</div>

<div id="outline-container-org622036f" class="outline-4">
<h4 id="org622036f"><span class="done DONE">DONE</span> 列表相关的断言(List-related Predicates)</h4>
<div class="outline-text-4" id="text-org622036f">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-05 Tue 18:48]</span></span></li>
</ul>
<p>
对象是否为列表?比较两个列表.
</p>

<p>
下面这些断言用来测试 Lisp 对象是否为原子(atom), cons cell 或列表又或是可以分辨的
对象 <code>nil</code>.(其中的许多断言可以由其他断言来定义,但是它们使用的频率太高了,因此值得
单独作为断言函数.)
</p>

<dl class="org-dl">
<dt><code>(consp object)</code></dt><dd>如果 object 是一个 cons cell, 则返回 <code>t</code> 否则,返回
<code>nil</code>. 尽管 <code>nil</code> <b>是</b> 一个列表,但它不是一个 cons cell.</dd>
<dt><code>(atom object)</code></dt><dd><p>
如果 object 是一个原子,则返回 <code>t</code>, 否则,返回 <code>nil</code>. 除了
cons cell 之外的所有对象都是原子. <code>nil</code> 符号也是一个原子,同时它也是一个列表,这
是唯一一个既是原子也是列表的 Lisp 对象.
</p>
<pre class="example" id="orgc2147b4">
  (atom OBJECT) ≡ (not (consp OBJECT))
</pre></dd>
<dt><code>(listp object)</code></dt><dd><p>
如果 object 是一个 cons cell 或 <code>nil</code> ,这个函数返回 <code>t</code>,
否则,返回 <code>nil</code>.
</p>

<pre class="example" id="org6453918">
  (listp '(1))
       ⇒ t
  (listp '())
       ⇒ t
</pre></dd>
<dt><code>(nlistp object)</code></dt><dd><p>
这个函数与 <code>(listp)</code> 刚好相反,如果 object 不是一个列表,则
返回 <code>t</code>, 反之,返回 <code>nil</code>
</p>
<pre class="example" id="org64d89e3">
          (listp OBJECT) ≡ (not (nlistp OBJECT))
</pre></dd>
<dt><code>(null object)</code></dt><dd><p>
如果 object 是 <code>nil</code> 则该函数返回 <code>t</code>, 否则,返回 <code>nil</code>. 这
个函数与 <code>not</code> 函数相同,但是为了清楚起见, 当 object 被认为是列表时,我们使用
<code>null</code>, 当其被认为是一个真值时,我们使用 <code>not</code> (<code>not</code> 参见
 <a href="#org95c036a">组合条件(Combining Conditions)</a> )
</p>
<pre class="example" id="org521fb33">
   (null '(1))
	⇒ nil
   (null '())
	⇒ t
</pre></dd>
<dt><code>(proper-list-p object)</code></dt><dd><p>
如果 object 是一个正确列表,那么这个函数返回 object
的长度. 否则,返回 <code>nil</code> (参见 <a href="#org0f39bb9">Cons Cells</a>). 除了要满足 <code>listp</code> 之外,这个正确列
表也不是循环列表或点列表.
</p>
<pre class="example" id="orgae22401">
  (proper-list-p '(a b c))      ; 正确列表 (a . (b . (c . nil)))
      ⇒ 3
  (proper-list-p '(a b . c))    ; 点列表 (a . (b . c))
      ⇒ nil
</pre></dd>
</dl>
</div>
</div>

<div id="outline-container-orgf87bd69" class="outline-4">
<h4 id="orgf87bd69"><span class="done DONE">DONE</span> 列表元素(List Elements)</h4>
<div class="outline-text-4" id="text-orgf87bd69">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-05 Tue 19:41]</span></span></li>
</ul>
<p>
提取一个列表的元素.
</p>

<dl class="org-dl">
<dt><code>(car CONS-CELL)</code></dt><dd><p>
这个函数返回cons cell CONS-CELL 的第一个插槽指向的值. 换
句话说,它返回的是 CONS-CELL 的 CAR.
</p>

<p>
作为一个特例, 如果 CONS-CELL 是 <code>nil</code> , 这个函数的返回值也是 <code>nil</code>. 因此,任意
的列表都是有效参数. 如果参数不是一个 cons cell 或不是 <code>nil</code> 那么就会发出错误信
号.
</p>
<pre class="example" id="orga468270">
  (car '(a b c))    ; (a . (b . (c . nil)))
       ⇒ a
  (car '())         ; (nil . nil)
       ⇒ nil
</pre></dd>

<dt><code>(cdr CONS-CELL)</code> </dt><dd><p>
这个函数返回 cons cell CONS-CELL 的第二个插槽指向的值,换
句话说,它返回的是 CONS-CELL 的 CDR.
</p>

<p>
作为一个特例,如果 CONS-CELL 是 <code>nil</code>, 这个函数返回 <code>nil</code>, 因此任意的列表都是有
效的参数. 如果参数不是一个 cons cell 或不是 <code>nil</code> 那么就会发出错误信
号.
</p>
<pre class="example" id="org8070d0f">
  (cdr '(a b c))    ; (a . (b . (c . nil)))
       ⇒ (b c)
  (cdr '())         ; (nil . nil)
       ⇒ nil
</pre></dd>

<dt><code>(car-safe OBJECT)</code></dt><dd><p>
这个函数让你能取出一个 cons cell 的 CAR 且避免其他数据
类型的错误. 如果 OBJECT 是一个 cons cell ,它会返回 OBJECT 的 CAR, 否则,返回
<code>nil</code>. 这和 <code>car</code> 是不同的, 如果 object 不是一个列表, <code>car</code> 会发出一个错误信号.
</p>
<pre class="example" id="orga6c417f">
  (car-safe OBJECT)
  ≡
  (let ((x OBJECT))
    (if (consp x)
	(car x)
      nil))
</pre></dd>

<dt><code>(cdr-safe OBJECT)</code></dt><dd><p>
这个函数让你能取出一个 cons cell 的 CDR 且避免其他数据
类型的错误.如果 OBJECT 是一个 cons cell, 则返回 OBJECT 的 CDR, 否则返回
<code>nil</code>. 这和 <code>cdr</code> 是不同的, 如果 object 不是一个列表, <code>cdr</code> 会发出一个错误信号.
</p>
<pre class="example" id="org242e780">
  (cdr-safe OBJECT)
  ≡
  (let ((x OBJECT))
    (if (consp x)
	(cdr x)
      nil))
</pre></dd>

<dt>宏 <code>(pop LISTNAME)</code></dt><dd><p>
这个宏提供了一个方便的方式来检查一个列表的 CAR, 并将其
一次性从列表中删除. 它操作的是储存在 LISTNAME 中的列表.它会从列表中删除第一个
元素,将第一个元素的 CDR 保存到 LISTNAME, 然后返回被删除的元素.
</p>

<p>
一个最简单的例子, LISTNAME 是一个未引用的命名一个列表的符号; 在这种情况下,该宏
等价于 <code>(prog1 (car listname) (setq listname (cdr lsitname)))</code>.
</p>
<pre class="example" id="org30e2267">
  x
       ⇒ (a b c)
  (pop x)
       ⇒ a
  x
       ⇒ (b c)
</pre>
<p>
更一般的说, LISTNAME 可以是一个广义变量.这种情况下, 这个宏会使用 <code>setf</code> 来将数
据保存到 LISTNAME. 参见 <a href="#org728a322">广义变量(Generalized Variables)</a>.
</p>

<p>
对于向列表中添加元素的 <code>push</code> 宏,请参见 <a href="#orgfff3f75">列表变量(List Variables)</a>.
</p></dd>

<dt><code>(nth N LIST)</code></dt><dd><p>
这个函数返回 LIST 的第 N 个元素. 元素从 0 开始编号,因此一个
LIST 的 CAR 的元素编号是 0. 如果 LIST 的长度是 N 或更小,那么返回值就是 <code>nil</code>.
</p>
<pre class="example" id="orgd77906f">
  (nth 2 '(1 2 3 4))
       ⇒ 3
  (nth 10 '(1 2 3 4))
       ⇒ nil

  (nth n x) ≡ (car (nthcdr n x))
</pre></dd>

<dt><code>(nthcdr N LIST)</code></dt><dd><p>
这个函数返回 LIST 的第 N 个 CDR. 换句话说,它跳过列表的前
N 个链接并返回后面的.
</p>

<p>
如果 N 是 0, <code>nthcdr</code> 返回整个列表. 如果 LIST 的长度是 N 或小于 N, <code>nthcdr</code> 返
回 <code>nil</code>.
</p>
<pre class="example" id="orgab22b7d">
  (nthcdr 1 '(1 2 3 4))
       ⇒ (2 3 4)
  (nthcdr 10 '(1 2 3 4))
       ⇒ nil
  (nthcdr 0 '(1 2 3 4))
       ⇒ (1 2 3 4)
</pre></dd>

<dt><code>(last LIST &amp;optional N)</code></dt><dd>这个函数返回 LIST 的最后一个链接. 这个链接的 CAR
是列表的最后一个元素. 如果 LIST 是空的, 那么就会返回 <code>nil</code>. 如果 N 是非 <code>nil</code>
的,那么会返回第 N 到最后的链接,如果 N 比 LIST 的长度还大,则会返回整个 LIST.</dd>

<dt><code>(safe-length LIST)</code></dt><dd><p>
这个函数返回 LIST 的长度,不会有报错或无限循环的风险.
它通常返回列表中不同的 cons cell 的数量. 然而，对于循环列表来说,该值只是一个上
限,它往往太大了.
</p>

<p>
如果 LIST 不是 <code>nil</code> 或 cons cell, 则 <code>sefe-length</code> 返回 0.
</p></dd>
</dl>


<p>
当你不用担心列表是循环的时候,计算列表的长度最常用的方法是使用 <code>length</code> 函数. 参
见 <a href="#org6f6c0f4">序列函数(Sequence Functions)</a>.
</p>

<dl class="org-dl">
<dt><code>(caar CONS-CELL)</code></dt><dd>等价于 <code>(car (car CONS-CELL))</code>.</dd>
<dt><code>(cadr CONS-CELL)</code></dt><dd>等价于 <code>(car (cdr CONS-CELL))</code> 或 <code>(nth 1 CONS-CELL)</code></dd>
<dt><code>(cdar CONS-CELL)</code></dt><dd>等价于 <code>(cdr (car CONS-CELL))</code></dd>
<dt><code>(cddr CONS-CELL)</code></dt><dd>等价于 <code>(cdr (cdr CONS-CELL))</code> 或 <code>(nthcdr 2 CONS-CELL)</code></dd>
</dl>


<p>
除了上面的函数之外,还有 24 个 <code>cdr</code> 和 <code>car</code> 的组合定义为 <code>cXXXr</code> 和 <code>cXXXXr</code>,
这里的每个 <code>X</code> 都是 <code>a</code> 或 <code>d</code>. <code>cadr</code> , <code>caddr</code> 和 <code>cadddr</code> 分别挑出列表的第二
个,第三个和第四个元素. <code>cl-lib</code> 提供了相同的功能 <code>cl-second</code>, <code>cl-third</code>,
<code>cl-fourth</code> 参见 <a href="https://www.gnu.org/software/emacs/manual/html_mono/cl.html#List-Functions">cl#List Functions</a>.
</p>

<dl class="org-dl">
<dt><code>(butlast X &amp;optional N)</code></dt><dd>这个函数返回一个列表,返回的列表是原列表删除了最后
一个元素或最后 N 个元素的剩余部分. 如果 N 比 0 大,该函数会生成列表 X 的副本以
便不会损毁原来的列表 X. 一般来讲, <code>(append (butlast X N) (last X N))</code> 返回的列
表等于 X.</dd>
<dt><code>(nbutlast X &amp;optional N)</code></dt><dd>这是 <code>butlast</code> 的另一个版本,它的工作方式是破坏性
地修改相应元素的 CDR 而不是生成一个副本后修改副本.</dd>
</dl>
</div>
</div>

<div id="outline-container-org2213f78" class="outline-4">
<h4 id="org2213f78"><span class="done DONE">DONE</span> 构建列表(Building Lists)</h4>
<div class="outline-text-4" id="text-org2213f78">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-06 Wed 19:36]</span></span></li>
</ul>
<p>
创建列表结构.
</p>

<p>
许多函数都能构建列表,因为列表位于 Lisp 的核心位置.
</p>

<p>
<code>cons</code> 是最基础的列表构建函数;然而,有意思的事,在 Emacs 的源代码中 <code>list</code> 的使用
次数大于 <code>cons</code>
</p>

<dl class="org-dl">
<dt><code>(cons OBJECT1 OBJECT2)</code></dt><dd><p>
这个函数是最基本的构造一个新列表结构的函数. 它会创
建一个新的 cons cell, 让 OBJECT1 成为 CAR, OBJECT2 成为 CDR. 然后它会返回这个
新的 cons cell. 参数 object1 和 object2 可以是任意 Lisp 对象, 但是通常来说
object2 会是一个列表.
</p>

<pre class="example" id="org14283ef">
  (cons 1 '(2))
       ⇒ (1 2)
  (cons 1 '())
       ⇒ (1)
  (cons 1 2)
       ⇒ (1 . 2)
</pre>
<p>
<code>cons</code> 通常用来在一个列表前面添加一个新的元素. 这种行为被称作 "consing the
element onto the list".
<sup><a id="fnr.5" class="footref" href="#fn.5" role="doc-backlink">5</a></sup> 例如:
</p>
<pre class="example" id="org93805a4">
          (setq list (cons newelt list))
</pre>
<p>
请注意,这个例子里的变量命名 <code>list</code> 与下面描述的函数命名 <code>list</code> 没有冲突; 任何
符号都可以兼用.
</p></dd>

<dt><code>(list &amp;rest objects)</code></dt><dd><p>
这个函数创建一个以 objects 作为元素的列表. 结果返回
的列表总是以 <code>nil</code> 为终结点.如果没有给定任何 objects 则返回一个空列表:
</p>
<pre class="example" id="orga627f01">
  (list 1 2 3 4 5)
       ⇒ (1 2 3 4 5)
  (list 1 2 '(3 4 5) 'foo)
       ⇒ (1 2 (3 4 5) foo)
  (list)
       ⇒ nil
</pre></dd>

<dt><code>(make-list length object)</code></dt><dd><p>
这个函数创建一个具有 length 个元素的列表,这个列
表中的每个元素都是 object. 可以比较以下 <code>make-string</code> (参见
<a href="#orgd539f64">创建字符串(Creating Strings)</a>)和 <code>make-list</code>.
</p>
<pre class="example" id="org63d7978">
  (make-list 3 'pigs)
       ⇒ (pigs pigs pigs)
  (make-list 0 'pigs)
       ⇒ nil
  (setq l (make-list 3 '(a b)))
       ⇒ ((a b) (a b) (a b))
  (eq (car l) (cadr l))
       ⇒ t
</pre></dd>

<dt><code>(append &amp;rest sequences)</code></dt><dd><p>
这个函数返回一个包含 sequences 中所有元素的列表.
sequences 可以是列表,向量,布尔向量或字符串,但最后一个元素通常是一个列表. 除了
最后一个参数之外的所有参数都会被复制,所以不会有参数被修改. (参见
<a href="#orgf39062c">重排列(Rearrangement)</a> 里的 <code>nconc</code>, 一种不用复制连结列表的方式.)
</p>

<p>
更一般的说, <code>append</code> 的最后一个参数可能是任意 Lisp 对象.最后一个参数不会被复制
或转换;它会成为新的列表中最后一个 cons cell 的 CDR. 如果最后一个参数本身是一个
列表,那么它的元素会成为结果列表中的元素(而不是这个列表成为结果列表中的元素).如
果这个列表最后的元素不是一个列表(<code>nil</code> 或正确列表),那么结果就会是一个 "点列表
", 因为它的最后一个 CDR 不是 <code>nil</code>.(参见 <a href="#org0f39bb9">Cons Cells</a>)
</p>

<p>
下面是一些使用 <code>append</code> 的示例:
</p>
<pre class="example" id="org7fc373e">
  (setq trees '(pine oak))
       ⇒ (pine oak)
  (setq more-trees (append '(maple birch) trees))
       ⇒ (maple birch pine oak)

  trees
       ⇒ (pine oak)
  more-trees
       ⇒ (maple birch pine oak)
  (eq trees (cdr (cdr more-trees)))
       ⇒ t
</pre>
<p>
通过查看下面的方框图,你可以知道 <code>append</code> 是如何工作的. 变量 <code>trees</code> 被设置为列
表 <code>(pine oak)</code> ,然后变量 <code>more-trees</code> 被设置为列表 <code>(maple birch pine
  oak)</code>. 然而变量 <code>trees</code> 还是继续指向原来的列表:
</p>
<pre class="example" id="org515b1a8">
  more-trees                trees
  |                           |
  |     --- ---      --- ---   -&gt; --- ---      --- ---
   --&gt; |   |   |--&gt; |   |   |--&gt; |   |   |--&gt; |   |   |--&gt; nil
	--- ---      --- ---      --- ---      --- ---
	 |            |            |            |
	 |            |            |            |
	  --&gt; maple    --&gt;birch     --&gt; pine     --&gt; oak
</pre>
<p>
一个空序列不会对 <code>append</code> 返回的结果贡献任何值.这样的后果是,最后一个参数为
<code>nil</code> 会强制生成前面参数的副本:
</p>
<pre class="example" id="org6ac90fe">
  trees
       ⇒ (pine oak)
  (setq wood (append trees nil))
       ⇒ (pine oak)
  wood
       ⇒ (pine oak)
  (eq wood trees)
       ⇒ nil
</pre>
<p>
在函数 <code>copy-sequence</code> 发明之前,这曾经是一种常用的复制列表的方式. 参见
<a href="#orgc0e0dcf">序列 数组 向量(Sequences Arrays Vectors)</a>.
下面这个例子展示了使用向量和字符串作为 <code>append</code> 的参数:
</p>
<pre class="example" id="org2e8e469">
  (append [a b] "cd" nil)
       ⇒ (a b 99 100)
</pre>
<p>
如果有 <code>apply</code> 函数(参见<a href="#orgfb3c20f">调用函数(Calling Functions)</a>)的帮助,我们可以将一个列表
的列表中所有的列表都附加到结果中去.
</p>
<pre class="example" id="org76cbfff">
  (apply 'append '((a b c) nil (x y z) nil))
       ⇒ (a b c x y z)
</pre>
<p>
如果没有给定 sequences, 则返回 <code>nil</code> :
</p>
<pre class="example" id="org7ba53c4">
  (append)
       ⇒ nil
</pre>
<p>
下面是一些最后的参数不是列表的例子:
</p>
<pre class="example" id="org4621a43">
  (append '(x y) 'z)
       ⇒ (x y . z)
  (append '(x y) [z])
       ⇒ (x y . [z])
</pre>
<p>
这里的第二个例子显示了当最后一个参数是序列但不是列表时,序列的元素不会成为结果
列表的元素,而是这个序列成为最后一个 CDR, 就像其他所有非列表作为最后参数一样.
</p></dd>

<dt><code>(copy-tree tree &amp;optional vecp)</code></dt><dd><p>
这个函数返回树结构 tree 的副本. 如果 tree
是一个 cons cell, 则生成一个具有相同 CAR 和 CDR 的新 cons cell ,然后递归地以相
同方式复制 CAR 和 CDR.
</p>

<p>
通常来讲,当 tree 是 cons cell 之外的对象时, <code>copy-tree</code> 直接返回 tree 自身. 然
而, 如果 vecp 是非 <code>nil</code> 的, 它也会复制向量(并递归的操作他们的元素)
</p></dd>

<dt><code>(flatten-tree tree)</code></dt><dd><p>
这个函数返回 tree 的一个 "扁平"的副本, 也就是,一个包
含以 tree 为根的 cons cell 树的所有非 <code>nil</code> 终端节点或叶子的列表.返回列表中的
叶子与 tree 中的叶子顺序相同.
</p>
<pre class="example" id="orgfed05c4">
  (flatten-tree '(1 (2 . 3) nil (4 5 (6)) 7))
      ⇒(1 2 3 4 5 6 7)
</pre></dd>

<dt><code>(ensure-list object)</code></dt><dd><p>
这个函数将 object 作为列表返回. 如果 object 已经是一
个列表了,函数直接返回它; 否则,该函数返回一个但元素的列表,只包含有这个 object.
</p>

<p>
如果你有一个可能是也可能不是列表的变量,这通常就很有用了,然后,你就可以这样使用
了:
</p>
<pre class="example" id="org7247cbc">
  (dolist (elem (ensure-list foo))
    (princ elem))
</pre></dd>

<dt><code>(number-sequence from &amp;optional to separation)</code></dt><dd><p>
这个函数返回一个列表,该列
表以 from 开头,按照 separation 递增,到 to 结束或在 to 之前结束. separation 可
以是正数或负数,默认值是1. 如果 to 是 <code>nil</code> 或数值上等于 from, 则返回值是一个单
元素的列表 <code>(from)</code> . 如果 to 比 from 少,且 separation 是正数,或者 to 比 from
大,但 separation 是负数,则返回值是 <code>nil</code>, 因为这些参数指定的是一个空序列.
</p>

<p>
如果 separation 是 0, 且 to 既不是 <code>nil</code> 也不在数值上等于 from, 则该函数会发出
一个错误信号,因为这些参数指定的是一个无限序列.
</p>

<p>
所有的参数都是数字.浮点数作为参数可能会很棘手,因为浮点数运算是不精确的.例如,根
据计算机的不同, <code>(number-sequence 0.4 0.6 0.2)</code> 返回一个单元素列表 <code>(0.4)</code>, 而
<code>(number-sequence 0.4 0.8 0.2)</code> 返回一个三个元素的列表这种情况是很可能会发生的.
这个列表的第 N 个元素是通过精确公式 <code>(+ from (* N separation))</code>. 因此,如果想要
将 to 包含在列表中,可以给 to 传递为这种精确表达式.或者,也可以给 to 传递一个稍
微大一点的值(如果 separation 是负数,则传递稍负一点的数.)
</p>

<p>
一些例子:
</p>
<pre class="example" id="orgce99a45">
  (number-sequence 4 9)
       ⇒ (4 5 6 7 8 9)
  (number-sequence 9 4 -1)
       ⇒ (9 8 7 6 5 4)
  (number-sequence 9 4 -2)
       ⇒ (9 7 5)
  (number-sequence 8)
       ⇒ (8)
  (number-sequence 8 5)
       ⇒ nil
  (number-sequence 5 8 -1)
       ⇒ nil
  (number-sequence 1.5 6 2)
       ⇒ (1.5 3.5 5.5)
</pre></dd>
</dl>
</div>
</div>

<div id="outline-container-orgfff3f75" class="outline-4">
<h4 id="orgfff3f75"><span class="done DONE">DONE</span> 列表变量(List Variables)</h4>
<div class="outline-text-4" id="text-orgfff3f75">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-07 Thu 00:20]</span></span></li>
</ul>
<p>
修改储存在变量中的列表.
</p>

<p>
这小节的函数和一个宏函数,提供了很方便的方式来修改存储在变量里的列表.
</p>

<dl class="org-dl">
<dt>宏 (push element listname)</dt><dd><p>
这个宏函数创建一个新的列表,其 CAR 是 element ,
CDR 是由 listname 指定的列表,并将新列表储存到 listname 中. 在最简单的例子中,
listname 是一个命名列表的未引用的符号, 这个宏函数等价于
<code>(setq listname (cons element listname))</code>
</p>
<pre class="example" id="org77cc282">
  (setq l '(a b))
       ⇒ (a b)
  (push 'c l)
       ⇒ (c a b)
  l
       ⇒ (c a b)
</pre>
<p>
更一般的说, <code>listname</code> 可以是一个广义变量. 在这种情况下,该宏函数等价于
<code>(setf listname (cons element listname))</code>. 参见
<a href="#org728a322">广义变量(Generalized Variables)</a>.
对于从列表中删除第一个元素的 <code>pop</code> 宏函数,参见 <a href="#orgf87bd69">列表元素(List Elements)</a>.
</p></dd>
</dl>


<p>
下面的两个函数修改作为变量值的列表.
</p>
<dl class="org-dl">
<dt><code>(add-to-list symbol element &amp;optional append compare-fn)</code></dt><dd><p>
这个函数通过将
element 设置到旧的值中(如果 element 不是该值的成员)来设置变量 symbol. 函数返回
更新或没更新的结果列表.在调用前, symbol 的值最好是一个列表. <code>add-to-list</code> 使用
compare-fn 来将 element 与已有的列表成员比较;如果 compare-fn 是 <code>nil</code>, 则使用
<code>equal</code> 比较.
</p>

<p>
通常来讲,如果 element 被添加了,它会被添加到 symbol 的前面,但是如果可选参数
append 是非 <code>nil</code> 的,它就会被添加到末尾.
</p>

<p>
参数 symbol 不是隐式引用的; <code>att-to-list</code> 是一个普通的函数,和 <code>set</code> 类似,但不
同于 <code>setq</code>. 如果是你自己想要的,请自己引用该参数.
</p>

<p>
当 symbol 引用的是词法变量时,不要使用该函数.
</p>

<p>
下面是一个如何使用 <code>add-to-list</code> 的场景:
</p>
<pre class="example" id="org426ae71">
  (setq foo '(a b))
       ⇒ (a b)

  (add-to-list 'foo 'c)     ;; Add ‘c’.
       ⇒ (c a b)

  (add-to-list 'foo 'b)     ;; No effect.
       ⇒ (c a b)

  foo                       ;; ‘foo’ was changed.
       ⇒ (c a b)
</pre>
<p>
<code>(add-to-list 'var value)</code> 的等价表达式是:
</p>
<pre class="example" id="org12ba3d7">
  (if (member VALUE VAR)
      VAR
    (setq VAR (cons VALUE VAR)))
</pre></dd>

<dt><code>(add-to-ordered-list symbol element &amp;optional order)</code></dt><dd><p>
这个函数通过将
element 插入到旧的值中 order 指定的位置,来设置变量 symbol, symbol 必须是一个列
表. 如果 element 已经是 list 的成员了,那么就会调整其在 list 中的位置到 order
处. 成员关系使用 <code>eq</code> 进行测试. 这个函数会返回结果列表,无论是否进行了更新.
</p>

<p>
order 通常来讲是一个数字(整数或浮点数), 列表的元素按照非递减的数字顺序排序.
</p>

<p>
order 可以是 <code>nil</code> 或省略.如果已有数字顺序,那么元素的数字顺序保持不变;若没
有,element 没有数字顺序. 没有数字列表顺序的元素会直接被放置到列表的末尾,没有特
定顺序.
</p>

<p>
如果有数字顺序的话, order 的任何其他值会移除 element 的数字顺序,若没有,它就等
价于 <code>nil</code>.
</p>

<p>
参数 symbol 是非隐式引用的, <code>add-to-ordered-list</code> 是一个普通函数,和 <code>set</code> 类似,但
不同于 <code>setq</code>. 如果有必要,请自己引用参数.
</p>

<p>
排序信息是储存在 symbol 的 <code>list-order</code> 属性中的一个哈希表中的. symbol 不能引
用的是词法变量.
</p>

<p>
下面是显示如何使用 <code>add-to-ordered-list</code> 的一个场景:
</p>
<pre class="example" id="orga464191">
  (setq foo '())
       ⇒ nil

  (add-to-ordered-list 'foo 'a 1)     ;; Add ‘a’. a 的数字顺序为 1
       ⇒ (a)

  (add-to-ordered-list 'foo 'c 3)     ;; Add ‘c’. c 的数字顺序为 3
       ⇒ (a c)

  (add-to-ordered-list 'foo 'b 2)     ;; Add ‘b’. b 的数字顺序为 2
       ⇒ (a b c)

  (add-to-ordered-list 'foo 'b 4)     ;; Move ‘b’. b 的数字顺序设置为4
       ⇒ (a c b)

  (add-to-ordered-list 'foo 'd)       ;; Append ‘d’. d 没有数字顺序,直接插入到末尾
       ⇒ (a c b d)

  (add-to-ordered-list 'foo 'e)       ;; Add ‘e’. e 和 d 没有数字,插入到末尾,没有特定顺序.
       ⇒ (a c b e d)

  foo                       ;; ‘foo’ was changed.
       ⇒ (a c b e d)

</pre></dd>
</dl>
</div>
</div>

<div id="outline-container-org65e7d81" class="outline-4">
<h4 id="org65e7d81"><span class="done DONE">DONE</span> 修改列表(Modifying Lists)</h4>
<div class="outline-text-4" id="text-org65e7d81">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-07 Thu 12:36]</span></span></li>
</ul>
<p>
将新的元素储存到已有列表.
</p>

<p>
你可以使用 <code>setcar</code> 和 <code>setcdr</code> 来修改一个 cons cell 的 CAR 和 CDR. 这些是破坏性
的操作,因为它们会改变已有的列表.破坏性列表应该只应用于可变列表,也就是,通过
<code>cons</code> , <code>list</code> 或类似操作构造的列表. 通过引用创建的列表是程序的一部分,不应该通
过破坏性操作改变. 参见 <a href="#org73c2bd1">易变性(Mutability)</a>.
</p>

<blockquote>
<p>
Common Lisp 注意: Common Lisp 使用 <code>rplaca</code> 和 <code>prlacd</code> 来修改列表结构;他们改变
结构的方式和 <code>setcar</code> 和 <code>setcdr</code> 相同,但是 Common Lisp 函数返回的是 cons cell
而 <code>setcar</code> 和 <code>setcdr</code> 返回的是新 CAR 或 CDR.
</p>
</blockquote>
</div>

<ul class="org-ul">
<li><a id="org75a5e3f"></a><span class="done DONE">DONE</span> Setcar<br />
<div class="outline-text-5" id="text-org75a5e3f">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-07 Thu 11:05]</span></span></li>
</ul>
<p>
替换列表中的一个元素.
</p>

<p>
修改一个 cons cell 中的 CAR 可以使用 <code>setcar</code>. 当用在一个列表上时, <code>setcar</code> 用一
个不同的元素替换列表中的一个元素.
</p>

<dl class="org-dl">
<dt><code>(setcar cons object)</code></dt><dd><p>
函数将 object 储存为 cons 的新 CAR, 替换掉 cons 原来
的 CAR. 也就是说,它将 cons 的 CAR 插槽指向 object. 该函数的返回值是 object. 例
如:
</p>
<pre class="example" id="org91910cb">
  (setq x (list 1 2))
       ⇒ (1 2)
  (setcar x 4)
       ⇒ 4
  x
       ⇒ (4 2)
</pre>
<p>
当 cons cell 是几个列表的共享结构的部分时,将新 CAR 储存到 cons cell 会同时改变
这些列表中的一个元素. 下面是一个例子:
</p>
<pre class="example" id="org1876485">

  ;; Create two lists that are partly shared.
  (setq x1 (list 'a 'b 'c))
       ⇒ (a b c)
  (setq x2 (cons 'z (cdr x1)))
       ⇒ (z b c)

  ;; Replace the CAR of a shared link.
  (setcar (cdr x1) 'foo)
       ⇒ foo
  x1                           ; Both lists are changed.
       ⇒ (a foo c)
  x2
       ⇒ (z foo c)

  ;; Replace the CAR of a link that is not shared.
  (setcar x1 'baz)
       ⇒ baz
  x1                           ; Only one list is changed.
       ⇒ (baz foo c)
  x2
       ⇒ (z foo c)
</pre>
<p>
下面是变量 <code>x1</code> 和 <code>x2</code> 中的两个列表的共享结构的图形表述,显示了为什么替换 <code>b</code>
会同时修改它们:
</p>
<pre class="example" id="org7f72d49">
	  --- ---        --- ---      --- ---
  x1---&gt; |   |   |----&gt; |   |   |--&gt; |   |   |--&gt; nil
	  --- ---        --- ---      --- ---
	   |        --&gt;   |            |
	   |       |      |            |
	    --&gt; a  |       --&gt; b        --&gt; c
		   |
	 --- ---   |
  x2--&gt; |   |   |--
	 --- ---
	  |
	  |
	   --&gt; z
</pre>
<p>
下面是显示相同关系的另一种方框图的形式:
</p>
<pre class="example" id="orgfe05571">
  x1:
   --------------       --------------       --------------
  | car   | cdr  |     | car   | cdr  |     | car   | cdr  |
  |   a   |   o-------&gt;|   b   |   o-------&gt;|   c   |  nil |
  |       |      |  --&gt;|       |      |     |       |      |
   --------------  |    --------------       --------------
		   |
  x2:              |
   --------------  |
  | car   | cdr  | |
  |   z   |   o----
  |       |      |
   --------------

</pre></dd>
</dl>
</div>
</li>

<li><a id="org418bcd7"></a><span class="done DONE">DONE</span> Setcdr<br />
<div class="outline-text-5" id="text-org418bcd7">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-07 Thu 11:20]</span></span></li>
</ul>
<p>
替换部分列表的主干.这可以用来添加或删除元素.
</p>

<p>
用来修改 CDR 的最底层的原始函数是 <code>setcdr</code>:
</p>

<dl class="org-dl">
<dt><code>(setcdr cons object)</code></dt><dd>这个函数将 object 储存为 cons 的新 CDR, 用来替换原来
的 CDR. 换句话说,该函数将 cons 的 CDR 插槽改变为指向 object. 其返回值是 object.</dd>
</dl>


<p>
下面是一个使用不同列表来替换一个列表的 CDR 的例子. 列表中除了第一个元素之外的元
素都被移除了. 第一个元素没有改变,因为第一个元素位于列表的 CAR, 而不是 CDR.
</p>
<pre class="example" id="org0b35008">
(setq x (list 1 2 3))
     ⇒ (1 2 3)
(setcdr x '(4))
     ⇒ (4)
x
     ⇒ (1 4)
</pre>
<p>
你可以通过修改列表中 cons cell 的 CDR 来删除列表中位于中间的元素.例如,下面的例子
从列表 <code>(a b c)</code> 删除第二个元素 <code>b</code>, 就是通过改变第一个 cons cell 的 CDR 完成的:
</p>
<pre class="example" id="orgec16a97">
(setq x1 (list 'a 'b 'c))
     ⇒ (a b c)
(setcdr x1 (cdr (cdr x1)))
     ⇒ (c)
x1
     ⇒ (a c)
</pre>
<p>
下面是这个例子的方框表示:
</p>
<pre class="example" id="org9a13890">
                   --------------------
                  |                    |
 --------------   |   --------------   |    --------------
| car   | cdr  |  |  | car   | cdr  |   --&gt;| car   | cdr  |
|   a   |   o-----   |   b   |   o--------&gt;|   c   |  nil |
|       |      |     |       |      |      |       |      |
 --------------       --------------        --------------
</pre>
<p>
第二个 cons cell 原来储存的是元素 b, 仍然存在,且其 car 仍然是 b, 但是它不再组成
列表的部分了.
</p>

<p>
通过修改 CDR 来插入一个新的元素也同样容易:
</p>
<pre class="example" id="orgec7f95e">
(setq x1 (list 'a 'b 'c))
     ⇒ (a b c)
(setcdr x1 (cons 'd (cdr x1)))
     ⇒ (d b c)
x1
     ⇒ (a d b c)
</pre>
<p>
下面是这个例子的方框表示:
</p>
<pre class="example" id="orge974ae9">
 --------------        -------------       -------------
| car  | cdr   |      | car  | cdr  |     | car  | cdr  |
|   a  |   o   |   --&gt;|   b  |   o-------&gt;|   c  |  nil |
|      |   |   |  |   |      |      |     |      |      |
 --------- | --   |    -------------       -------------
           |      |
     -----         --------
    |                      |
    |    ---------------   |
    |   | car   | cdr   |  |
     --&gt;|   d   |   o------
        |       |       |
         ---------------

</pre>
</div>
</li>

<li><a id="orgf39062c"></a><span class="done DONE">DONE</span> 重排列(Rearrangement)<br />
<div class="outline-text-5" id="text-orgf39062c">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-07 Thu 11:42]</span></span></li>
</ul>
<p>
重新排序列表中的元素; 组合列表.
</p>

<p>
这一小节是一些通过修改他们的组件 cons cell 的 CDR 来破坏性地重新排列列表的函数.
这些函数是破坏性的,因为他们会破坏传递给他们的原始列表,重新链接他们的 cons cell
来形成一个新的列表,这个新列表会作为返回值.
</p>

<p>
另一个修改 cons cell 的函数,请参见 <a href="#org1ae1b05">集合与列表(Sets And Lists)</a> 中的 <code>delq</code>,
</p>

<dl class="org-dl">
<dt><code>(nconc &amp;rest lists)</code></dt><dd><p>
这个函数返回一个包含 lists 中所有元素的列表. 与
<code>append</code> (参见 <a href="#org2213f78">构建列表(Building Lists)</a>)不同. 不会复制 lists 的副本进行操作,而
是 lists 的最后一个 CDR 改变成指向后面的列表. lists 的最后一个不会被改变,例如:
</p>
<pre class="example" id="org253b164">
  (setq x (list 1 2 3))
       ⇒ (1 2 3)
  (nconc x '(4 5))
       ⇒ (1 2 3 4 5)
  x
       ⇒ (1 2 3 4 5)
</pre>
<p>
因为 <code>nconc</code> 的最后一个参数没有改变,因此最后一个参数使用常量列表是合理的,例如
<code>'(4 5)</code> ,就像上面的例子一样. 也是处于相同的原因,最后一个参数也不必须是列表:
</p>
<pre class="example" id="orga62139f">
  (setq x (list 1 2 3))
       ⇒ (1 2 3)
  (nconc x 'z)
       ⇒ (1 2 3 . z)
  x
       ⇒ (1 2 3 . z)
</pre>
<p>
然而,其他的参数(除了最后一个之外)应该是可变列表.
</p>

<p>
一个常见的陷阱是使用常量列表作为 <code>nconc</code> 的非最后一个参数. 如果你这样做了,出现
的结果行为是未定义的(参见 <a href="#orgc883584">自执行表达式(Self-Evaluating Forms)</a>). 程序每次运行时
都可能会发生改变. 下面是可能会发生的情况(并不是一定会发生):
</p>
<pre class="example" id="org07ec2f5">
  (defun add-foo (x)            ; We want this function to add
    (nconc '(foo) x))           ;   ‘foo’ to the front of its arg.

  (symbol-function 'add-foo)
       ⇒ (lambda (x) (nconc '(foo) x))

  (setq xx (add-foo '(1 2)))    ; It seems to work.
       ⇒ (foo 1 2)
  (setq xy (add-foo '(3 4)))    ; What happened?
       ⇒ (foo 1 2 3 4)
  (eq xx xy)
       ⇒ t

  (symbol-function 'add-foo)
       ⇒ (lambda (x) (nconc '(foo 1 2 3 4) x))
</pre></dd>
</dl>
</div>
</li>
</ul>
</div>

<div id="outline-container-org1ae1b05" class="outline-4">
<h4 id="org1ae1b05"><span class="done DONE">DONE</span> 集合与列表(Sets And Lists)</h4>
<div class="outline-text-4" id="text-org1ae1b05">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-07 Thu 12:37]</span></span></li>
</ul>
<p>
列表可以表示一个有限的数学集合.
</p>

<p>
一个列表可以表示一个未排序的数学集合(简单理解为,如果一个值出现在列表中,就将其视
为集合的元素,并忽略列表中的顺序.). 想要组成两个集合的并集,可以使用 <code>append</code> (只
要你不介意会有重复的元素). 你可以使用 <code>delete-dups</code> 或 <code>seq-uniq</code> 来移除 <code>equal</code>
的重复项. 集合相关的其他有用的函数包括 <code>memq</code> 和 <code>delq</code> 以及他们的 <code>equal</code> 版本,
<code>member</code> 和 <code>delete</code>.
</p>

<blockquote>
<p>
Common Lisp 提示: Common Lisp 也有集合操作 <code>union</code> (不会产生重复元素) 和
<code>intersection</code>. 在 Emacs Lisp 中, 这些功能的变体由 <code>cl-lib</code> 库提供,
参见 <a href="https://www.gnu.org/software/emacs/manual/html_mono/cl.html#Lists-as-Sets">cl#Lists as Sets</a> .
</p>
</blockquote>

<dl class="org-dl">
<dt><code>(memq object list)</code></dt><dd><p>
这个函数测试 object 是否为 list 的成员. 如果是,则返回
一个以 object 第一次出现的位置为开始的列表. 否则,会返回 <code>nil</code> , <code>memq</code> 中的
<code>q</code> 意思是说该函数使用 <code>eq</code> 来将 object 与 list 中的元素进行比较:
</p>
<pre class="example" id="orgaba2f05">
  (memq 'b '(a b c b a))
       ⇒ (b c b a)
  (memq '(2) '((1) (2)))    ; The two ‘(2)’s need not be ‘eq’.
       ⇒ Unspecified; might be ‘nil’ or ‘((2))’.
</pre></dd>
<dt><code>(delq object list)</code></dt><dd><p>
这个函数从 list 中破坏性地移除 <code>eq</code> object 的所有元素,
并返回结果列表. <code>delq</code> 中的 <code>q</code> 意思是该函数使用 <code>eq</code> 来将 object 与 list 中的
元素进行比较,就像是 <code>memq</code> 和 <code>remq</code>.
</p>

<p>
通常来说,当你激活 <code>delq</code> 时,你应该通过将返回值分配给储存原始列表的变量来使用返
回值. 原因解释如下:
</p>

<p>
<code>delq</code> 函数通过简单的向前推进列表来删除列表前端的元素,并返回从这些元素开始之后
的子列表. 例如:
</p>
<pre class="example" id="orgf324ebc">
  (delq 'a '(a b c)) ≡ (cdr '(a b c))  ;
</pre>
<p>
当出现在列表中间的元素被删除时,删除它会引发 CDR (参见 <a href="#org418bcd7">Setcdr</a>)的改变.
</p>
<pre class="example" id="orgc54e7c5">
  (setq sample-list (list 'a 'b 'c '(4)))
       ⇒ (a b c (4))
  (delq 'a sample-list)
       ⇒ (b c (4))
  sample-list
       ⇒ (a b c (4))
  (delq 'c sample-list)
       ⇒ (a b (4))
  sample-list
       ⇒ (a b (4))
</pre>
<p>
请注意 <code>(delq 'c sample-list)</code> 将 <code>sample-list</code> 修改为删除第三个元素,但是
<code>(delq 'a sample-list)</code>  不会拼接任何东西,它只会返回一个更短的列表.请不要假设
原本储存参数 list 的变量现在有更少的元素,或是仍然储存原来的列表!请保存 <code>delq</code>
的结果然后再使用它.我们常常将结果储存回原始列表所在的变量:
</p>
<pre class="example" id="org570d3af">
  (setq flowers (delq 'rose flowers))
</pre>
<p>
在下面的例子中, <code>delq</code> 试图匹配的 <code>(list 4)</code> 与 <code>sample-list</code> 中的 <code>(4)</code> 是
<code>equal</code> 的,但不是 <code>eq</code> 的:
</p>
<pre class="example" id="org73e731c">
  (delq (list 4) sample-list)
       ⇒ (a c (4))
</pre>
<p>
如果你想要删除给定值是 <code>equal</code> 的元素,请使用 <code>delete</code> (下面会介绍).
</p></dd>

<dt><code>(remq object list)</code></dt><dd><p>
这个函数返回 list 的副本,这个副本中删除了所有 <code>eq</code>
object 的元素. <code>remq</code> 中的 <code>q</code> 意思是该函数使用 <code>eq</code> 来将 object 与 list 中的
元素进行比较.
</p>
<pre class="example" id="orgb37487f">
  (setq sample-list (list 'a 'b 'c 'a 'b 'c))
       ⇒ (a b c a b c)
  (remq 'a sample-list)
       ⇒ (b c b c)
  sample-list
       ⇒ (a b c a b c)
</pre></dd>

<dt><code>(memql object list)</code></dt><dd><p>
函数 <code>memql</code> 测试 object 是否为 list 的成员, object
与 list 成员比较使用的是 <code>eql</code>, 因此浮点值元素是通过值进行比较的. 如果 object
是 list 的成员, <code>memql</code> 返回以 object 第一次在 list 中出现的位置开始的子列表,
否则,返回 <code>nil</code>
</p>

<p>
将这个函数与 <code>memq</code> 进行比较:
</p>
<pre class="example" id="orga50bf52">
  (memql 1.2 '(1.1 1.2 1.3))  ; ‘1.2’ and ‘1.2’ are ‘eql’.
       ⇒ (1.2 1.3)
  (memq 1.2 '(1.1 1.2 1.3))  ; The two ‘1.2’s need not be ‘eq’.
       ⇒ Unspecified; might be ‘nil’ or ‘(1.2 1.3)’.
</pre></dd>
</dl>


<p>
下面三个函数与 <code>memq</code>, <code>delq</code>, 和 <code>remq</code> 类似,但是使用 <code>equal</code> 而不是 <code>eq</code> 来比
较元素. 参见 <a href="#org9fe4c9b">相等断言(Equality Predicates)</a>.
</p>

<dl class="org-dl">
<dt><code>(member object list)</code></dt><dd><p>
这个函数测试 object 是否为 list 中的成员,使用
<code>equal</code> 进行比较. 如果 object 是成员, <code>member</code> 返回一个以 object 第一次出现的
位置开始的列表. 否则,返回 <code>nil</code>.
</p>

<p>
将这个函数与 <code>memq</code> 比较:
</p>
<pre class="example" id="org057a055">
  (member '(2) '((1) (2)))  ; ‘(2)’ and ‘(2)’ are ‘equal’.
       ⇒ ((2))
  (memq '(2) '((1) (2)))    ; The two ‘(2)’s need not be ‘eq’.
       ⇒ Unspecified; might be ‘nil’ or ‘(2)’.
  ;; Two strings with the same contents are ‘equal’.
  (member "foo" '("foo" "bar"))
       ⇒ ("foo" "bar")
</pre></dd>

<dt><code>(delete object sequence)</code></dt><dd><p>
这个函数从 sequence 中删除所有 <code>equal</code> object 的
元素并返回结果序列.
</p>

<p>
如果 sequence 是列表, <code>delete</code> 像 <code>delq</code> 一样删除元素: 使用 <code>equal</code> 来比较元素,就
像 <code>member</code> 一样; 当发现有匹配的元素时,它会像 <code>delq</code> 一样删除元素. 正如使用
<code>delq</code> 一样,你通常应该将返回值赋值给储存原本列表的变量来使用返回值.
</p>

<p>
如果 sequence 是一个向量或字符串,delete 会返回一个 sequence 的副本,这个副本删
除了所有 <code>equal</code> object 的元素.
</p>

<p>
例如:
</p>
<pre class="example" id="orgfff0ef3">
  (setq l (list '(2) '(1) '(2)))
  (delete '(2) l)
       ⇒ ((1))
  l
       ⇒ ((2) (1))
  ;; If you want to change ‘l’ reliably,
  ;; write ‘(setq l (delete '(2) l))’.
  (setq l (list '(2) '(1) '(2)))
  (delete '(1) l)
       ⇒ ((2) (2))
  l
       ⇒ ((2) (2))
  ;; In this case, it makes no difference whether you set ‘l’,
  ;; but you should do so for the sake of the other case.
  (delete '(2) [(2) (1) (2)])
       ⇒ [(1)]
</pre></dd>

<dt><code>(remove object sequence)</code></dt><dd><p>
这个函数是 <code>delete</code> 的非破坏性副本. 它会返回一
个 sequence 的副本,一个列表,向量或字符串,其中所有 <code>equal</code> 与 object 的元素都被
删除了,例如:
</p>
<pre class="example" id="orgb0081a6">
  (remove '(2) '((2) (1) (2)))
       ⇒ ((1))
  (remove '(2) [(2) (1) (2)])
       ⇒ [(1)]
</pre>
<blockquote>
<p>
Common Lisp 注意: GNU Emacs Lisp 中的 <code>member</code>, <code>delete</code> 和 <code>remove</code> 是源于
Maclisp 而不是 Common Lisp. Common Lisp 的版本不适用 <code>equal</code> 来比较元素.
</p>
</blockquote></dd>

<dt><code>(member-ignore-case object list)</code></dt><dd>这个函数与 <code>member</code> 类似,但 object 应该
是一个字符串,并且忽略其大小写与文本表示: 大小写字母视为相等,单字节字符串会在比
较之前转换成多字节.</dd>

<dt><code>(delete-dups list)</code></dt><dd>这个函数破坏性地从 list 中移除所有 <code>equal</code> 的重复项,并
将结果储存到 list 中并返回这个列表. 当list 中的一个元素有多个 <code>equal</code> 发生时,
<code>delete-dups</code> 会保留第一个. 对于非破坏性地操作,参见
<a href="#org6f6c0f4">序列函数(Sequence Functions)</a>  中的 <code>seq-uniq</code>.</dd>
</dl>


<p>
向储存在变量中的列表中添加元素并作为集合使用的函数 <code>add-to-list</code>, 参见
<a href="#orgfff3f75">列表变量(List Variables)</a>.
</p>
</div>
</div>

<div id="outline-container-orgaf2e615" class="outline-4">
<h4 id="orgaf2e615"><span class="done DONE">DONE</span> 关联表(Association Lists)</h4>
<div class="outline-text-4" id="text-orgaf2e615">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-07 Thu 19:54]</span></span></li>
</ul>
<p>
列表可以表示有限的关系或映射.
</p>

<p>
"association list"(关联表),简写 "alist", 是记录从键到值的映射的列表. 这是一种被
叫做 "associations"(关联,联系,关系) 的 con cell 的列表: 每个 cons cell 的 CAR 是
键, CDR 是"associated value" (关联值).<sup><a id="fnr.6" class="footref" href="#fn.6" role="doc-backlink">6</a></sup>
</p>

<p>
下面是一个 alist 的示例, <code>pine</code> 键与值 <code>cones</code> 关联; 键 <code>oak</code> 与值 <code>acorns</code> 关联;
键 <code>maple</code> 与 <code>seeds</code> 关联
</p>
<pre class="example" id="org0ec6c01">
((pine . cones)
 (oak . acorns)
 (maple . seeds))
</pre>
<p>
alist 中的键和值都可以是任意 Lisp 对象. 例如,在下面的 alist 中,符号 <code>a</code> 与数字
<code>1</code> 关联, 字符串 <code>"b"</code> 与列表 <code>(2 3)</code> 关联, 这个列表就是 alist 元素的 CDR:
</p>
<pre class="example" id="org3c0d93f">
((a . 1) ("b" 2 3))
</pre>
<p>
有时最好是设计一个 alist 来将关联值储存在元素的 CDR 的 CAR 中. 下面就是这样一个
alist 的例子:
</p>
<pre class="example" id="orgf7115cb">
     ((rose red) (lily white) (buttercup yellow))
     ;; 他们的形式是这个样子的 ((car . (car . nil)) ... )
</pre>
<p>
这里我们认为 <code>red</code> 是关联于 <code>rose</code> 的值. 这种 alist 的一个好处是,你可以在 CDR 的
CDR 中储存其他的相关信息,即使是一个其他条目的列表. 一个坏处是,你不能使用 <code>rassq</code>
(下面描述) 来找到包含给定值的元素. 当这些考虑都不重要时,选择哪种形式就是个人口味
问题了,只要你对任意给定 alist 都使用一致的形式就行.
</p>

<p>
上面展示的相同列表可以认为是元素的 CDR 是关联值, <code>rose</code> 的关联值是列表 <code>(red)</code>.
</p>

<p>
关联表通常用来记录可能保留在堆栈中的信息,因为新的关联可以很容易就被添加到列表的
前端.当在关联表中搜查一个给定键的关联时,会返回第一个找到的关联(如果有多个的话).
</p>

<p>
在 Emacs Lisp 中,如果一个关联表的元素不是 cons cell ,这不被认为是一个错误, alist
的查找函数只会忽略这样的元素. 许多其他版本的 Lisp 在这种情况下会发出错误信号.
</p>

<p>
请注意,属性列表与关联列表有几个相似的方面. 属性列表的每个键与关联表一样只出现一
次. 关于属性列表和关联列表的比较,请参见 <a href="#orgab3b2c8">属性列表(Property Lists)</a>.
</p>

<dl class="org-dl">
<dt><code>(assoc key alist &amp;optional testfn)</code></dt><dd><p>
这个函数返回 alist 中 key 的第一个关联,如果 testfn 是一个函数,则使用它来比较
key 和 alist 的元素,否则,使用 <code>equal</code> 比较(参见
<a href="#org9fe4c9b">相等断言(Equality Predicates)</a>. 如果 testfn 是函数,它会使用两个参数进行调用:
key 和 alist 中元素的 CAR. 如果没有与 key 相等的 CAR ,则返回 <code>nil</code> :
</p>
<pre class="example" id="org5566b81">
  (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
       ⇒ ((pine . cones) (oak . acorns) (maple . seeds))
  (assoc 'oak trees)
       ⇒ (oak . acorns)
  (cdr (assoc 'oak trees))
       ⇒ acorns
  (assoc 'birch trees)
       ⇒ nil
</pre>
<p>
下面是另一个例子,键和值都不是符号:
</p>
<pre class="example" id="orgf7f969d">
  (setq needles-per-cluster
	'((2 "Austrian Pine" "Red Pine")
	  (3 "Pitch Pine")
	  (5 "White Pine")))

  (cdr (assoc 3 needles-per-cluster))
       ⇒ ("Pitch Pine")
  (cdr (assoc 2 needles-per-cluster))
       ⇒ ("Austrian Pine" "Red Pine")

</pre>
<p>
函数 <code>assoc-string</code> 与 <code>assoc</code> 很像,除了它会忽视字符串之间的特定区别. 参见
<a href="#org3bcdb05">文本比较(Text Comparison)</a>.
</p></dd>

<dt><code>(rassoc value list)</code></dt><dd><p>
这个函数返回 alist 中第一值为 value 的关联. 如果
alist 中没有一个关联的 CDR <code>equal</code> value 那么就会返回 <code>nil</code>.
</p>

<p>
<code>rassoc</code> 和 <code>~assoc 类似,但它比较的是每个 alist 关联的 CDR 而不是 CAR. 你可以
  认为是 ~assoc</code> 的逆,用给定值来找键.
</p></dd>

<dt><code>(assq key alist)</code></dt><dd><p>
这个函数与 <code>assoc</code> 相似的地方在于都是返回 alist 中 key
的第一个关联,但是比较使用的是 <code>eq</code> .如果 alist 中没有一个联系的 CAR eq key 那
么 <code>assq</code> 就返回 <code>nil</code>. 这个函数比 <code>assoc</code> 更常用,因为 <code>eq</code> 比 <code>equal</code> 快并且
大部分的 alist 都使用 symbol 作为键(符号类型都是具有唯一标识的,不会出现名字相
同内容不同的情况). 参见 <a href="#org9fe4c9b">相等断言(Equality Predicates)</a>.
</p>
<pre class="example" id="orgd3ce9e5">
  (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
       ⇒ ((pine . cones) (oak . acorns) (maple . seeds))
  (assq 'pine trees)
       ⇒ (pine . cones)
</pre>
<p>
换句话说,当 alist 中的键可能不是 symbol 的时候, <code>assq</code> 就通常不是很有用了:
</p>
<pre class="example" id="orgcd1477e">
  (setq leaves
	'(("simple leaves" . oak)
	  ("compound leaves" . horsechestnut)))

  (assq "simple leaves" leaves)
       ⇒ Unspecified; might be ‘nil’ or ‘("simple leaves" . oak)’.
  (assoc "simple leaves" leaves)
       ⇒ ("simple leaves" . oak)
</pre></dd>

<dt><code>(alist-get key alist &amp;optional default remove testfn)</code></dt><dd><p>
这个函数与 <code>assq</code>
类似.它通过比较 alist 中元素的 key 来找到第一个联系 <code>(key . value)</code>, 如果找到
了,则返回该联系的 value 值.如果没有找到,函数会返回 default. alist 中的元素与
key 的比较是使用的 testfn 指定的函数,默认是 <code>eq</code>.
</p>

<p>
default 是一个广义变量(参见 <a href="#org728a322">广义变量(Generalized Variables)</a>), 可以用于更改使用
了 <code>setf</code> 的值. 当用它来设置值时,可选参数 remove 非 <code>nil</code> 意味着从 alist 中删
除 key 的联系(如果新值是 <code>eql</code> 于 default 的.)
</p></dd>

<dt><code>(rassq value alist)</code></dt><dd><p>
这个函数返回 alist 中第一个值为 value 的联系. 如果
alist 中没有联系的 CDR <code>eq</code> value, 则返回 <code>nil</code>.
</p>

<p>
<code>rassq</code> 和 <code>assq</code> 类似,除了它会比较每个 alist 联系的 CDR 而不是 CAR. 你可以认
为它是 <code>assq</code> 的逆,用给定值来找键:
</p>
<pre class="example" id="orgffa4e8f">
  (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))

  (rassq 'acorns trees)
       ⇒ (oak . acorns)
  (rassq 'spores trees)
       ⇒ nil
</pre>
<p>
<code>rassq</code> 不能查找储存在元素的 CDR 的 CAR 中的值:
</p>
<pre class="example" id="orgdb6bd6c">
  (setq colors '((rose red) (lily white) (buttercup yellow)))

  (rassq 'white colors)
       ⇒ nil
</pre>
<p>
在这种情况下, 关系 <code>(lily white)</code> 的 CDR 不是符号 <code>white</code> 而是列表
<code>(white)</code>. 如果关系是写成点对形式就更清楚了:
</p>
<pre class="example" id="org100f387">
  (lily white) ≡ (lily . (white))
</pre></dd>

<dt><code>(assoc-default key alist &amp;optional test default)</code></dt><dd><p>
这个函数在 alist 中查找
key 的匹配项. 对于 alist 中的每个元素,它会将 key 与 元素(如果元素是原子)或元素
的 CAR(如果元素是 cons cell) 进行比较, 比较方式是通过调用带两个参数(元素或其
CAR 以及 key)的 call 函数. 参数是按照顺序传递的,因此你可以通过对一个包含有正则
表达式(参见 <a href="#org8dfde4e">正则搜索(Regexp Search)</a>) 的 alist 使用 <code>string-match</code> 来获得有用的
结果. 如果 test 省略或为 <code>nil</code>, 则使用 <code>equal</code> 进行比较.
</p>

<p>
如果一个 alist 元素与 key 匹配了,那么 <code>assoc-default</code> 会基于该元素返回一个值.如
果元素是 cons cell ,那么返回值就是元素的 CDR .否则,返回值就是 default.
</p>

<p>
如果没有一个 alist 元素与 key 匹配,那么该函数返回 <code>nil</code>.
</p></dd>
<dt><code>(copy-alist alist)</code></dt><dd><p>
这个函数返回 alist 的两层深度的副本: 它会为每个联系创
建一个新的副本,所以你可以不用改变原来的联系就能修改新 alist 中的联系.
</p>
<pre class="example" id="orge4d9f01">
  (setq needles-per-cluster
	'((2 . ("Austrian Pine" "Red Pine"))
	  (3 . ("Pitch Pine"))
	  (5 . ("White Pine"))))
  ⇒
  ((2 "Austrian Pine" "Red Pine")
   (3 "Pitch Pine")
   (5 "White Pine"))

  (setq copy (copy-alist needles-per-cluster))
  ⇒
  ((2 "Austrian Pine" "Red Pine")
   (3 "Pitch Pine")
   (5 "White Pine"))

  (eq needles-per-cluster copy)
       ⇒ nil
  (equal needles-per-cluster copy)
       ⇒ t
  (eq (car needles-per-cluster) (car copy))
       ⇒ nil
  (cdr (car (cdr needles-per-cluster)))
       ⇒ ("Pitch Pine")
  (eq (cdr (car (cdr needles-per-cluster)))
      (cdr (car (cdr copy))))
       ⇒ t
</pre>
<p>
下面这个例子显示了 <code>copy-alist</code> 是如何改变副本的关联而没有其他影响的:
</p>
<pre class="example" id="org8d91cca">
  (setcdr (assq 3 copy) '("Martian Vacuum Pine"))
  (cdr (assq 3 needles-per-cluster))
       ⇒ ("Pitch Pine")
</pre></dd>
<dt><code>(assq-delete-all key alist)</code></dt><dd><p>
这个函数从 alist 中删除所有 CAR <code>eq</code> 与 key
的元素,就像你用 <code>delq</code> 来一个个删除所有这些元素一样. 它会返回一个缩短了的
alist, 并且通常会改变 alist 的原本列表结构.要想得到正确的结果,请使用
<code>assq-delete-all</code> 的返回值而不是查看 alist 储存的值
</p>
<pre class="example" id="orge7d7bd8">
  (setq alist (list '(foo 1) '(bar 2) '(foo 3) '(lose 4)))
       ⇒ ((foo 1) (bar 2) (foo 3) (lose 4))
  (assq-delete-all 'foo alist)
       ⇒ ((bar 2) (lose 4))
  alist
       ⇒ ((foo 1) (bar 2) (lose 4))
</pre></dd>
<dt><code>(assoc-delete-all key alist &amp;optional test)</code></dt><dd>这个函数与
<code>(assq-delete-all)</code> 类似,但它接收一个可选参数 test, 这是一个断言函数,用来比较
alist 中的键. 如果 test 省略或为 <code>nil</code> 则其默认为使用 <code>equal</code>. 和
<code>assq-delete-all</code> 一样,这个函数通常会修改 alist 的原本的列表结构.</dd>
<dt><code>(rassq-delete-all value alist)</code></dt><dd>这个函数从 alist 中删除所有 CDR <code>eq</code> 于
value 的元素. 它会返回一个缩短的 alist, 并且通常会改变 alist 的原本列表结
构. <code>rassq-delete-all</code> 和 <code>assq-delete-all</code> 类似,但它比较的是每个 alist 元素
(联系)的 CDR 而不是 CAR.</dd>
<dt>宏 <code>(let-alist alist body)</code></dt><dd><p>
为 alist 中每个用作键的符号创建一个绑定,以点为
前缀. 当访问同一个 alist 的多个条目时这会很有用,最好是通过一个例子来理解:
</p>
<pre class="example" id="org7560033">
  (setq colors '((rose . red) (lily . white) (buttercup . yellow)))
  (let-alist colors
    (if (eq .rose 'red)
	.lily))
       ⇒ white
</pre>
<p>
body 是在编译时进行检查,并且只有出现在 body 中用 "."作为符号名的第一个字符的符
号会被绑定. 查找键是通过 <code>assq</code> 完成的, <code>assq</code> 的返回值的 CDR 会赋值为绑定的值.
</p>

<p>
嵌套的关联列表也是支持的:
</p>
<pre class="example" id="orgefa83dd">
  (setq colors '((rose . red) (lily (belladonna . yellow) (brindisi . pink))))
  (let-alist colors
    (if (eq .rose 'red)
	.lily.belladonna))
       ⇒ yellow
</pre>
<p>
嵌套的 <code>let-alist</code> 也是允许的,但是在内层的 <code>let-alist</code> 代码不能访问外层
<code>let-alist</code> 绑定的变量.
</p></dd>
</dl>
</div>
</div>


<div id="outline-container-orgab3b2c8" class="outline-4">
<h4 id="orgab3b2c8"><span class="done DONE">DONE</span> 属性列表(Property Lists)</h4>
<div class="outline-text-4" id="text-orgab3b2c8">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-07 Thu 21:39]</span></span></li>
</ul>
<p>
成对的元素的列表.
</p>

<p>
属性列表(plist) 是一个配对元素的列表. 每一对都将一个属性名(通常是一个符号)与一个
属性或值联系起来. 下面是一个属性列表的例子:
</p>
<pre class="example" id="orgfd0232d">
     (pine cones numbers (1 2 3) color "blue")
</pre>
<p>
这个属性列表将 <code>pine</code> 和 <code>cones</code>, <code>numbers</code> 和 <code>(1 2 3)</code>, <code>color</code> 和 <code>"blue"</code> 联
系起来. 属性名和属性值可以是任意 Lisp 对象,但是属性名称通常是符号(如上例所示.)
</p>

<p>
属性列表用于多种上下文.例如, 函数 <code>put-text-property</code> 接收一个属性列表作为参数,
指定要应用到字符串或缓冲区中的文本的文本属性和关联值. 参见
<a href="#org05aca52">文本属性(Text Properties)</a>.
</p>

<p>
属性列表的另一个突出用途就是用来储存符号属性. 每个符号占用一个属性的列表,用来记
录关于符号的各种信息;这些属性是以一个属性列表的形式储存的. 参见
<a href="#orgcdc18d7">符号属性(Symbol Properties)</a>
</p>
</div>

<ul class="org-ul">
<li><a id="org19c0032"></a><span class="done DONE">DONE</span> 属性列表和关联列表(Plists and Alists)<br />
<div class="outline-text-5" id="text-org19c0032">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-07 Thu 21:26]</span></span></li>
</ul>
<p>
属性列表和关联列表的优点比较
</p>

<p>
关联列表(参见 <a href="#orgaf2e615">关联表(Association Lists)</a>) 与关联列表非常相似. 与关联列表相比,属性
列表中每对的顺序并不重要,因为属性名必须是有区别的.
</p>

<p>
属性列表比关联列表更适合将信息附加到各种 Lisp 函数名或变量. 如果你的程序将所有的
这样的信息维持在一个关联列表中,检查某个特定 Lisp 函数名或变量时,通常每次都需要搜
索整个列表,这会很慢. 相比之下,如果你将相同的信息维持在一个属性列表中,每次搜索都
只会扫描一个属性列表的长度,通常会很短. 这也是为什么变量的文档是记录在一个名为
<code>variable-documentation</code> 的属性中了. 字节编译器同样也使用属性来记录那些需要特殊
处理的函数.
</p>

<p>
然而,关联列表也有它们自己的优点.取决于你的应用程序,在一个关联列表的前面添加一个
关系可能会比更新一个属性要快. 一个符号的所有属性都是储存在同一个属性列表中,所有,
属性名的不同使用之间有冲突的可能性.(处于这个原因,选择唯一的属性名是一个好主意,例
如属性名以程序的常用名称,变量和函数的前缀) 一个关联列表可能会像堆栈一样使用,其中
的关系则会被压入到列表的前端并在后面丢弃; 这在属性列表中是不可能的.
</p>
</div>
</li>

<li><a id="org2eaa211"></a><span class="done DONE">DONE</span> 访问属性列表(Plist Access)<br />
<div class="outline-text-5" id="text-org2eaa211">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-07 Thu 21:39]</span></span></li>
</ul>
<p>
访问储存在其他位置的属性列表.
</p>

<p>
下面的函数可以用来操作属性列表.他们全都使用 <code>eq</code> 来比较属性名.
</p>

<dl class="org-dl">
<dt><code>(plist-get plist property)</code></dt><dd><p>
这个函数会返回储存在属性列表 plist 中的属性
property 的属性值. 它能接收一个格式错误的 plist 参数. 如果没有在 plist 中找到
property, 则会返回 <code>nil</code> 示例:
</p>
<pre class="example" id="org3eae60e">
  (plist-get '(foo 4) 'foo)
       ⇒ 4
  (plist-get '(foo 4 bad) 'foo)
       ⇒ 4
  (plist-get '(foo 4 bad) 'bad)
       ⇒ nil
  (plist-get '(foo 4 bad) 'bar)
       ⇒ nil
</pre></dd>

<dt><code>(plist-put plist property value)</code></dt><dd><p>
这个函数将 value 储存为属性列表 plist 的
property 属性的属性值.它可能会破坏性地修改 plist, 或是它可能会构造一个新的列表
结构而不改变原来的.函数会返回修改后的属性列表,所以你可以将返回值储存回你获取
plist 的地方. 例如:
</p>
<pre class="example" id="org08d4d7a">
  (setq my-plist (list 'bar t 'foo 4))
       ⇒ (bar t foo 4)
  (setq my-plist (plist-put my-plist 'foo 69))
       ⇒ (bar t foo 69)
  (setq my-plist (plist-put my-plist 'quux '(a)))
       ⇒ (bar t foo 69 quux (a))
</pre></dd>
<dt><code>(lax-plist-get plist property)</code></dt><dd>与 <code>plist-get</code> 类似,除了它会使用 <code>equal</code>
比较属性而不是 <code>eq</code>.</dd>
<dt><code>(lax-plist-put plist property value)</code></dt><dd>与 <code>plist-put</code> 类似,但是它使用
<code>equal</code> 比较属性,而不是 <code>eq</code>.</dd>
<dt><code>(plist-member plist property)</code></dt><dd>如果 plist 中包含有给定的 property, 返回一
个非 <code>nil</code> 值,与 <code>plist-get</code> 不同,这个函数允许你区分一个缺失的属性和一个值为
<code>nil</code> 的属性.返回值实际上是 CAR 为 property 的 plist 的尾部.</dd>
</dl>
</div>
</li>
</ul>
</div>
</div>


<div id="outline-container-orgc0e0dcf" class="outline-3">
<h3 id="orgc0e0dcf"><span class="todo NEXT">NEXT</span> 序列 数组 向量(Sequences Arrays Vectors)</h3>
<div class="outline-text-3" id="text-orgc0e0dcf">
<p>
列表,字符串和向量叫做序列.作用于各种序列的特定函数.向量的描述也在这一部分.
</p>

<p>
序列类型是另外两个 Lisp 对象的并集: 列表和数组. 换句话说,任意列表都是序列,任意数
组也是序列. 所有序列共同拥有的属性是每个序列都是元素的一个有序集合.
</p>

<p>
数组("array") 是一个固定长度的对象,一个元素一个插槽. 访问所有元素需要的时间是一
个恒定值. 数组有 4 种类型: 字符串, 向量, 布尔向量, 字符表.
</p>

<p>
列表是元素的序列,但是列表不是单一的原始对象; 它由 cons cell 组成,一个元素是一个
cons cell. 查找列表中的第 N 个元素需要访问 N 个 cons cel ,因此离列表开头更远的元
素需要更长的访问时间. 但向列表中插入或删除元素是可行的.
</p>

<p>
下面的示意图显示了这些类型的关系:
</p>
<pre class="example" id="org0ad528b">
 _____________________________________________
|                                             |
|          Sequence                           |
|  ______   ________________________________  |
| |      | |                                | |
| | List | |             Array              | |
| |      | |    ________       ________     | |
| |______| |   |        |     |        |    | |
|          |   | Vector |     | String |    | |
|          |   |________|     |________|    | |
|          |  ____________   _____________  | |
|          | |            | |             | | |
|          | | Char-table | | Bool-vector | | |
|          | |____________| |_____________| | |
|          |________________________________| |
|_____________________________________________|
</pre>
</div>

<div id="outline-container-org6f6c0f4" class="outline-4">
<h4 id="org6f6c0f4"><span class="todo NEXT">NEXT</span> 序列函数(Sequence Functions)</h4>
<div class="outline-text-4" id="text-org6f6c0f4">
<p>
接受各种序列的函数.
</p>

<p>
这一小节介绍那些接收任何类型序列的函数
</p>

<dl class="org-dl">
<dt><code>(sequencep object)</code></dt><dd>如果 object 是一个列表,向量,字符串,布尔向量或字符表则
返回 <code>t</code>, 否则返回 <code>nil</code>. 另请参阅下面的 <code>seqp</code> 函数.</dd>
<dt><code>(length sequence)</code></dt><dd><p>
这个函数返回 sequence 中元素的数量.如果参数不是序列或 "
点列表",该函数会发出一个 <code>wrong-type-argument</code> 的错误信号; 如果参数是一个循环
列表,则会发出一个 <code>circular-list</code> 的错误信号. 对于字符表,返回的值总是比最大的
Emacs 字符编码多1.
</p>

<p>
相关函数 <code>safe-length</code> 请参见下面的 <code>safe-legth</code> 的定义.
</p>
<pre class="example" id="orgfe39140">
  (length '(1 2 3))
      ⇒ 3
  (length ())
      ⇒ 0
  (length "foobar")
      ⇒ 6
  (length [1 2 3])
      ⇒ 3
  (length (make-bool-vector 5 nil))
      ⇒ 5
</pre></dd>
</dl>
<p>
关于字符串的字节大小另请参见 <a href="#org263a727">文本表示(Text Representations)</a>.
</p>

<p>
如果你需要计算显示出来字符串的宽度,你应该使用 <code>string-width</code> (参见
<a href="#org09acbcb">显示的文本的大小(Size of Displayed Text)</a>), 而不是 <code>length</code>, 因为 <code>length</code> 只计算
字符的数量,但是不计算每个字符的显示宽度.
</p>
<pre class="example" id="org8b6b2ca">

(string-width "12")     ; 2
(length "12")           ; 2
(string-width "一二")   ; 4
(length "一二")         ; 2
</pre>

<dl class="org-dl">
<dt><code>(length&lt; sequence length)</code></dt><dd>如果 sequence 比 length 短,返回一个非 <code>nil</code> 值.
如果 sequence 是一个很长的列表,这可能比计算 sequence 的长度要更高效.</dd>
<dt><code>(length&gt; sequence length)</code></dt><dd>如果 sequence 比 length 长,返回一个非 <code>nil</code> 值.</dd>
<dt><code>(length= sequence length)</code></dt><dd>如果 sequence 的长度与 length 相等,则返回一个非
<code>nil</code> 值.</dd>
<dt><code>(elt sequence index)</code></dt><dd></dd>

<dt><code>(sequencep object)</code></dt><dd></dd>

<dt><code>(sequencep object)</code></dt><dd></dd>

<dt><code>(sequencep object)</code></dt><dd></dd>

<dt><code>(sequencep object)</code></dt><dd></dd>

<dt><code>(sequencep object)</code></dt><dd></dd>

<dt><code>(sequencep object)</code></dt><dd></dd>

<dt><code>(sequencep object)</code></dt><dd></dd>

<dt><code>(sequencep object)</code></dt><dd></dd>

<dt><code>(sequencep object)</code></dt><dd></dd>

<dt><code>(sequencep object)</code></dt><dd></dd>

<dt><code>(sequencep object)</code></dt><dd></dd>

<dt><code>(sequencep object)</code></dt><dd></dd>

<dt><code>(sequencep object)</code></dt><dd></dd>
</dl>
</div>
</div>
<div id="outline-container-orga89d466" class="outline-4">
<h4 id="orga89d466"><span class="todo NEXT">NEXT</span> 数组(Arrays)</h4>
<div class="outline-text-4" id="text-orga89d466">
<p>
Emacs Lisp 中数组的特性.
</p>
</div>
</div>

<div id="outline-container-orga12e3af" class="outline-4">
<h4 id="orga12e3af"><span class="todo NEXT">NEXT</span> 数组函数(Array Functions)</h4>
<div class="outline-text-4" id="text-orga12e3af">
<p>
数组特有的函数.
</p>
</div>
</div>

<div id="outline-container-org8139b11" class="outline-4">
<h4 id="org8139b11"><span class="todo NEXT">NEXT</span> 向量(Vectors)</h4>
<div class="outline-text-4" id="text-org8139b11">
<p>
Emacs 向量的特殊特性.
</p>
</div>
</div>

<div id="outline-container-org714d4f3" class="outline-4">
<h4 id="org714d4f3"><span class="todo NEXT">NEXT</span> 向量函数(Vectors Functions)</h4>
<div class="outline-text-4" id="text-org714d4f3">
<p>
专门用于向量的函数.
</p>
</div>
</div>

<div id="outline-container-org74ce9c3" class="outline-4">
<h4 id="org74ce9c3"><span class="todo NEXT">NEXT</span> 字符表(Char-Tables)</h4>
<div class="outline-text-4" id="text-org74ce9c3">
<p>
如何使用字符表.
</p>
</div>
</div>

<div id="outline-container-org4b3540d" class="outline-4">
<h4 id="org4b3540d"><span class="todo NEXT">NEXT</span> 布尔向量(Bool-Vectors)</h4>
<div class="outline-text-4" id="text-org4b3540d">
<p>
如何使用布尔向量.
</p>
</div>
</div>

<div id="outline-container-org81013e3" class="outline-4">
<h4 id="org81013e3"><span class="done DONE">DONE</span> Rings</h4>
<div class="outline-text-4" id="text-org81013e3">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-08 Fri 22:22]</span></span></li>
</ul>
<p>
管理固定大小的对象环?
</p>

<p>
一个 "ring" (环?) 是一种固定大小的数据结构,支持插入,删除,旋转,模索引引用和遍历操
作. 一个高效的环数据结构是通过 <code>ring</code> 包来实现的.它提供了这一小节中列出的函数.
</p>

<p>
请注意, Emacs 中的几种环,例如 kill 环和 mark 环,实际上是由简单列表实现的,不是使
用 <code>ring</code> 包;因此下面这些函数无法作用于它们.
</p>

<dl class="org-dl">
<dt><code>(make-ring size)</code></dt><dd>这个函数返回一个可以储存 size 个对象的新环. size 应该要
是一个整数.</dd>
<dt><code>(ring-p object)</code></dt><dd>如果 object 是一个环,则返回 <code>t</code>, 否则返回 <code>nil</code></dd>
<dt><code>(ring-size ring)</code></dt><dd>返回 ring 的最大容量.</dd>
<dt><code>(ring-length ring)</code></dt><dd>返回 ring 当前含有的对象数量.函数的返回值永远不会大于 <code>ring-size</code>.</dd>
<dt><code>(ring-elements ring)</code></dt><dd>返回 ring 中对象的列表,按照最新的对象优先的顺序.</dd>
<dt><code>(ring-copy ring)</code></dt><dd>返回一个新的环,该环是 ring 的副本. 新的环中有着与 ring
<code>eq</code> 的对象</dd>
<dt><code>(ring-empyt-p ring)</code></dt><dd>如果 ring 是空的,返回 <code>t</code> ,否则返回 <code>nil</code>.</dd>
</dl>


<p>
环中最新的元素总是位于索引 0.更高的碎银对应于更旧的元素.索引是以环的长度为模计算
的. 索引 -1 对应于最旧的元素, -2 对应第二旧的元素,以此类推.
</p>
<dl class="org-dl">
<dt><code>(ring-ref ring index)</code></dt><dd>返回 ring 中在索引 index 处找到的对象. index 可以是
负数或比环的长度还大. 如果 ring 是空的, <code>ring-ref</code> 会发出错误信号.</dd>
<dt><code>(ring-insert ring object)</code></dt><dd>该函数将 object 插入到 ring 中,让 object 成为最
新的元素,并返回 object. 如果环已经满了,插入操作会移除最旧的元素来为新元素挪出
空间.</dd>
<dt><code>(ring-remove ring &amp;optional index)</code></dt><dd>从 ring 中移除对象,并返回被移除的对象.
参数 index 指定要移除的条目; index 为 <code>nil</code> ,意味着移除最旧的条目. 如果 ring
是空的, <code>ring-remove</code> 会发出错误信号.</dd>
<dt><code>(ring-insert-at-beginning ring object)</code></dt><dd>该函数将 object 插入到环中,并将其
视为最旧的元素,返回值并不重要.
如果 ring 是满的,该函数会为要插入的元素移除最新的元素来挪出空间.</dd>
<dt><code>(ring-resize ring size)</code></dt><dd>将 ring 的大小设置为 size. 如果新的大小比原来更小,那
么环中最旧的元素会被丢弃.</dd>
</dl>


<p>
如果你很小心的不超过环的大小,那么你可以将环作为先进先出的队列来使用. 例如:
</p>
<pre class="example" id="org8de0b8d">
(let ((fifo (make-ring 5)))
  (mapc (lambda (obj) (ring-insert fifo obj))
        '(0 one "two"))
  (list (ring-remove fifo) t
        (ring-remove fifo) t
        (ring-remove fifo)))
     ⇒ (0 t one t "two")
</pre>
</div>
</div>
</div>


<div id="outline-container-org0dc4d87" class="outline-3">
<h3 id="org0dc4d87"><span class="todo TODO">TODO</span> 记录(Records)</h3>
<div class="outline-text-3" id="text-org0dc4d87">
<p>
具有用户定义的类型的符合对象.
</p>
</div>
</div>
<div id="outline-container-orgf516f8b" class="outline-3">
<h3 id="orgf516f8b"><span class="todo TODO">TODO</span> 哈希表(Hash Tables)</h3>
<div class="outline-text-3" id="text-orgf516f8b">
<p>
非常快速的查询表.
</p>
</div>
<div id="outline-container-org06d4537" class="outline-4">
<h4 id="org06d4537">TODO</h4>
</div>
<div id="outline-container-org500d54b" class="outline-4">
<h4 id="org500d54b">TODO</h4>
</div>
<div id="outline-container-orgdd7fefe" class="outline-4">
<h4 id="orgdd7fefe">TODO</h4>
</div>
<div id="outline-container-orgdc3fd16" class="outline-4">
<h4 id="orgdc3fd16"><span class="todo TODO">TODO</span> 其他哈希(Other Hash)</h4>
<div class="outline-text-4" id="text-orgdc3fd16">
<p>
杂项
</p>
</div>
</div>
</div>
<div id="outline-container-orgf14e561" class="outline-3">
<h3 id="orgf14e561"><span class="todo TODO">TODO</span> 符号(Symbols)</h3>
<div class="outline-text-3" id="text-orgf14e561">
<p>
符号唯一地表示名称.
</p>
</div>
<div id="outline-container-org971770a" class="outline-4">
<h4 id="org971770a"><span class="todo TODO">TODO</span> 符号组成(Symbol Components)</h4>
<div class="outline-text-4" id="text-org971770a">
<p>
符号有名字,值,函数定义以及属性列表.
</p>
</div>
</div>
<div id="outline-container-org9900be8" class="outline-4">
<h4 id="org9900be8">TODO</h4>
</div>

<div id="outline-container-org5f3730c" class="outline-4">
<h4 id="org5f3730c"><span class="todo TODO">TODO</span> 创建符号(Creating Symbols)</h4>
<div class="outline-text-4" id="text-org5f3730c">
<p>
符号是如何保持唯一性的.
</p>
</div>
</div>

<div id="outline-container-orgcdc18d7" class="outline-4">
<h4 id="orgcdc18d7"><span class="todo TODO">TODO</span> 符号属性(Symbol Properties)</h4>
<div class="outline-text-4" id="text-orgcdc18d7">
<p>
每个符号都有一个用来记录各种信息的属性列表.
</p>
</div>
</div>
</div>


<div id="outline-container-org8786ce9" class="outline-3">
<h3 id="org8786ce9"><span class="done DONE">DONE</span> 求值(Evaluation)</h3>
<div class="outline-text-3" id="text-org8786ce9">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-12 Tue 19:52]</span></span></li>
</ul>
<p>
Lisp 表达式是如何求值的.
</p>

<p>
Emacs Lisp 中的求值是由 "Lisp 解释器" 执行的, "Lisp 解释器"  是一个接收 Lisp 对
象作为输入并计算其"作为表达式的值" 的程序. 求值是如何进行的取决于对象的数据类型,
并遵循这一章节描述的规则. 解释器会自动执行对你程序的部分进行求值,但是也可以通过
Lisp 原始函数 <code>eval</code> 来显式调用.
</p>
</div>

<div id="outline-container-org869e90d" class="outline-4">
<h4 id="org869e90d"><span class="done DONE">DONE</span> Eval 简介(Intro Eval)</h4>
<div class="outline-text-4" id="text-org869e90d">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-10 Sun 15:53]</span></span></li>
</ul>
<p>
Lisp 解释器或者也叫求值器,是 Emacs 的一部分,用来计算给定的表达式的值. 当一个由
Lisp 编写的函数被调用时,求值器就会通过对函数体中的表达式进行求值来计算函数的值.
因此,运行任意的 Lisp 程序实际上意味着运行 Lisp 解释器.
</p>

<p>
一个用于求值的 Lisp 对象被叫做 "form" 或 "expression" <sup><a id="fnr.7" class="footref" href="#fn.7" role="doc-backlink">7</a></sup> (表达式). 表达式就是
数据对象而不仅仅是文本,这是 Lisp 类编程语言和典型编程语言之间的基本区别之一. 所
有对象都可以被求值,但在实践中,只有数字,符号,列表和字符串经常被求值.
</p>

<p>
在后续的小节中,我们会描述对每种表达式来说,求值的细节.
</p>

<p>
读取一个 Lisp 表达式然后对该表达式求值是很常见的,但是读取和求值是单独的活动,两者
都可以单独进行. 读取操作本质上不对任何东西求值;它将 Lisp 对象的打印表示转换成该
对象本身. 这个对象是一个要求值的表达式或是服务于一些完全不同的用途,取决于 <code>read</code>
的调用者是否指定相应操作. 参见 <a href="#orgdd8af85">输入函数(Input Functions)</a>.
</p>

<p>
求值是一个递归过程,而且对一个表达式求值经常涉及到对表达式里的部分求值.例如,当你
执行一个函数调用的表达式,例如 <code>(car x)</code>, Emacs 首先会对参数(子表达式 <code>x</code>)求值.参
数求值之后, Emcas 会 <code>执行</code> 函数 <code>(car)</code> ,如果函数是由 Lisp 编写的,那么执行函数
是通过对函数体求值来进行的(然而,在这个例子里, <code>car</code> 不是一个 Lisp 函数;他是由 C
实现的原始函数).更多关于函数和函数调用的信息, 参见 <a href="#org5921345">函数(Functions)</a>.
</p>

<p>
求值是在一个叫做 "environment"(环境) 的上下文中进行的, 这个 "环境" 是由所有 Lisp
变量的当前值和绑定组成的(参见 <a href="#org7e787fa">变量(Variables)</a>). <sup><a id="fnr.8" class="footref" href="#fn.8" role="doc-backlink">8</a></sup> 每当一个表达式指向一个变量且没有为其创建新的绑定
的时候,该变量求值的结果是当前环境的给定值. 对一个表达式进行求值也可能通过绑定变
量来暂时改变环境.(参见 <a href="#org6826578">局部变量(Local Variables)</a>)
</p>

<p>
表达式求值也可能导致持久的改变;这种变化叫做 "副作用". 一个表达式产生副作用的例子
是 <code>(setq foo 1)</code>.
</p>

<p>
不要将求值与命令按键解释混淆. 编辑器命令循环使用已激活的按键映射来将键盘输入转换
乘命令(一种可以交互式调用的函数),然后使用 <code>call-interactively</code> 来执行该命令. 如
果命令是由 Lisp 编写的,执行命令通常涉及到求值;然而这一步不被认为是命令按键解释的
一部分. 参见 <a href="#org6ebe914">命令循环(Command Loop)</a>.
</p>
</div>
</div>

<div id="outline-container-org0d16480" class="outline-4">
<h4 id="org0d16480"><span class="done DONE">DONE</span> 表达式(Forms)</h4>
<div class="outline-text-4" id="text-org0d16480">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-12 Tue 19:52]</span></span></li>
</ul>
<p>
各种对象是如何求值的
</p>

<p>
一个用于求值的 Lisp 对象被叫做一个 "表达式". Emacs 如何对表达式求值取决于其数据
类型. Emacs 有三种求值方式不同的表达式: 符号, 列表以及所有其他类型. 这一节将一个
个描述所有这三种类型,会先从其他类型开始,这种类型是自执行的表达式.
</p>
</div>

<ul class="org-ul">
<li><a id="orgc883584"></a><span class="done DONE">DONE</span> 自执行表达式(Self-Evaluating Forms)<br />
<div class="outline-text-5" id="text-orgc883584">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-10 Sun 16:13]</span></span></li>
</ul>
<p>
求值结果就是他们自身的表达式.
</p>

<p>
一个"自执行表达式"就是任意非列表或非符号的表达式. 自执行表达式的求值结果就是他们
本身: 求值的结果与被求值的是相同的对象. 因此数字 25 的求值结果为 25, 字符串
"foo" 的求值结果为字符串 "foo". 同样地,对向量的求值也不会造成对向量元素的求值,而
是返回一个内容不变的同一向量.
</p>
<pre class="example" id="org7a53b5c">
'123               ; A number, shown without evaluation.
     ⇒ 123
123                ; Evaluated as usual—result is the same.
     ⇒ 123
(eval '123)        ; Evaluated "by hand"—result is the same.
     ⇒ 123
(eval (eval '123)) ; Evaluating twice changes nothing.
     ⇒ 123
</pre>

<p>
一个自执行的表达式生成的值会成为程序的一部分,你不用该试图使用 <code>setcat</code>, <code>aset</code>
或类似操作来修改它. Lisp 解释器可能会统一保存你的程序中自执行表达式生成的值,因此
这些常量可能结构共享.参见 <a href="#org73c2bd1">易变性(Mutability)</a>.
</p>

<p>
在 Lisp 代码中编写数字,字符,字符串,甚至向量是很常见的, 这利用了它们是自执行的优
势. 然而,对于那些缺乏读取语法的类型来说,这样做就很罕见了,因为没有一种方式能以文
本形式编写它们. 通过 Lisp 程序可以构造包含这些类型的表达式. 下面是一个示例:
</p>
<pre class="example" id="org115da90">
;; Build an expression containing a buffer object.
(setq print-exp (list 'print (current-buffer)))
     ⇒ (print #&lt;buffer eval.texi&gt;)
;; Evaluate it.
(eval print-exp)
     ⊣ #&lt;buffer eval.texi&gt;
     ⇒ #&lt;buffer eval.texi&gt;

</pre>
</div>
</li>

<li><a id="org59ab721"></a><span class="done DONE">DONE</span> 符号表达式(Symbol Forms)<br />
<div class="outline-text-5" id="text-org59ab721">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-10 Sun 16:26]</span></span></li>
</ul>
<p>
符号作为变量求值.
</p>

<p>
当一个符号进行求值时,它会被当作是一个变量处理. 如果有返回值,则返回值就是该"变量"
的值. 如果符号作为一个变量没有值,那么 Lisp 解释器会发出一个错误信号. 更多关于使
用变量的信息,参见 <a href="#org7e787fa">变量(Variables)</a>.
</p>

<p>
在下面的例子中,我们使用 <code>setq</code> 来设置一个符号的值. 然后我们对这个符号求值,并获取
用 <code>setq</code> 储存的值.
</p>
<pre class="example" id="org82c0316">
(setq a 123)
     ⇒ 123
(eval 'a)
     ⇒ 123
a
     ⇒ 123
</pre>

<p>
符号 <code>t</code> 和 <code>nil</code> 是特殊处理的,因此, <code>nil</code> 的值永远是 <code>nil</code>, <code>t</code> 的值永远是 <code>t</code>;
你不能将他们设置或绑定为其他值.因此, 即使 <code>eval</code> 将它们与其他任意符号同等对待,这
两个符号也表现得就像是自执行的表达式一样. 符号名以 <code>:</code> 开头的符号也是以同样的方
式视为"自执行"; 同样地,其值通常不能被改变. 参见 <a href="#orgde44202">常量(Constant Variable)</a>.
</p>
</div>
</li>

<li><a id="orgee64c9e"></a><span class="done DONE">DONE</span> 列表分类(Classifying Lists)<br />
<div class="outline-text-5" id="text-orgee64c9e">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-10 Sun 16:31]</span></span></li>
</ul>
<p>
如果区分各种列表表达式
</p>

<p>
根据列表的第一个元素,一个非空列表的表达式可能是函数调用,宏调用或特殊表达式. 这三
种表达式以不同方式求值,下面有描述. 列表中剩下的元素组成了函数,宏或特殊表达式的参
数.
</p>

<p>
非空列表的求值中,第一步就是检查列表的第一个元素. 这个元素单独决定了列表是何种表
达式以及列表的剩下部分会如何进行处理. 第一个元素不会被求值,因为它可能是某些 Lisp
方言(例如 Scheme)编写的.
</p>
</div>
</li>
<li><a id="org70e8bb7"></a><span class="done DONE">DONE</span> 函数指向(Function Indirection)<br />
<div class="outline-text-5" id="text-org70e8bb7">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-10 Sun 17:03]</span></span></li>
</ul>
<p>
当符号作为一个列表的 CAR 出现时,我们通过符号找到真正的函数.
</p>

<p>
如果列表的第一个元素是一个符号,那么求值过程会检查该符号的函数单元,并使用函数单元
的内容,而不是使用最初的符号. 如果函数单元的内容是其他的符号,这个叫做 "符号函数指
向" 的过程会一直重复,直到它获得一个非符号内容. 更多关于符号函数指向的信息,请参见
<a href="#orgb7df300">函数名(Function Names)</a>.
</p>

<p>
在一个符号的函数单元指向相同符号时,这个过程的一种可能的后果就是一个无限循环. 否
则的话,我们最终会得到一个非符号,它应该是一个函数或其他适合的对象.
</p>

<p>
更精确地说,我们目前有 Lisp 函数(lambda 表达式), 字节码函数, 原始函数, Lisp 宏,
特殊表达式或自加载对象.每一个这些类型是下面的小节描述的情况. 如果找到的对象不是
这些类型中的某一个,那么 Emacs 会发出一个 <code>invalid-function</code> 的错误信号.
</p>

<p>
下面的示例阐述了符号指向的过程. 我们使用 <code>fset</code> 来设置一个符号的函数单元,使用
<code>symbol-function</code> 来获取函数单元的内容(参见 <a href="#org86bef4b">函数单元(Function Cells)</a>). 具体来说,
我们将符号 <code>car</code> 储存到 <code>first</code> 函数单元,并将 <code>first</code> 符号储存到 <code>erste</code> 函数单
元.
</p>
<pre class="example" id="orgce6ae2a">
;; Build this function cell linkage:
;;   -------------       -----        -------        -------
;;  | #&lt;subr car&gt; | &lt;-- | car |  &lt;-- | first |  &lt;-- | erste |
;;   -------------       -----        -------        -------
(symbol-function 'car)
     ⇒ #&lt;subr car&gt;
(fset 'first 'car)
     ⇒ car
(fset 'erste 'first)
     ⇒ first
(erste '(1 2 3))   ; Call the function referenced by ‘erste’.
     ⇒ 1
</pre>
<p>
相比之下,下面的例子没有任何符号函数指向就调用了一个函数,因为第一个元素是一个匿名
Lisp 函数,不是一个符号.
</p>
<pre class="example" id="org555652c">
((lambda (arg) (erste arg))
 '(1 2 3))
     ⇒ 1
</pre>
<p>
内置函数 <code>indirect-function</code> 提供了一种容易的方法来显式执行符号函数指向.
</p>


<dl class="org-dl">
<dt><code>(indirect-function function &amp;optional noerror)</code></dt><dd><p>
这个函数返回 function 的意
义作为函数,如果 function 是一个符号, 那么它会找到 function 的函数定义,并从该值
开始. 如果 function 不是一个符号,那么它返回 function 本身.
</p>

<p>
如果最后找到的符号是未绑定的,这个函数会返回 <code>nil</code>. 如果在符号链中有循环,那么这
个函数会发出一个 <code>cyclic-function-indirection</code> 的错误信号.
</p>

<p>
可选参数 noerror 已经弃用了, 保留它是为了向下兼容,没有实际效果.
</p>

<p>
下面是如何在 Lisp 中定义 <code>indirect-function</code> 的代码:
</p>
<pre class="example" id="orge790a9d">
  (defun indirect-function (function)
    (if (and function
	     (symbolp function))
	(indirect-function (symbol-function function))
      function))

</pre></dd>
</dl>
</div>
</li>


<li><a id="org5432328"></a><span class="done DONE">DONE</span> 函数表达式(Function Forms)<br />
<div class="outline-text-5" id="text-org5432328">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-10 Sun 19:53]</span></span></li>
</ul>
<p>
调用函数的表达式.
</p>

<p>
如果被求值的列表的第一个元素是一个 Lisp 函数对象, 字节码对象或原始函数对象,那么
该列表就是一个 "函数调用". 例如, 下面是一个对函数 <code>+</code> 的调用:
</p>
<pre class="example" id="org206de04">
     (+ 1 x)
</pre>

<p>
执行一个函数单元的第一步是对列表中剩余元素按从左到右顺序进行求值. 求值结果就是实
际参数,一个列表元素一个值. 下一步就是带着这个参数列表来调用函数, 事实上是使用函
数 <code>apply</code> 来调用(参见 <a href="#orgfb3c20f">调用函数(Calling Functions)</a>). 如果函数是用 Lisp 编写的,
参数就是用来绑定函数的参数变量的(参见 <a href="#org8ae8a6d">Lambda 表达式(Lambda Expressions)</a>); 然后函
数体中的表达式会按顺序求值, 最后一个函数体的表达式的值会作为函数调用的值(返回值).
</p>
</div>
</li>
<li><a id="org815e999"></a><span class="done DONE">DONE</span> 宏表达式(Macro Forms)<br />
<div class="outline-text-5" id="text-org815e999">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-10 Sun 20:08]</span></span></li>
</ul>
<p>
调用宏的表达式.
</p>

<p>
如果要求值的列表的第一个元素是一个宏对象,那么该列表就是一个"宏调用". 当宏调用进
行求值时,列表中剩下的元素最初不会被求值. 而是这些元素自身会被用作宏的参数. 宏的
定义会计算一个叫做宏的 "扩展" 的替换表达式, 该表达式会在替换原表达式进行求值. 这
个扩展可以是任意形式的表达式:自执行变量,符号或列表. 如果扩展本身是一个宏调用,这
个扩展的过程会一直重复,直到出现一些其他形式的表达式结果.
</p>

<p>
宏调用的一般求值由扩展的求值结束. 然而,宏扩展不一定会立即求值,或是根本不求值,因
为其他程序也会扩展宏调用,并且他们也可能会或可能不会对扩展求值.
</p>

<p>
通常来讲,参数表达式不会被求值后作为 <b>计算</b> 宏扩展的一部分,而是作为扩展的一部分,
因此他们会在扩展被求值时进行计算.
</p>

<p>
例如,给定如下的一个宏定义:
</p>
<pre class="example" id="orgabf8e73">
(defmacro cadr (x)
  (list 'car (list 'cdr x)))
</pre>
<p>
形如 <code>(cadr (assq 'handler list))</code> 的表达式就是一个宏调用了,其扩展为:
</p>
<pre class="example" id="orgce4fee2">
(car (cdr (assq 'handler list)))
</pre>
<p>
请注意, <code>(assq 'handler list)</code> 的参数是出现在扩展中的.
</p>

<p>
关于 Emacs Lisp 宏的完整描述,请参见 <a href="#org15d607f">宏(Macros)</a>.
</p>
</div>
</li>

<li><a id="org1ce4062"></a><span class="done DONE">DONE</span> 特殊表达式(Special Forms)<br />
<div class="outline-text-5" id="text-org1ce4062">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-10 Sun 20:44]</span></span></li>
</ul>
<p>
特殊表达式是特殊的原始函数,它们中大部分都极其重要
</p>

<p>
"特殊表达式" 是被特殊标记的原始函数,这样他们的参数就不会全部求值. 大部分的特殊表
达式定义控制结构或执行变量绑定(这些是函数不能做到的)
</p>

<p>
每个特殊表达式都有自己的规则,规定了哪些参数要求值,哪些参数不用求值直接使用. 某个
特定参数是否被求值可能取决于其他参数的求值结果.
</p>

<p>
如果一个表达式的第一个符号是特殊表达式的符号,那么该表达式就应该遵循该特殊表达式
的规则; 否则, Emcas 的行为定义就是不明确的(尽管它不会崩溃). 例如,
<code>((lambda (x) x . 3) 4)</code> 包含了一个以 lambda 开头的表达式,但是不是一个完好定义的
lambda 表达式,因此 Emacs 可能会发出错误信号,也可能会返回 3 或 4 或 <code>nil</code>, 又或者
表现为其他行为.
</p>

<dl class="org-dl">
<dt><code>(special-form-p object)</code></dt><dd>这个断言是测试其参数是否为一个特殊表达式的,如果是
则返回 <code>t</code>, 否则,返回 <code>nil</code>.</dd>
</dl>


<p>
下面是一个 Emacs Lisp 中所有特殊表达式的列表,按照字母表顺序排列,带有每个项目在哪
里描述的引用.
</p>

<dl class="org-dl">
<dt><code>and</code></dt><dd>参见 <a href="#org95c036a">组合条件(Combining Conditions)</a>.</dd>
<dt><code>catch</code></dt><dd>参见 <a href="#org67133ff">Catch and Throw</a>.</dd>
<dt><code>cond</code></dt><dd>参见 <a href="#orgaa372a6">条件(Conditionals)</a>.</dd>
<dt><code>condition-case</code></dt><dd>参见 <a href="#org715ee31">处理错误(Handling Errors)</a></dd>
<dt><code>defconst</code></dt><dd>参见 <a href="#org01c338c">定义变量(Defining Variables)</a>.</dd>
<dt><code>defvar</code></dt><dd>参见 <a href="#org01c338c">定义变量(Defining Variables)</a>.</dd>
<dt><code>function</code></dt><dd>参见 <a href="#orgbf27a2a">匿名函数(Anonymous Functions)</a>.</dd>
<dt><code>if</code></dt><dd>参见 <a href="#orgaa372a6">条件(Conditionals)</a>.</dd>
<dt><code>interactive</code></dt><dd>参见 <a href="#org30f4580">交互式调用(Interactive Call)</a>.</dd>
<dt><code>lambda</code></dt><dd>参见 <a href="#org8ae8a6d">Lambda 表达式(Lambda Expressions)</a>.</dd>
<dt><code>let</code></dt><dd></dd>

<dt><code>let*</code></dt><dd>参见 <a href="#org6826578">局部变量(Local Variables)</a>.</dd>
<dt><code>or</code></dt><dd>参见 <a href="#org95c036a">组合条件(Combining Conditions)</a>.</dd>
<dt><code>prog1</code></dt><dd></dd>

<dt><code>prog2</code></dt><dd></dd>

<dt><code>progn</code></dt><dd>参见 <a href="#org2916e3a">顺序执行(Sequencing)</a>.</dd>
<dt><code>quote</code></dt><dd>参见 <a href="#orgc309393">引用(Quoting)</a> .</dd>
<dt><code>save-current-buffer</code></dt><dd>参见 <a href="#org75e596b">当前缓冲区(Current Buffer)</a>.</dd>
<dt><code>save-excursion</code></dt><dd>参见 <a href="#orgb7f4793">Excursions</a>.</dd>
<dt><code>save-restriction</code></dt><dd>参见 <a href="#org3ea3146">Narrowing</a>.</dd>
<dt><code>setq</code></dt><dd>参见 <a href="#orgbd90c15">设置变量(Setting Variables)</a>.</dd>
<dt><code>setq-default</code></dt><dd>参见 <a href="#org85bfae2">Creating Buffer-Local</a>.</dd>
<dt><code>unwind-protect</code></dt><dd>参见 <a href="#org61d300d">非局部退出(Nonlocal Exits)</a>.</dd>
<dt><code>while</code></dt><dd>参见 <a href="#orgcf83ad9">迭代(Iteration)</a>.</dd>
</dl>


<blockquote>
<p>
Common Lisp 提示: 以下是 Emacs Lisp 和 Common Lisp 中特殊表达式的一些比
较. <code>setq</code>, <code>if</code> 和 <code>catch</code> 在 Emacs Lisp 和 Common Lisp 中都是特殊表达
式. <code>save-excursion</code> 是 Emacs Lisp 中的特殊表达式,在 Common Lisp 中不存在. <code>throw</code>
是 Common Lisp 中的特殊表达式(因为它必需要能够抛出多个值),但是在 Emacs Lisp 中是
一个函数(没有多个值).
</p>
</blockquote>
</div>
</li>

<li><a id="orga109dc9"></a><span class="done DONE">DONE</span> 自加载(Autoloading)<br />
<div class="outline-text-5" id="text-orga109dc9">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-10 Sun 21:27]</span></span></li>
</ul>
<p>
设置为加载包含着其实际定义的文件的函数
</p>

<p>
自动加载的特性允许你调用一个函数定义还没加载到 Emacs 中的函数或宏. 它指定了哪个
文件含有定义. 当一个自加载对象作为一个符号的函数定义出现时,将该符号作为函数调用
会自动加载指定的文件;然后会调用从该文件中加载的真实的定义.安排一个自动加载对象作
为符号的函数定义出现的方式在 <a href="#org910e488">自动加载(Autoload)</a> 有描述.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgc309393" class="outline-4">
<h4 id="orgc309393"><span class="done DONE">DONE</span> 引用(Quoting)</h4>
<div class="outline-text-4" id="text-orgc309393">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-10 Sun 21:26]</span></span></li>
</ul>
<p>
特殊表达式 <code>quote</code> 返回它的单个参数,如编写时一样,不会对其进行求值. 这提供了一种
在程序中包含不是自执行对象的常量符号和列表的方式.(将自执行对象,例如数字,字符串和
向量引用起来是没有必要的)
</p>

<dl class="org-dl">
<dt><code>(quote object)</code></dt><dd>这个特殊表达式返回 object, 而不对它求值. 返回值可能会被共
享,并且不应该被修改. 参见 <a href="#orgc883584">自执行表达式(Self-Evaluating Forms)</a>.</dd>
</dl>


<p>
因为 <code>quote</code> 在程序中使用的如此频繁, Lisp 为其提供了一种便利的读取语法. 一个撇号
( <code>'</code> ) 后面跟上一个 Lisp 对象(在读取语法中) 会扩展成为一个列表,其第一个元素是
<code>quote</code> ,第二个元素是该 Lisp 对象. 因此, 读取语法 <code>'x</code>  是 <code>(quote x)</code> 的缩写.
</p>

<p>
下面是一些使用 <code>quote</code> 的表达式的示例:
</p>
<pre class="example" id="org7c93672">
(quote (+ 1 2))
     ⇒ (+ 1 2)
(quote foo)
     ⇒ foo
'foo
     ⇒ foo
''foo
     ⇒ 'foo
'(quote foo)
     ⇒ 'foo
['foo]
     ⇒ ['foo]
</pre>

<p>
尽管表达式 <code>(list '+ 1 2)</code> 和 <code>'(+ 1 2)</code> 都生成一个等于 <code>(+ 1 2)</code> 的列表,前者生
成的是一个崭新生成的可变列表,而后者生成的是一个由 cons cell 构建的可能会共享并且
不应该被改变的列表. 参见 <a href="#orgc883584">自执行表达式(Self-Evaluating Forms)</a>.
</p>

<p>
其他的引用结构,包括 <code>function</code> (参见 <a href="#orgbf27a2a">匿名函数(Anonymous Functions)</a>) 和 <code>`</code> (参见
<a href="#orgd7832f2">反引用(Backquote)</a>, 前者会生成一个要进行编译的由 Lisp 编写的匿名 lambda 表达式,后
者用来只引用列表的一部分,并计算和替换其他部分.
</p>
</div>
</div>

<div id="outline-container-orgd7832f2" class="outline-4">
<h4 id="orgd7832f2"><span class="done DONE">DONE</span> 反引用(Backquote)</h4>
<div class="outline-text-4" id="text-orgd7832f2">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-10 Sun 21:50]</span></span></li>
</ul>
<p>
更容易的列表结构构造.
</p>

<p>
"反引用构造" (Backquote constructs) 能让你引用一个列表,但有选择性地对列表元素求
值. 在最简单的例子中,它和特殊表达式 <code>quote</code> 是相等的(在上一章节中描述的; 参见
<a href="#orgc309393">引用(Quoting)</a>). 例如,下面两个表达式生成相同的结果:
</p>
<pre class="example" id="org17e233d">
`(a list of (+ 2 3) elements)
     ⇒ (a list of (+ 2 3) elements)
'(a list of (+ 2 3) elements)
     ⇒ (a list of (+ 2 3) elements)
</pre>
<p>
要反引用的参数中的特殊记号 <code>,</code> 表明一个值不是常量. Emcas Lisp 求值器会对 <code>,</code> 的
参数求值,并将值放入列表结构中:
</p>
<pre class="example" id="org8fed2bd">
`(a list of ,(+ 2 3) elements)
     ⇒ (a list of 5 elements)
</pre>
<p>
使用 <code>,</code> 的替换在列表结构的更深层级也是允许的. 例如:
</p>
<pre class="example" id="orga66dd4e">
`(1 2 (3 ,(+ 4 5)))
     ⇒ (1 2 (3 9))
</pre>

<p>
你也可以使用特殊记号 <code>,@</code> 将求值结果拼接到结果列表中. 要粘贴的列表的元素会成为结
果列表的其他元素相同层级的元素. 没有使用 <code>`</code> 的相同代码通常是无法读取的. 下面是
一些例子:
</p>
<pre class="example" id="orgcf46219">
(setq some-list '(2 3))
     ⇒ (2 3)
(cons 1 (append some-list '(4) some-list))
     ⇒ (1 2 3 4 2 3)
`(1 ,@some-list 4 ,@some-list)
     ⇒ (1 2 3 4 2 3)

(setq list '(hack foo bar))
     ⇒ (hack foo bar)
(cons 'use
  (cons 'the
    (cons 'words (append (cdr list) '(as elements)))))
     ⇒ (use the words foo bar as elements)
`(use the words ,@(cdr list) as elements)
     ⇒ (use the words foo bar as elements)
</pre>

<p>
如果一个反引用构造的子表达式没有替换或拼接,那它的作用就像 <code>quote</code> 一样,因为它产
生的是可能会被共享且不应该被修改的 cons cell ,向量,和字符串. 参见
<a href="#orgc883584">自执行表达式(Self-Evaluating Forms)</a>.
</p>
</div>
</div>

<div id="outline-container-org823d079" class="outline-4">
<h4 id="org823d079"><span class="done DONE">DONE</span> 执行(Eval)</h4>
<div class="outline-text-4" id="text-org823d079">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-12 Tue 19:17]</span></span></li>
</ul>
<p>
如何显式调用 Lisp 解释器.
</p>

<p>
大多数情况下,表达式是自动求值的,因为它们是出现在一个正在运行的程序中的. 在很少的
情况下,你可能需要编写一种对表达式的求值是在运行时计算的代码,例如,在从被编辑的文
本中读取或从属性列表中获取表达式. 在这些情况下,请使用 <code>eval</code> 函数. 通常情况下,
<code>eval</code> 是不需要的而会使用其他函数. 例如,要从变量中获取值,尽管 <code>eval</code> 能用,但是
<code>symbol-value</code> 是更何时的选择; 或者,与其将表达式储存在一个后续需要 <code>eval</code> 的属性
列表中,不如储存在后续要传递给 <code>funcall</code> 的函数中.
</p>

<p>
这一小节描述的函数和变量对表达式求值,指定求值过程的限制,或记录最近的返回值. 加载
一个文件同样也执行求值(参见 <a href="#orgfe470e1">加载(Loading)</a> ).
</p>

<p>
通常将函数储存在数据结构中,并使用 <code>funccall</code> 或 <code>apply</code> 调用它,比储存表达式到数
据结构中并对其求值要更干净,更灵活. 使用函数提供了给给它们传递信息作为参数的能力.
</p>

<dl class="org-dl">
<dt><code>(eval from &amp;optional lexical)</code></dt><dd><p>
这是表达式求值的基础函数. 它会在当前环境中
对 form 求值,并返回求值结果. form 对象的类型决定了它是如何被求值的. 参见
<a href="#org0d16480">表达式(Forms)</a>.
</p>

<p>
参数 lexical 指定了局部变量的范围规则(参见 <a href="#orgc0f0806">变量范围(Variable Scoping)</a>). 如果它
被省略或为 <code>nil</code>, 那就意味着使用默认的动态范围规则来对 form 求值. 如果它是
<code>t</code>, 那就意味着使用词法范围规则. lexical 的值也可以是一个非空的关联表,用来为词
法绑定指定一个特定的 "词法环境"; 但是,这个特性只在特殊用途时有用,例如在 Emacs
Lisp 调试器中. 参见 <a href="#orge2ebb68">词法绑定(Lexical Bindings)</a>.
</p>

<p>
因为 <code>eval</code> 是一个函数,那么出现在 <code>eval</code> 调用中的参数表达式会被两次求值: 第一
次是在 <code>eval</code> 真正调用前的准备,第二次是 <code>eval</code> 函数自身. 下面是一个例子:
</p>
<pre class="example" id="org496527c">
  (setq foo 'bar)
       ⇒ bar
  (setq bar 'baz)
       ⇒ baz
  ;; Here ‘eval’ receives argument ‘foo’
  (eval 'foo)
       ⇒ bar
  ;; Here ‘eval’ receives argument ‘bar’, which is the value of ‘foo’
  (eval foo)
       ⇒ baz
</pre>
<p>
当前对 <code>eval</code> 的有效调用的次数被限制为了 <code>max-lisp-eval-depth</code> (见下文).
</p>
<blockquote>
<p>
两次求值的理解: 函数执行的第一步是对参数求值(参见 <a href="#org5432328">函数表达式(Function Forms)</a>),
eval 是一个函数表达式,因此执行 eval 的第一步就是对参数求值,而 eval 本身的作用
是对参数求值,因此在真正执行 eval 时会对参数第二次求值.
</p>
</blockquote></dd>

<dt>命令 <code>(eval-region start end &amp;optional stream read-function)</code></dt><dd><p>
这个函数会对
当前缓冲区中由位置 start 和 end 定义的区域里的表达式求值. 它从区域中读取表达式,并
且对他们调用 <code>eval</code> 直到到达区域的结束,或者直到发出一个错误信号以及未处理的错
误.
</p>

<p>
默认设置下, <code>eval-region</code> 不会产生任何输出. 然而, 如果 stream 是非 <code>nil</code> 的,
那么输出函数产生的所有输出(参见 <a href="#orge0896d7">输出函数(Output Functions)</a>),以及来自区域中表达
式求值结果的值,都会使用 stream 进行打印. 参见 <a href="#org8c6411d">输出流(Output Streams)</a>.
</p>

<p>
如果 read-function 非 <code>nil</code> ,那么它就应该是一个函数,用来代替函数 <code>read</code> 去一个
个读取表达式. 这个函数是使用一个参数进行调用的,该参数就是读取输入的流. 你可以
使用变量 <code>load-read-function</code> (参见<a href="#orgb7a9174">程序如何执行加载(How Programs Do Loading)</a> )
来指定这个函数,但是使用 read-function 参数更有程序健壮性.
</p>

<p>
<code>eval-region</code> 不会移动光标,且永远返回 <code>nil</code>.
</p></dd>

<dt>命令 <code>(eval-buffer optional buffer-or-name stream filename unibyte print)</code></dt><dd><p>
这个函数与 <code>eval-region</code> 类似,但是其参数提供了不同的可选功能. <code>eval-buffer</code> 会
操作 buffer-or-name 缓冲区的整个可访问部分(参见
<a href="https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Narrowing">emacs#Narrowing</a>). buffer-or-name 可以是一个缓冲区,一个缓冲区名(字符串),或
是 <code>nil</code> (或省略)来表示使用当前缓冲区.除了 stream 为 <code>nil</code> 且 print 非 <code>nil</code>
时, stream 的用法与 <code>eval-region</code> 一样. 在不一样的用法中,来自表达式求值的结果
值会被丢弃,但输出函数的输出仍会打印到回显区. filename 是用于 <code>load-history</code> 的
文件名(参见 <a href="#org0148acb">卸载(Unloading)</a>) ,其默认为 <code>buffer-file-name</code> (参见
<a href="#org235c270">缓冲区文件名(Buffer File Name)</a>). 如果 unibyte 是非 <code>nil</code>, 则在可以的时候,
<code>read</code> 会将字符串转换成单字节.
</p>

<p>
<code>eval-current-buffer</code> 是这个命令的一个别名.
</p></dd>

<dt>用户选项 <code>max-lisp-eval-depth</code></dt><dd><p>
这个变量定义了在发出错误信号(伴有错误提升消
息 <code>"Lisp nesting exceeds max-lisp-eval-depth"</code> )之前, 对函数 <code>eval</code> , <code>apply</code>
以及 <code>funcall</code> 的调用的最大允许深度.
</p>

<p>
当超过这个限制时,会有相关的错误信息提示,是一种 Emacs Lisp 在"病态"定义的函数中
避免无限递归的方式. 如果你将该变量的值设置的太大,这样的代码可能会造成堆栈溢出.
在某些系统中,这种溢出是可以处理的.在这种情况下, 正常的 Lisp 求值过程会被打断并
且控制权会被转移回顶层命令循环(<code>top-level</code>). 请注意,这种情况下是无法进入 Emacs
Lisp 调试器的. 参见 <a href="#org931ad9f">调试错误(Error Debugging)</a>.
</p>

<p>
这个深度限制也把 <code>eval</code> <code>apply</code> 和 <code>funcall</code> 的内部调用计算在内, 例如 Lisp 表
达式中的函数调用,函数调用参数和函数体中表达式的递归求值,以及 Lisp 代码中的显示
调用.
</p>

<p>
这个变量的默认值是 800. 如果你将它设置为小于 100, Lisp 会在深度达到给定值时将
其重设为 100. 进入 Lisp 调试器也会会增加深度值,如果只有很少的剩余空间了,请确保
调试器自身有足够的空间去执行.
</p>

<p>
<code>max-specpdl-size</code> 提供了另一个关于嵌套的限制,参见 <a href="#org6826578">局部变量(Local Variables)</a>.
</p></dd>

<dt>变量 <code>values</code></dt><dd><p>
这个变量的值是一个返回值组成的列表,这些值是由所有从缓冲区(包
括 minibuffer) 中读取,求值和打印的表达式返回的(由进行这些操作的标准 Emcas 命令
完成值的生成),请注意,这些值是 <b>不</b> 包括 <code>*ielm*</code> 缓冲区里的执行,或使用 <code>C-j</code>,
<code>C-x C-e</code> 的求值以及 <code>lisp-interaction-mode</code> 中类似的求值命令的返回值的.
</p>

<p>
这个变量是被 <b>弃用</b> 的,会在将来的版本中被移除,因为它会不断扩大 Emacs 进程的内
存占用. 出于这个原因, 我们建议不要使用它.
</p>

<p>
<code>values</code> 的元素是按照时间远近的顺序排列的
</p>
<pre class="example" id="orgb410801">
  (setq x 1)
       ⇒ 1
  (list 'A (1+ 2) auto-save-default)
       ⇒ (A 3 t)
  values
       ⇒ ((A 3 t) 1 ...)
</pre>
<p>
在反向引用最近执行的表达式的值可能会有用. 通常来说,打印 <code>values</code>  自身的值是一
个坏主意,因为它可能非常长. 相反的,我们可以检查特定的元素,就像这样:
</p>
<pre class="example" id="org897fd13">
  ;; Refer to the most recent evaluation result.
  (nth 0 values)
       ⇒ (A 3 t)
  ;; That put a new element on,
  ;;   so all elements move back one.
  (nth 1 values)
       ⇒ (A 3 t)
  ;; This gets the element that was next-to-most-recent
  ;;   before this example.
  (nth 3 values)
       ⇒ 1

</pre></dd>
</dl>
</div>
</div>

<div id="outline-container-orgde5b9c4" class="outline-4">
<h4 id="orgde5b9c4"><span class="done DONE">DONE</span> 延迟执行(Deffered Eval)</h4>
<div class="outline-text-4" id="text-orgde5b9c4">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-12 Tue 19:50]</span></span></li>
</ul>
<p>
表达式的延迟求值和懒求值.
</p>

<p>
有时延迟一个表达式的求值是很有用的, 例如,如果你想要避免在程序的未来不需要其计算
结果的情况下执行某个耗时的计算. <code>thunk</code> 库提供了下面的函数和宏来支持这种 "延迟求
值":
</p>

<dl class="org-dl">
<dt>宏 <code>(thunk-delay forms ...)</code></dt><dd>返回一个用来对 forms 求值的 "thunk". 一个
thunk 就是一个继承了 <code>thunk-delay</code> 调用的词法环境的闭包(参见 <a href="#orgfa246ab">闭包(Closures)</a>).
使用这个宏需要 <code>lexical-binding</code> 变量.</dd>

<dt><code>(thunk-force thunk)</code></dt><dd>强制 thunk 执行创建 thunk 的 <code>thunk-delay</code> 中指定的表
达式的求值.最后一个表达式的结果会作为返回值. thunk 也会 "记住" 它已经被强制执
行了: 其他对相同 thunk 的进一步 <code>thunk-force</code> 调用都会返回相同结果而不用再一次
执行表达式.</dd>

<dt>宏 <code>(thunk-let (bindings... ) forms...)</code></dt><dd><p>
这个宏与 <code>let</code> 类似,但是会创建一个
"懒" 变量绑定.所有的绑定都有表达式 <code>(symbol value-form)</code>. 与 <code>let</code> 不同的是,
在对 form 求值时,任意 value-form 的求值都会被延迟,直到相应 symbol 的绑定被第一
次使用才进行求值. 所有 value-form 都最多被求值一次. 使用这个宏需要变量
<code>lexical-binding</code>
例子:
</p>
<pre class="example" id="orgc92e55f">
  (defun f (number)
    (thunk-let ((derived-number
		(progn (message "Calculating 1 plus 2 times %d" number)
		       (1+ (* 2 number)))))
      (if (&gt; number 10)
	  derived-number
	number)))

  (f 5)
  ⇒ 5

  (f 12)
  ⊣ Calculating 1 plus 2 times 12
  ⇒ 25
</pre>
<p>
因为懒加载变量的特殊性质,所以设置它们是错误的(例如,使用 <code>setq</code>)
</p></dd>

<dt>宏 <code>(thunk-let* (bindings...) forms...)</code></dt><dd><p>
它与 <code>thunk-let</code> 类似,但是
bindings 中的任意表达式都允许引用这个 <code>thunk-let*</code> 表达式中前面的绑定. 使用这
个宏需要变量 <code>lexical-binding</code>.
</p>
<pre class="example" id="org37ec7a5">
  (thunk-let* ((x (prog2 (message "Calculating x...")
		      (+ 1 1)
		    (message "Finished calculating x")))
	       (y (prog2 (message "Calculating y...")
		      (+ x 1)
		    (message "Finished calculating y")))
	       (z (prog2 (message "Calculating z...")
		      (+ y 1)
		    (message "Finished calculating z")))
	       (a (prog2 (message "Calculating a...")
		      (+ z 1)
		    (message "Finished calculating a"))))
    (* z x))

  ⊣ Calculating z...
  ⊣ Calculating y...
  ⊣ Calculating x...
  ⊣ Finished calculating x
  ⊣ Finished calculating y
  ⊣ Finished calculating z
  ⇒ 8
</pre>
<p>
<code>thunk-let</code> 和 <code>thunk-let*</code> 隐式使用 thunk: 他们的扩展创造帮助符号并将他们绑定给
包裹了绑定表达式的 thunk. 所有指向 forms 中原始变量的引用会被替换成一个表达式,
该表达式使用相应的帮助变量作为参数调用 <code>thunk-force</code>. 因此, 任意使用了
<code>thunk-let*</code> 或 <code>thunk-let</code> 的代码都可以被重写为使用 thunk 的代码,但是在多数情
况下使用这些宏会比显式使用 thunk 生成更好的代码.
</p></dd>
</dl>
</div>
</div>
</div>

<div id="outline-container-org553107e" class="outline-3">
<h3 id="org553107e"><span class="done DONE">DONE</span> 控制结构(Control Structures)</h3>
<div class="outline-text-3" id="text-org553107e">
<p>
条件,循环,非局部退出.
</p>

<p>
一个 Lisp 程序由一系列 "表达式" 组成(参见 <a href="#org0d16480">表达式(Forms)</a>). 我们通过将这些表达式封
装在 "控制结构" 中来控制它们的执行顺序. 控制结构是控制何时,是否或执行他们包含的
表达式多少次的特殊表达式.
</p>

<p>
最简单的执行顺序是顺序执行: 第一个执行表达式 A, 然后是表达式 B, 以此类推.这是当
你在一个函数体内或是在一个 Lisp 代码文件的顶层编写几个连续的表达式时会发生的事情,即
这些表达式按照编写的顺序执行. 我们把这称为 "文本顺序". 例如, 如果一个函数体由两
个表达式 A 和 B 组成,对该函数求值会先对 A 求值再对 B 求值. B 的求值结果会成为函
数的返回值.
</p>

<p>
显式控制结构让非顺序执行成为可能.
</p>

<p>
Emacs Lisp 提供了几种控制结构,包括顺序执行的其他变种,条件, 迭代,以及跳转(在控制
之下的),都会在这部分进行讨论. 内置的控制结构是特殊表达式,因为它们的子表达式不一
定会被求值或不一定会顺序求值. 你可以使用宏来定义你自己的控制结构构造(参见
<a href="#org15d607f">宏(Macros)</a>).
</p>
</div>

<div id="outline-container-org2916e3a" class="outline-4">
<h4 id="org2916e3a"><span class="done DONE">DONE</span> 顺序执行(Sequencing)</h4>
<div class="outline-text-4" id="text-org2916e3a">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-13 Wed 15:45]</span></span></li>
</ul>
<p>
按照文本顺序执行.
</p>

<p>
按照表达式出现的顺序执行是最常见的一种将控制权从一个表达式传递到另一个的方式. 在
某些上下文中,例如在函数体中,这是自动发生的.在其他地方,你必须使用控制结构构造来实
现这一点: <code>progn</code>, 这是 Lisp 最简单的控制结构构造.
</p>

<p>
<code>progn</code> 是一个特殊表达式:
</p>
<pre class="example" id="org917ba26">
(progn A B C ...)
</pre>
<p>
这个表达式的意思是按照顺序执行表达式 A, B, C, 等等. 这些表达式叫做 <code>progn</code> 表达
式的 "body" (主体). 主体的最后一个表达式的值会成为整个 <code>progn</code> 的值. <code>(progn)</code>
会返回 <code>nil</code>.
</p>

<p>
在早期的 Lisp 中, <code>progn</code> 是执行两个或两个以上的连续表达式并使用最后一个表达式的
值的唯一方式. 但是程序员发现他们经常需要在一个函数的主体中使用 <code>progn</code> (当时函数
的主体中只允许有一个表达式). 因此函数的主体就被做成了一个隐式的 <code>progn</code> : 就像在
一个真的 <code>progn</code> 主体中一样允许多个表达式. 许多其他的控制结构同样包含隐式
<code>progn</code>. 因此, <code>progn</code> 不像多年以前那样用得频繁了. 它现在最经常用在
<code>unwind-protect</code>, <code>and</code>, <code>or</code> 或在 <code>if</code> 的 THEN 部分.
</p>

<dl class="org-dl">
<dt><code>(progn forms...)</code></dt><dd><p>
这个特殊表达式按文本顺序执行所有的 forms, 并返回最后一个
表达式的结果.
</p>

<pre class="example" id="org2d569cb">
  (progn (print "The first form")
	 (print "The second form")
	 (print "The third form"))
       ⊣ "The first form"
       ⊣ "The second form"
       ⊣ "The third form"
  ⇒ "The third form"
</pre></dd>
</dl>


<p>
还有另外两个构造同样对一系列表达式求值,但是返回的是不同的值:
</p>

<dl class="org-dl">
<dt><code>(prog1 form1 forms)</code></dt><dd><p>
这个特殊表达式对 form1 和所有 forms 按文本顺序求值求
值, 返回 form1 的结果.
</p>
<pre class="example" id="orgc4b1acb">
  (prog1 (print "The first form")
	 (print "The second form")
	 (print "The third form"))
       ⊣ "The first form"
       ⊣ "The second form"
       ⊣ "The third form"
  ⇒ "The first form"
</pre>
<p>
下面是一种从变量 <code>x</code> 的列表中移除并返回第一个元素的方式:
</p>

<pre class="example" id="org3fc0674">
  (prog1 (car x) (setq x (cdr x)))
</pre></dd>

<dt><code>(prog2 form1 form2 forms...)</code></dt><dd><p>
这个特殊表达式对 form1, form2, 以及所有后续
的表达式按照文本顺序求值,返回第二个表达式 form2 的结果.
</p>
<pre class="example" id="orgabe67b2">
  (prog2 (print "The first form")
	 (print "The second form")
	 (print "The third form"))
       ⊣ "The first form"
       ⊣ "The second form"
       ⊣ "The third form"
  ⇒ "The second form"

</pre></dd>
</dl>
</div>
</div>


<div id="outline-container-orgaa372a6" class="outline-4">
<h4 id="orgaa372a6"><span class="done DONE">DONE</span> 条件(Conditionals)</h4>
<div class="outline-text-4" id="text-orgaa372a6">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-13 Wed 16:31]</span></span></li>
</ul>
<p>
if, cond, when, unless.
</p>

<p>
条件控制结构可以在备选方案中选择. Emacs Lisp 有 5 中条件表达式: <code>if</code>, 与其他语言
中的差不多; <code>when</code> 和 <code>unless</code> 是 <code>if</code> 的变种; <code>cond</code>, 是一个通用的 case 语句;
<code>pcase</code> 是 <code>cond</code> 的推广(参见 <a href="#org9b24c8c">模式匹配的条件(Pattern-Matching Conditional)</a> ).
</p>

<dl class="org-dl">
<dt><code>(if condition then-form else-forms...)</code></dt><dd><p>
if 基于 condition 的值来在
then-form 和 else-forms 之间进行选择. 如果 condition 的求值为非 <code>nil</code> ,那么
then-form 就会被求值并返回其结果. 否则, else-forms 就会按照文本顺序进行求值,并
返回最后一个的求值结果. (if 的 else 部分就是一个隐式 <code>progn</code> 的例子, 参见
<a href="#org2916e3a">顺序执行(Sequencing)</a>.)
</p>

<p>
如果 condition 值为 <code>nil</code> ,并且没有给定 else-forms, 那么 <code>if</code> 就会返回 <code>nil</code>.
</p>

<p>
<code>if</code> 是一个特殊表达式,因为没有被选择的分支永远不会被执行,它会被忽略. 因此,在下
面这个例子中, <code>true</code> 不会被打印,因为 <code>print</code> 永远不会被调用:
</p>
<pre class="example" id="org32ff879">
  (if nil
      (print 'true)
    'very-false)
  ⇒ very-false
</pre></dd>

<dt>宏 <code>(when condition then-forms...)</code></dt><dd>这是 <code>if</code> 的变种,它没有 else-forms ,并
且可以有多个 then-forms. 特别的, <code>(when condition A B C)</code> 等价于
 <code>(if condition (progn A B C) nil)</code></dd>

<dt>宏 <code>(unless condition forms...)</code></dt><dd>这是 <code>if</code> 的变种,它没有 then-forms:
<code>(unless condition A B C)</code> 等价于 <code>(if condition nil A B C)</code>.</dd>

<dt><code>(cond clause...)</code></dt><dd><p>
<code>cond</code> 从任意数量的备选方案中做出选择. <code>cond</code> 中的每个
clause (子句) 都必需是列表. 这个列表的 CAR 就是 condition; 如果还有剩下的元素,
就是 body-forms (主体表达式). 因此,这个 clause (子句) 就是像这样的:
</p>
<pre class="example" id="orgfb96a99">
  (CONDITION BODY-FORMS...)
</pre>
<p>
<code>cond</code> 会按照文本顺序尝试(通过对每个 clause 的 condition 进行求值的方式)每个子
句(clause). 如果 condition 是非 <code>nil</code> 的,则该子句生效;然后 <code>cond</code> 会对其主体表
达式 (body-forms) 求值,并返回最后一个主体表达式的值.剩下的所有子句则会被忽略.
</p>

<p>
如果 condition 的值是 <code>nil</code> 则该子句失败,于是 <code>cond</code> 会移动到下一个子句继续尝
试其 condition.
</p>

<p>
一个子句也可能是像这样:
</p>
<pre class="example" id="org5ed8fec">
  (CONDITION)
</pre>
<p>
那么,如果在测试时 condition 是非 <code>nil</code> , <code>cond</code> 表达式会返回该 condition 的值.
</p>

<p>
如果每个 condition 都求值为 <code>nil</code>, 那么每个子句都失败, <code>cond</code> 返回 <code>nil</code>.
</p>

<p>
下面的例子中有 4 个子句,分别用来测试 <code>x</code> 的值是数字,字符串,缓冲区以及符号的情
况:
</p>
<pre class="example" id="org37f4fca">
  (cond ((numberp x) x)
	((stringp x) x)
	((bufferp x)
	 (setq temporary-hack x) ; multiple body-forms
	 (buffer-name x))        ; in one clause
	((symbolp x) (symbol-value x)))
</pre>
<p>
通常,当前面所有子句都失败时,我们希望执行最后一个子句. 要实现这一点,我们使用
<code>t</code> 作为最后一个子句的 condition, 就像这样: <code>(t body-forms)</code> .表达式 <code>t</code> 的求
值结果为 <code>t</code> ,且永远不会为 <code>nil</code>, 因此只要 <code>cond</code> 到达了这个子句,它就永远不会
失败. 例如:
</p>
<pre class="example" id="orgfe86184">
  (setq a 5)
  (cond ((eq a 'hack) 'foo)
	(t "default"))
  ⇒ "default"
</pre>
<p>
如果 <code>a</code> 的值为 <code>hack</code> 这个 <code>cond</code> 表达式就返回 <code>foo</code>, 否则,就会返回字符串
<code>"default"</code>.
</p></dd>
</dl>


<p>
所有条件表达式构造都可以使用 <code>cond</code> 或 <code>if</code> 来表达. 因此,如何选择它们是个人喜好
的问题. 例如:
</p>
<pre class="example" id="orgcc59d0e">
(if A B C)
≡
(cond (A B) (t C))

</pre>
</div>
</div>

<div id="outline-container-org95c036a" class="outline-4">
<h4 id="org95c036a"><span class="done DONE">DONE</span> 组合条件(Combining Conditions)</h4>
<div class="outline-text-4" id="text-org95c036a">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-13 Wed 17:54]</span></span></li>
</ul>
<p>
<code>and</code>, <code>or</code>, <code>not</code> 和它们的同伴们.
</p>

<p>
这一节描述那些通常与 <code>if</code> 和 <code>cond</code> 一起使用来表达复杂条件的构造. <code>and</code> 和 <code>or</code>
构造也可以单独用作多种条件构造.
</p>

<blockquote>
<p>
对 and 和 or 的理解: and 检测到 <code>nil</code> 值就返回 <code>nil</code>, 否则返回最后一个表达式的值;
or 是检测到非 <code>nil</code> 值,就返回刚检测到的非 <code>nil</code> 值,否则返回 <code>nil</code>.
因此不带参数的 and 函数,检测不到 <code>nil</code> 值(因为它没有值),于是就返回 <code>t</code> ; 而没有
参数的 or 函数, 检测不到 <code>t</code> 值,就返回 <code>nil</code>
</p>

<p>
and 和 or 这种逻辑函数,返回的应该是逻辑上的真值和假值,编程语言中对逻辑真值和逻辑
假值的处理应该是规定某个值为假值,然后所有非假值的值都是真值,因此我们在很多情况下
都会看到不是使用专门代表真值和假值的 <code>t</code> 和 <code>nil</code> 来表示逻辑值,而是使用表达式的
求值结果,那就是把非假值当作真值使用的.(python 里也是类似的用法, 只有 FALSE 专门
对待,其他的 !FALSE 都当作逻辑真值使用了)
</p>
</blockquote>

<dl class="org-dl">
<dt><code>(not condition)</code></dt><dd>这个函数测试 condition 的错误. 如果 condition 是 <code>nil</code>,
则返回 <code>t</code>, 否则返回 <code>nil</code> . 函数 <code>not</code> 与 <code>null</code> 是完全相等的,如果你是为了测
试一个空列表,那我们推荐使用 <code>null</code> 这个函数名 .</dd>

<dt><code>(and conditions...)</code></dt><dd><p>
特殊表达式 <code>and</code> 测试是否所有的 conditions 都为真. 它
是通过按照编写顺序一个个对 conditions 进行求值来执行的.
</p>

<p>
如果任意的 conditions 求值为 <code>nil</code> 那么不管剩下的 conditions 如何, <code>and</code> 的结
果必为 <code>nil</code> ;因此 <code>and</code> 会立即返回 <code>nil</code>, 而忽略剩下的 conditions.
</p>

<p>
如果所有的 conditions 都是非 <code>nil</code> 的, 那么最后一个的值会成为 <code>and</code> 表达式的值.只
有 <code>(and)</code> 没有 conditions 会返回 <code>t</code>, 这是合理的,因为所有的 conditions 都不是
<code>nil</code> (想想看,哪个是 <code>nil</code> 值? 没有,因为它一个 conditions 都没有,自然不可能有
<code>nil</code> .)
</p>

<p>
下面是一个示例. 第一个条件返回整数 1, 非 <code>nil</code>. 相似地,第二个条件返回整数 2,
非 <code>nil</code>. 第三个条件是 <code>nil</code>, 因此剩下的条件永远都不会被执行了.
</p>
<pre class="example" id="org0311e48">
  (and (print 1) (print 2) nil (print 3))
       ⊣ 1
       ⊣ 2
  ⇒ nil
</pre>
<p>
下面是一个更真实地使用 <code>and</code> 的例子:
</p>
<pre class="example" id="org1e1cc3d">
  (if (and (consp foo) (eq (car foo) 'x))
      (message "foo is a list starting with x"))
</pre>
<p>
请注意, 如果 <code>(consp foo)</code> 返回 <code>nil</code>, 则 <code>(car foo)</code> 不会被执行,这样可以避免
错误.
</p>

<p>
<code>and</code> 表达式也可以使用 <code>if</code> 或 <code>cond</code> 来编写:
</p>
<pre class="example" id="org61d1f6c">
  (and ARG1 ARG2 ARG3)
  ≡
  (if ARG1 (if ARG2 ARG3))
  ≡
  (cond (ARG1 (cond (ARG2 ARG3))))
</pre></dd>

<dt><code>(or conditions...)</code></dt><dd><p>
特殊表达式 <code>or</code> 测试 conditions 中是否至少有一个为真.
它通过按照编写顺序一个个对所有 conditions 求值来执行.
</p>

<p>
如果任意的 conditions 求值为非 <code>nil</code> 值,那么 <code>or</code> 的结果必为非 <code>nil</code> 值; 因此
<code>or</code> 会立刻返回,而忽略剩下的 conditions. 它的返回值是刚刚被求值的 condition 的
非 <code>nil</code> 值.
</p>

<p>
如果所有的 conditions 都是 <code>nil</code> , 那么 <code>or</code> 表达式返回 <code>nil</code>. 只有 <code>(or)</code> 没
有 conditions 会返回 <code>nil</code>, 这是合理的,因为所有 conditions 都是 <code>nil</code>.( 想想,
哪个不是 <code>nil</code>, 没有,因为它就没有 conditions)
</p>

<p>
例如, 下面这个表达式测试 <code>x</code> 是否为 <code>nil</code> 或整数0:
</p>
<pre class="example" id="org22d63df">
  (or (eq x nil) (eq x 0))
</pre>

<p>
与 <code>and</code> 构造一样, <code>or</code> 也可以由 <code>cond</code> 编写:
</p>
<pre class="example" id="orgd9a92a8">
  (or ARG1 ARG2 ARG3)
  ≡
  (cond (ARG1)
	(ARG2)
	(ARG3))
</pre>
<p>
你几乎可以用 <code>if</code> 来编写 <code>or</code> ,但不完全可以:
</p>
<pre class="example" id="org88a08a4">
  (if ARG1 ARG1
    (if ARG2 ARG2
      ARG3))
</pre>
<p>
这并不是完全等价,因为它可能会执行 arg1 或 arg2 两次. 相比之下,
<code>(or ARG1 ARG2 ARG3)</code> 永远不会对任意参数求值超过一次.
</p></dd>

<dt><code>(xor condition1 condition2)</code></dt><dd><p>
这个函数返回 condition1 和 condition2 的布尔
异或值. 也就是如果两个参数都是 <code>nil</code> 或都是非 <code>nil</code>, 那么 <code>xor</code> 就返回
<code>nil</code>. 否则,它会返回参数值为非 <code>nil</code> 的值.
</p>

<p>
请注意,与 <code>or</code> 相比, 这个函数的两个参数永远都会被求值.
</p></dd>
</dl>
</div>
</div>

<div id="outline-container-org9b24c8c" class="outline-4">
<h4 id="org9b24c8c"><span class="done DONE">DONE</span> 模式匹配的条件(Pattern-Matching Conditional)</h4>
<div class="outline-text-4" id="text-org9b24c8c">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-21 Thu 16:57]</span></span></li>
</ul>
<p>
如何使用 <code>pcase</code> 和它的同类.
</p>

<p>
除了上面 4 中基本条件表达式之外, Emacs Lisp 也有一种模式匹配的条件表达式,也就是
<code>pcase</code> 宏,它是 <code>cond</code> 和 <code>cl-case</code> (参见 <a href="https://www.gnu.org/software/emacs/manual/html_mono/cl.html#Conditionals">cl#Conditionals</a>) 的混合,它克服了这两者
的限制,并引进了"pattern matching programming style"(模式匹配编程风格). <code>pcase</code>
克服的限制有:
</p>
<ul class="org-ul">
<li><p>
<code>cond</code> 表达式通过对其每个子句中的 condition 断言求值来选择备选方案(参见
<a href="#orgaa372a6">条件(Conditionals)</a>). 最主要的限制是在 condition 中用 let 绑定的变量在子句的主
体表达式中是不可用的.
</p>

<p>
另一个烦恼(与其说是限制而不如说是不便之处)是当一系列 condition 断言实现相等性
测试时,会出现很多重复的代码(<code>cl-case</code> 解决了这个不便之处).
</p></li>

<li><p>
<code>cl-case</code> 宏通过对其第一个参数与一系列指定值进行相等性求值来选择备选方案.
其局限性有两个方面:
</p>
<ul class="org-ul">
<li>相等性测试使用 <code>eql</code>.</li>

<li>用来比较的值必需提前编写并已知.</li>
</ul>

<p>
这些使得 <code>cl-case</code> 不适合字符串或符合数据结构(例如,列表或向量).(<code>cond</code> 没有这
些限制,但有其他限制,参见上文)
</p></li>
</ul>


<p>
从概念上来讲, <code>pcase</code> 宏借用了 <code>cl-case</code> 的第一个参数中心和 <code>cond</code> 的子句处理流
程,将 condition 替换成了一个通用的相等性测试,这个测试是 "模式匹配" 的变种,并添加
了一些让你能简要地表达一个子句的断言的功能,而且还共享了子句的断言和主体表达式之
间的 let 绑定.
</p>

<p>
断言的简要表达式被叫做 "模式"(pattern). 当作为第一个参数值被调用的断言返回一个非
<code>nil</code> 值时,我们称之为 "模式与值匹配了"(有时也称 "值与模式匹配了")
</p>
</div>

<ul class="org-ul">
<li><a id="orgaa90b63"></a><span class="done DONE">DONE</span> pcase 宏(The <code>pcase</code> macro)<br />
<div class="outline-text-5" id="text-orgaa90b63">
<p>
包括示例和注意事项.
</p>

<p>
背景知识,参见 <a href="#org9b24c8c">模式匹配的条件(Pattern-Matching Conditional)</a>.
</p>

<dl class="org-dl">
<dt>宏 <code>(pcase expression &amp;rest clauses)</code></dt><dd><p>
clauses 中的每个子句都有这样的形式:
<code>(pattern body-forms...)</code>.
</p>

<p>
对 expression 求值来决定它的值(记为 EXPVAL). 在 clauses 中寻找其 pattern 匹配
EXPVAL 的第一个子句,并将控制权递交到该子句的主体表达式.
</p>

<p>
如果有匹配的子句,则 <code>pcase</code> 的值就是成功的子句中最后一个主体表达式的值. 否则,
<code>pcase</code> 求值结果为 <code>nil</code>.
</p>

<p>
每个 pattern 都要必须是一个 "pcase 模式", 这种模式可以使用下面定义的任意基本模
式,或使用由 <code>pcase-defmacor</code> 定义的模式(参见
<a href="#org89ff146">扩展 pcase(Extending <code>pcase</code>)</a>).
</p></dd>
</dl>


<p>
这一小节的剩余部分描述的是不同形式的基本模式,展示了一些例子,并在使用某些模式形式
提供的 let 绑定功能时提出了重要的注意事项. 一个基本模式可以是下面这些形式:
</p>
<dl class="org-dl">
<dt><code>_ (下划线)</code></dt><dd>匹配任意的 EXPVAL. 这个形式也被称作 "无所谓" 或 "通配符".</dd>
<dt><code>'VAL</code></dt><dd>如果 EXPVAL 等于 VAL 才匹配. 是否匹配的比较就像是使用 <code>equal</code> 一样
(参见 <a href="#org9fe4c9b">相等断言(Equality Predicates)</a>).</dd>
<dt><code>KEYWORD</code></dt><dd></dd>

<dt><code>INTEGER</code></dt><dd></dd>

<dt><code>STRING</code></dt><dd>如果 EXPVAL 等于这些文本对象就匹配. 这个是上面 <code>'VAL</code> 的特殊情况,
可能是因为这些类型的文本对象是自引用的(自执行的呗).</dd>
<dt><code>SYMBOL</code></dt><dd><p>
匹配任意 EXPVAL, 另外还让 SYMBOL 绑定到 EXPVAL, 这样的绑定在
body-forms 中是可用的(参见 <a href="#org5437ee7">动态绑定(Dynamic Binding)</a>).
</p>

<p>
如果 SYMBOL 是一个顺序模式 SEQPAT( 例如,使用下面的 <code>and</code>), 那么绑定也会在
SEQPAT 中后面出现 SYMBOL 的部分可用. 这个用法有些注意事项, 参见下面的
 <a href="#orga67f2d7">注意事项(caveats)</a>.
</p>

<p>
两个需要避免使用的符号是 <code>t</code> 和 <code>nil</code>, 前者的用法就像上面的 <code>_</code> 一样,因此不推
荐使用,后者则会发出一个错误信号. 相同地,将两个关键符号绑定到一起是毫无意义
的(参见 <a href="#orgde44202">常量(Constant Variable)</a>).
</p></dd>
<dt><code>(cl-type TYPE)</code></dt><dd><p>
如果 EXPVAL 是 TYPE 类型,则匹配, TYPE 是可以被 <code>cl-typep</code>
接受的类型描述符(参见 <a href="https://www.gnu.org/software/emacs/manual/html_mono/cl.html#Type-Predicates">cl#Type Predicates</a>). 示例:
</p>
<pre class="example" id="org5a4db76">
  (cl-type integer)
  (cl-type (integer 0 10))
</pre></dd>
<dt><code>(pred FUNCTION)</code></dt><dd>当断言函数 FUNCTION 对 EXPVAL 调用时返回非 <code>nil</code> 值则匹配.
断言测试可以使用语法 <code>(pred (not FUNCTION))</code> 来否定. 断言 FUNCTION 可以有以下
几种形式:
<dl class="org-dl">
<dt>函数名(一个符号)</dt><dd>传递一个参数 EXPVAL 来调用该函数名的函数.例如 <code>integerp</code></dd>
<dt>lambda 表达式</dt><dd>传递一个参数 EXPVAL 来调用匿名函数(参见
<a href="#org8ae8a6d">Lambda 表达式(Lambda Expressions)</a>)</dd>
<dt>有 N 个参数的函数调用</dt><dd>调用函数(也就是函数调用语法的列表中的第一个元素),
传递给它 N 个参数(调用语法中的其他元素) 以及额外的第 N+1 个参数 EXPVAL.
示例: <code>(= 42)</code>, 这个例子中,函数是 <code>=</code>, N 是 1, 实际的函数调用是 <code>(= 42
    EXPVAL)</code>.</dd>
</dl></dd>
<dt><code>(app FUNCTION PATTERN)</code></dt><dd>如果 EXP 作为参数的 FUNCTION 的函数调用返回一个与
PATTERN 匹配的值,则表示匹配. FUNCTION 可以是上面 <code>pred</code> 中描述的形式中的一种.
但是,与 <code>pred</code> 不同的是, <code>app</code> 将函数的结果与 PATTERN 比较,而不是与布尔真值比
较.</dd>
<dt><code>(guard BOOLEAN-EXPRESSION)</code></dt><dd>如果 BOOLEAN-EXPRESSION 求值为非 <code>nil</code> 则表示
匹配.</dd>
<dt><code>(let PATTERN EXPR)</code></dt><dd>对 EXPR 求值来获取 EXPRVAL, 如果 EXPRVAL 与 PATTERN 匹
配,则表示匹配.(之所以叫做 <code>let</code> 是因为 PATTERN 可以使用 SYMBOL 将符号与值绑定.)</dd>
</dl>


<p>
一个"连续模式"(也叫 SEQPAT) 就是按照顺序处理其子模式参数的模式. <code>pcase</code> 有两种类
型的 SEQPAT: <code>and</code> 和 <code>or</code>. 他们与跟他们同名的特殊表达式有着相似的用法(参见
<a href="#org95c036a">组合条件(Combining Conditions)</a>), 但是他们不处理值而是处理子模式.
</p>
<dl class="org-dl">
<dt><code>(and PATTERN1...)</code></dt><dd>尝试按照顺序匹配 PATTERN1&#x2026;, 直到其中一个匹配失败. 加
入匹配失败, <code>and</code> 同样匹配失败,剩下的所有子模式都不会被测试了. 如果所有的子模
式都成功匹配,则 <code>and</code> 成功匹配.</dd>

<dt><code>(or PATTERN1 PATTERN2...)</code></dt><dd><p>
尝试按照顺序匹配 PATTERN1, PATTERN2, &#x2026; ,直到
其中一个成功匹配. 如果有一个匹配成功了, 则 <code>or</code> 也同样匹配成功,剩下的子模式不
会被测试了.
</p>

<p>
为了给 BODY-FORMS 一个一致的环境(参见 <a href="#org869e90d">Eval 简介(Intro Eval)</a>)(这样能避免匹配中
的求值错误),由模式绑定的变量集是每个子模式的变量绑定的并集. 如果一个变量没有被
匹配的子模式绑定,那它就会被绑定为 <code>nil是每个子模式的变量绑定的并集. 如果一个变
  量没有被匹配的绑那它就会被绑定为 ~nil</code>.
</p></dd>

<dt><code>(rx RX-EXPR...)</code></dt><dd><p>
使用 <code>rx</code> 正则表达式的表示法(参见 <a href="#org889d705">Rx 表示法(Rx Notation)</a>
)来将字符串与正则表达式RX-EXPR&#x2026; 进行匹配, 就像使用 <code>string-match</code> 一样.
</p>

<p>
除了常用的 <code>rx</code> 语法外, <code>RX-EXPR...</code> 可以包括下列构造:
</p>
<dl class="org-dl">
<dt><code>(let REF RX-EXPR...)</code></dt><dd>将符号 REF 绑定到与 RX-EXPR&#x2026; 匹配的子匹配. REF
在 body-form 中是绑定到子匹配的字符串或 <code>nil</code> 值,但是也可以用于 <code>backref</code>.</dd>
<dt><code>(backref REF)</code></dt><dd>与标准的 <code>backref</code> 构造类似,但是 REF 也可以是一个通过前面
的 <code>(let REF ...)</code> 构造引入的名字.</dd>
</dl></dd>
</dl>
</div>


<ul class="org-ul">
<li><a id="orgbe44b0b"></a><span class="done DONE">DONE</span> 使用示例<br />
<div class="outline-text-6" id="text-orgbe44b0b">
<ul class="org-ul">
<li><p>
优于 <code>cl-case</code>:
这是一个强调 <code>pcase</code> 优于 <code>cl-case</code> (参见 <a href="https://www.gnu.org/software/emacs/manual/html_mono/cl.html#Conditionals">cl#Conditionals</a>)的例子
</p>
<pre class="example" id="orgdc2511b">
  (pcase (get-return-code x)
    ;; string
    ((and (pred stringp) msg)
     (message "%s" msg))
    ;; symbol
    ('success       (message "Done!"))
    ('would-block   (message "Sorry, can't do it now"))
    ('read-only     (message "The shmliblick is read-only"))
    ('access-denied (message "You do not have the needed rights"))
    ;; default
    (code           (message "Unknown return code %S" code)))
</pre>
<p>
使用 <code>cl-case</code> ,你会需要显式声明一个局部变量 <code>code</code> 来保存 <code>get-return-code</code>
的返回值. 因为 <code>cl-case</code> 使用 <code>eql</code> 进行比较,因此它与字符串一起使用也是很难用
的.
</p></li>
<li><p>
使用 <code>and</code> : 一个常见的用法是以 <code>and</code> 开头编写模式,再加上一个或多个 symbol 子
模式来提供后续子模式(以及主体表达式)的绑定. 例如,下面的模式匹配一位整数:
</p>
<pre class="example" id="orgb711c56">
  (and
    (pred integerp)
    n                     ; bind ‘n’ to EXPVAL
    (guard (&lt;= -9 n 9)))
</pre>
<p>
首先,如果 <code>(integerp EXPVAL)</code> 求值为非 <code>nil</code>, 则 <code>pred</code> 成功匹配. 接着, <code>n</code> 是
一个匹配任意值的 SYMBOL 模式,并且它将 <code>n</code> 与 EXPVAL 绑定. 最后,如果布尔表达式
<code>(&lt;= -9 n 9)</code> (注意 <code>n</code> 的引用)求值为非 <code>nil</code>, 则 <code>guard</code> 成功匹配. 如果所有这
些子模式都匹配了,那么 <code>and</code> 就成功匹配.
</p></li>
<li><p>
使用 <code>pcase</code> 进行重整: 这个例子展示了如何将一个简单的匹配任务从其传统实现(函数
<code>grok/traditional</code>)重整为一个使用 <code>pcase</code> 的实现(函数 <code>gtok/pcase</code>)的. 这些函
数的文档字符串都是: "如果 OBJ 是一个 "key:NUMBER" 形式的字符串, 则返回NUMBER
(以字符串形式), 否则,返回列表 ("149" default)". 首先,传统的实现(参见
<a href="#org3c6463d">正则表达式(Regular Expressions)</a>):
</p>
<pre class="example" id="orge62a4cb">
  (defun grok/traditional (obj)
    (if (and (stringp obj)
	     (string-match "^key:\\([[:digit:]]+\\)$" obj))
	(match-string 1 obj)
      (list "149" 'default)))

  (grok/traditional "key:0")   ⇒ "0"
  (grok/traditional "key:149") ⇒ "149"
  (grok/traditional 'monolith) ⇒ ("149" default)
</pre>
<p>
下面的重整演示了 SYMBOL 绑定, <code>or</code> , <code>and</code> , <code>pred</code> , <code>app</code> 和 <code>let</code> 的用法:
</p>
<pre class="example" id="orgd65b343">
  (defun grok/pcase (obj)
    (pcase obj
      ((or                                     ; line 1
	(and                                   ; line 2
	 (pred stringp)                        ; line 3
	 (pred (string-match                   ; line 4
		"^key:\\([[:digit:]]+\\)$"))   ; line 5
	 (app (match-string 1)                 ; line 6
	      val))                            ; line 7
	(let val (list "149" 'default)))       ; line 8
       val)))                                  ; line 9

  (grok/pcase "key:0")   ⇒ "0"
  (grok/pcase "key:149") ⇒ "149"
  (grok/pcase 'monolith) ⇒ ("149" default)
</pre>
<p>
<code>grok/pcase</code> 是一个 <code>pcase</code> 表达式的单个子句, 1到8 行是模式, 第九行是(单个) 主
体表达式. 模式是 <code>or</code> 类型的,会尝试一个个匹配它的子模式参数, 第一个子模式是
<code>and</code> 类型(2-7行),然后是 <code>let</code> 类型(8行), 直到他们中的一个成功匹配.
</p>

<p>
和这个部分的第一个例子一样, <code>and</code> 是以一个 <code>pred</code> 子模式开头的,是为了保证后续
的子模式有正确的类型(字符串). 如果 <code>(stringp EXPVAL)</code> 返回 <code>nil</code>, <code>pred</code> 失败,
因此 <code>and</code> 也会失败.
</p>

<p>
接下来的 <code>pred</code> (line 4-5) 对 <code>(string-match RX EXPVAL)</code> 求值,如果结果非 <code>nil</code>
则匹配成功,这意味着 EXPVAL 有着希望的格式 <code>key:NUMBER</code>. 同样的,如果这部分匹配
失败,则 <code>pred</code> 也失败, <code>and</code> 也会失败.
</p>

<p>
最后的(在这个连续的 <code>and</code> 子模式中) <code>app</code> 对 <code>(match-string 1 EXPVAL)</code> (行6)
求值,来获得一个临时值 TMP (也就是 "NUMBER" 子字符串),并尝试将 TMP 与模式 <code>val</code>
(行7)进行匹配. 因为 <code>val</code> 是一个 SYMBOL 模式,所以它无条件匹配,并将 TMP 绑定到
<code>val</code> .
</p>

<p>
到现在 <code>app</code> 已经匹配了,也就是所有 <code>and</code> 的子模式都匹配了,因此 <code>and</code> 也匹配成
功了. 相同的,一旦 <code>and</code> 成功匹配, <code>or</code> 也成功匹配了,那么就不用继续去尝试子模式
<code>let</code> (行8) 了.
</p>

<p>
考虑 <code>obj</code> 不是字符串或者是一个错误格式字符串的情况.在这种情况下,上面的某个
<code>pred</code> (3-5行) 会匹配失败,因此 <code>and</code> (行2) 会匹配失败,因此 <code>or</code> 会继续尝试子模
式 <code>let</code> (行8).
</p>

<p>
首先, <code>let</code> 对 <code>(list "149 'default)</code> 求值,来获得 EXPRVAL: <code>("149" default)</code>,
然后尝试将 EXPRVAL 与模式 <code>val</code> 进行匹配. 因为 <code>val</code> 是 SYMBOL 模式,它将无条件
匹配并将 <code>val</code> 绑定到 EXPRVAL. 现在, <code>let</code> 匹配了,那么 <code>or</code> 也匹配了.
</p>

<p>
请注意, <code>and</code> 和 <code>let</code> 的子模式是如何都以相同方式完成的: 通过尝试与 SYMBOL 模
式 <code>val</code> 匹配(总是会成功),在此过程中,绑定 <code>val</code>. 因此, <code>or</code> 总是匹配成功,控制
权总是会递交到主体表达式(行9). 因为它是最后一个成功匹配的 <code>pcase</code> 子句的主体表
达式,所以它的值就是 <code>pcase</code> 的值,同样也是 <code>gtok/pcase</code> 的返回值(参见
<a href="#orgb4e7d90">什么是函数(What Is a Function)</a>).
</p></li>
</ul>
</div>
</li>

<li><a id="orga67f2d7"></a><span class="done DONE">DONE</span> 注意事项(caveats)<br />
<div class="outline-text-6" id="text-orga67f2d7">
<p>
前面的例子都使用了连续模式,这些连续模式都以某种方式包含了 SYMBOL 子模式.下面是这
种用法的一些重要细节.
</p>

<ul class="org-ul">
<li><p>
当 SYMBOL 在 SEQPAT 中出现超过一次时, 第二次以及后续的出现不会扩展为重新绑定,
而是扩展为一个使用 <code>eq</code> 的相等性测试.
</p>

<p>
下面的这个例子以两个子句和两个 SEQPAT, A 和 B 组成 <code>pcase</code> 表达式. A 和 B 都检
查 EXPVAL 是否为一对(使用 <code>pred</code>), 然后将符号与 EXPVAL 的 CAR 和 CDR 绑定(每次
绑定使用一个 <code>app</code>)
</p>

<p>
对于 A, 因为符号 <code>st</code> 使用了两次,第二次出现会变成一个使用 <code>eq</code> 的相等性测试.
另一方面, B 使用了两个不同的符号 <code>s1</code> 和 <code>s2</code>, 都成为独立的绑定.
</p>

<pre class="example" id="org132393d">
  (defun grok (object)
    (pcase object
      ((and (pred consp)        ; seqpat A
	    (app car st)        ; first mention: st
	    (app cdr st))       ; second mention: st
       (list 'eq st))
      ((and (pred consp)        ; seqpat B
	    (app car s1)        ; first mention: s1
	    (app cdr s2))       ; first mention: s2
       (list 'not-eq s1 s2))))

  (let ((s "yow!"))
    (grok (cons s s)))      ⇒ (eq "yow!")
  (grok (cons "yo!" "yo!")) ⇒ (not-eq "yo!" "yo!")
  (grok '(4 2))             ⇒ (not-eq 4 (2))
</pre></li>

<li><p>
会产生副作用的代码对 SYMBOL 的引用是未定义的. 要避免使用. 例如, 下面是两个相似
的函数,都使用了 <code>and</code> , SYMBOL 和 <code>guard</code> :
</p>
<pre class="example" id="orge63fc17">
  (defun square-double-digit-p/CLEAN (integer)
    (pcase (* integer integer)
      ((and n (guard (&lt; 9 n 100))) (list 'yes n))
      (sorry (list 'no sorry))))

  (square-double-digit-p/CLEAN 9) ⇒ (yes 81)
  (square-double-digit-p/CLEAN 3) ⇒ (no 9)

  (defun square-double-digit-p/MAYBE (integer)
    (pcase (* integer integer)
      ((and n (guard (&lt; 9 (incf n) 100))) (list 'yes n))
      (sorry (list 'no sorry))))

  (square-double-digit-p/MAYBE 9) ⇒ (yes 81)
  (square-double-digit-p/MAYBE 3) ⇒ (yes 9)  ; WRONG!
</pre>
<p>
区别在于 <code>guard</code> 的布尔表达式中: <code>CLEAN</code> 简单且直接地引用 <code>n</code>, 而 <code>MAYBE</code> 在表
达式  <code>(incf n)</code> 中引用 <code>n</code> 有着副作用. 当 <code>integer</code> 是 3 时,会发生:
</p>
<ul class="org-ul">
<li>第一个 <code>n</code> 绑定为 EXPVAL, 也就是 <code>(* 3 3)</code> 的执行结果(9).</li>

<li><p>
布尔表达式的求值:
</p>
<pre class="example" id="orgda661f2">
    start:   (&lt; 9 (incf n)        100)
    becomes: (&lt; 9 (setq n (1+ n)) 100)
    becomes: (&lt; 9 (setq n (1+ 9)) 100)
    becomes: (&lt; 9 (setq n 10)     100)
				       ; side-effect here!
    becomes: (&lt; 9       n         100) ; ‘n’ now bound to 10
    becomes: (&lt; 9      10         100)
    becomes: t
</pre></li>

<li>因为求值结果非 <code>nil</code>, <code>guard</code> 匹配成功, <code>and</code> 匹配成功,控制权会递交到该子句
的主体表达式.</li>
</ul>
<p>
除了断言9是两位数的数学错误之外, <code>MAYBE</code> 还有另一个问题. 主体表达式再一次引用
了 <code>n</code>, 但是我们看不到更新后的值 10. 发生了什么?
</p>

<p>
总之,最好完全避免这种带副作用的 SYMBOL 模式的引用,不仅仅是在布尔表达式中
(<code>guard</code>), 在 EXPR (<code>let</code>) 和 FUNCTION <code>(pred) 以及 (app)</code> 中也是.
</p></li>

<li><p>
在匹配中,子句的主体表达式可以引用模式的 let 绑定的符号集. 当 SEQPAT 是 <code>and</code>
类型时, 这个集合是每个子模式所绑定的所有符号的并集.这是有道理的,因为 <code>and</code> 要
匹配成功,所有的子模式都必需匹配.
</p>

<p>
当 SEQPAT 是 <code>or</code> 类型时, 就有点不同了: <code>or</code> 在第一个子模式匹配成功时就匹配成
功; 剩下的子模式会被忽略. 每个子模式都绑定一个不同的符号集是说不通的,因为主体
表达式无法区分哪个子模式匹配成功了,并从中选择不同的集合. 例如,下面的操作是无法
成立的:
</p>
<pre class="example" id="org01a51e0">
  (require 'cl-lib)
  (pcase (read-number "Enter an integer: ")
    ((or (and (pred cl-evenp)
	      e-num)      ; bind ‘e-num’ to EXPVAL
	 o-num)           ; bind ‘o-num’ to EXPVAL
     (list e-num o-num)))

  Enter an integer: 42
  error→ Symbol’s value as variable is void: o-num
  Enter an integer: 149
  error→ Symbol’s value as variable is void: e-num
</pre>
<p>
对主体表达式 <code>(list e-num o-num)</code> 的求值会发出错误信号. 要区分子模式,你可以使
用另一个符号,在所有子模式中的名字都相同,但值会不同. 重做上面的例子:
</p>
<pre class="example" id="org3ae75e4">
  (require 'cl-lib)
  (pcase (read-number "Enter an integer: ")
    ((and num                                ; line 1
	  (or (and (pred cl-evenp)           ; line 2
		   (let spin 'even))         ; line 3
	      (let spin 'odd)))              ; line 4
     (list spin num)))                       ; line 5

  Enter an integer: 42
  ⇒ (even 42)
  Enter an integer: 149
  ⇒ (odd 149)
</pre>
<p>
行 1 排除了 EXPVAL 和 <code>and</code> 以及 SYMBOL (<code>num</code>)的绑定. 行2中, <code>or</code> 以与前面相
同的凡是开始,但是不是绑定不同的符号,而是在两个子模式中使用 <code>let</code> 两次(行3-4)
来绑定相同的符号 <code>spin</code>. <code>spin</code> 的值可以区分子模式. 主体表达式引用了这两个符号
(行5).
</p></li>
</ul>
</div>
</li>
</ul>
</li>

<li><a id="org89ff146"></a><span class="done DONE">DONE</span> 扩展 pcase(Extending <code>pcase</code>)<br />
<div class="outline-text-5" id="text-org89ff146">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-21 Thu 14:44]</span></span></li>
</ul>
<p>
定义新类型的模式.
</p>

<p>
<code>pcase</code> 宏支持多种模式(参见<a href="#org9b24c8c">模式匹配的条件(Pattern-Matching Conditional)</a>). 你可以
使用 <code>pcase-defmacro</code> 宏来为其他种类的模式添加支持.
</p>

<dl class="org-dl">
<dt>宏 <code>(pcase-defmacro name args [doc] &amp;rest body)</code></dt><dd><p>
为 <code>pcase</code> 定义一个新的模
式, 由 <code>(name actual-args)</code> 形式激活. <code>pcase</code> 宏会将其扩展为一个对 body 求值的
函数调用,这个函数调用的作用就是在一个 args 被绑定为 actual-args 的环境中,将激
活的模式重写为其他为模式.
</p>

<p>
此外,还会安排 doc 与 <code>pcase</code> 的文档字符串一起显示. 根据惯例, doc 应该使用
<code>EXPVAL</code> 来代表其对 EXPRESSION(<code>pcase</code> 的第一个参数) 求值的结果.
</p></dd>
</dl>


<p>
通常来讲, body 将重写已激活的模式来使用更多基本的模式.尽管所有的模式最终都会减少
为核心模式,但 body 不需要直接使用核心模式. 下面的示例定义了两个模式,名为
<code>less-than</code> 和 <code>integer-less-than</code>.
</p>
<pre class="example" id="orgc2abc67">
(pcase-defmacro less-than (n)
  "Matches if EXPVAL is a number less than N."
  `(pred (&gt; ,n)))

(pcase-defmacro integer-less-than (n)
  "Matches if EXPVAL is an integer less than N."
  `(and (pred integerp)
        (less-than ,n)))
</pre>
<p>
请注意,文档字符串按照普通的方式描述 args( 在这个例子中,只有一个参数 n), 并依照惯
例使用 <code>EXPVAL</code>. 第一个重写(也就是 less-than 的 body 部分)使用了一个核心模式
<code>pred</code>. 第二个使用了两个核心模式 <code>and</code> 和 <code>pred</code> 以及新定义的模式
<code>less-than</code>. 他们都使用了单个反引用构造(参见 <a href="#orgd7832f2">反引用(Backquote)</a>).
</p>

<blockquote>
<p>
这里的反引用构造,我的理解是, pcase-defmacro 中定义的内容是用于扩展的,是在扩展后
才会执行,因此要保证扩展时他们不会执行. 换个说法,他们的功能是最终扩展为一个函数,
用于 <code>(pcase expression &amp;rest clauses)</code> 中clauses 的 (pattern body-forms) 中的
pattern , pcase 将 pcase-defmacro 定义的主体重写后用于 pcase 才执行,不用反引用对
其表示不求值的话,在扩展过程中就会对 pcase-defmacro 的内容求值了.
</p>

<p>
哦,进一步理解下, pcase 宏会先对 pcase-defmacro 的 body 进行扩展求值(重写),然后
pcase 用重写后得到的新 pattern 执行子句,这就是第二次求值了,就像 <code>(eval)</code> 的参数
一样,eval 的函数调用会先对 eval 的参数求值,而 eval 的作用又是对其参数求值,因此会
求值两次.
</p>
</blockquote>
</div>
</li>




<li><a id="org9aff3fc"></a><span class="done DONE">DONE</span> 反引用风格的模式(Backquote-Style Patterns)<br />
<div class="outline-text-5" id="text-org9aff3fc">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-21 Thu 15:14]</span></span></li>
</ul>
<p>
结构化模式匹配.
</p>

<p>
这一小节描述的是 "反引用风格的模式", 这是一系列的可以让结构化匹配更容易的内置模
式. 相关背景知识,参见 <a href="#org9b24c8c">模式匹配的条件(Pattern-Matching Conditional)</a>.
</p>

<p>
反引用风格的模式是一个强大的 <code>pcase</code> 模式扩展集(使用 <code>pcase-defmacro</code> 创建的),
它让 EXPVAL 与其结构的规格匹配更加容易.
</p>

<p>
例如,要匹配一个必需是两个元素的列表,且第一个元素是指定字符串,第二个元素是任意值
的 EXPVAL, 你可以编写一个这样的核心模式:
</p>
<pre class="example" id="org31efae9">
(and (pred listp)
     ls
     (guard (= 2 (length ls)))
     (guard (string= "first" (car ls)))
     (let second-elem (cadr ls)))
</pre>
<p>
或者,你可以编写等价的反引用风格的模式:
</p>
<pre class="example" id="org14c18dc">
`("first" ,second-elem)
</pre>
<p>
反引用风格的模式更加简洁,看起来就像 EXPVAL 的结构,并且避免了绑定 ls
</p>

<p>
一个反引用风格的模式的格式是 <code>`QPAT</code> , QPAT 可以有以下这些形式:
</p>
<dl class="org-dl">
<dt><code>(QPAT1 . QPAT2)</code></dt><dd>如果 EXPVAL 是一个 cons cell, 其 car 匹配 QPAT1, CDR 匹配
QPAT2, 则匹配. 这很容易可以扩大为一个 <code>(QPAT1 QPAT2 ...)</code> 的列表.</dd>
<dt><code>[QPAT1 QPAT2 ... QPATM]</code></dt><dd>如果 EXPVAL 是一个 M 长度的向量,其第 <code>0</code>
.. <code>M-1</code> 个元素分别匹配 QPAT1 , QPAT2 &#x2026; QPATM.</dd>
<dt><code>SYMBOL</code></dt><dd></dd>

<dt><code>KEYWORD</code></dt><dd></dd>

<dt><code>NUMBER</code></dt><dd></dd>

<dt><code>STRING</code></dt><dd>如果 EXPVAL 相应的元素是 <code>equal</code> 于指定的字面值对象就匹配.</dd>
<dt><code>,PATTERN</code></dt><dd>如果 EXPVAL 的相应元素与 PATTERN 匹配则匹配. 请注意 PATTERN 是
<code>pcase</code> 支持的任意种类模式.(在上面例子中, second-elem 是一个 SYMBOL 核心模式;
因此匹配任何值,并绑定 second-elem.)</dd>
</dl>


<p>
EXPVAL 的 "相应元素" 是 EXPVAL 中与反引用风格模式中的 QPAT 具有相同的结构化位置
的元素.(在上面的例子中, second-elem 的相应元素是 EXPVAL 的第二个值)
</p>

<p>
下面是一个使用 <code>pcase</code> 为一种小表达语言实现一个简单的解释器的示例(请注意,这需要
对 fn 子句中的 lambda 表达式进行词法绑定来正确捕获 body 和 arg, 参见
<a href="#orge2ebb68">词法绑定(Lexical Bindings)</a>):
</p>
<pre class="example" id="org0dad97a">

(defun evaluate (form env)
  (pcase form
    (`(add ,x ,y)       (+ (evaluate x env)
                           (evaluate y env)))
    (`(call ,fun ,arg)  (funcall (evaluate fun env)
                                 (evaluate arg env)))
    (`(fn ,arg ,body)   (lambda (val)
                          (evaluate body (cons (cons arg val)
                                               env))))
    ((pred numberp)     form)
    ((pred symbolp)     (cdr (assq form env)))
    (_                  (error "Syntax error: %S" form))))
</pre>
<p>
前三个子句使用了反引用风格的模式. <code>`(add ,x ,y)</code> 是一个模式,检查 <code>form</code> 是否为一
个三元素的列表,且由字面值符号 <code>and</code> 开头,然后提取第二和第三个元素并将它们绑定为
x 和 y. 子句的 body 对 x 和 y 求值并对结果求和. 相似的, <code>call</code> 子句实现了一个函
数调用, <code>fn</code> 子句实现了一个匿名函数定义.
</p>

<p>
剩下的子句使用了核心模式. <code>(pred numberp)</code> 在 form 是一个数字是匹配. 如果匹配,则
body 会对 form 求值. <code>(pred symbolp)</code> 在 form 是一个符号时匹配. 如果匹配,则
body 会在 env 中查找符号并返回其联系. 最后 <code>_</code> 是一个匹配任意值的捕获所有的模式,
因此它适合用来报告语法错误.
</p>

<p>
下面是这个小语言中的一些示例程序,包括他们的执行结果:
</p>
<pre class="example" id="org108db05">
(evaluate '(add 1 2) nil)                 ⇒ 3
(evaluate '(add x y) '((x . 1) (y . 2)))  ⇒ 3
(evaluate '(call (fn x (add 1 x)) 2) nil) ⇒ 3
(evaluate '(sub 1 2) nil)                 ⇒ error
</pre>
</div>
</li>


<li><a id="orgd5b8eb6"></a><span class="done DONE">DONE</span> 使用 pcase 模式解构(Destructuring with pcase Patterns)<br />
<div class="outline-text-5" id="text-orgd5b8eb6">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-21 Thu 16:57]</span></span></li>
</ul>
<p>
使用 pcase 模式来提取子字段
</p>

<p>
pcase 模式不仅仅表示一个他们可以匹配的对象的表达式的状态,他们也可以从这些对象中
提取子字段. 例如,我们可以使用下面的代码从一个列表中提取出其值是变量 <code>my-list</code> 的
值的两个元素 :
</p>
<pre class="example" id="orgadbbad4">
(pcase my-list
  (`(add ,x ,y)  (message "Contains %S and %S" x y)))
</pre>
<p>
这个例子不仅仅是提取出了 x 和 y, 此外还会测试 my-list 是一个恰好包含三个元素的列
表,且其第一个元素是符号 <code>add</code>. 如果这些测试中的任意一点失败了, <code>pcase</code> 会立即返
回 <code>nil</code> ,而不调用 <code>message</code>
</p>

<p>
从对象中提取出多个储存在对象中的值被叫做 "解构". 使用 <code>pcase</code> 模式允许执行 "解构
绑定", 它与局部绑定很相似(参见 <a href="#org6826578">局部变量(Local Variables)</a>), 但是通过从一个合适的
结构中的对象中提取值可以将值赋予变量中的多个元素.
</p>

<p>
这一小节定义的宏使用 <code>pcase</code> 模式来执行解构绑定. 对象的状态要是合适的结构意味着
对象必需与模式匹配,因为只有这样对象的子字段才能被提取. 例如:
</p>
<pre class="example" id="org7e208a4">
(pcase-let ((`(add ,x ,y) my-list))
  (message "Contains %S and %S" x y))
</pre>
<p>
这个例子与上一个例子的功能相同,除了它直接尝试从 my-list 中提取 x 和 y 而没有先验
证 my-list 是否是一个有着正确元素个数以及有着 <code>and</code> 作为首个元素的列表. 当对象事
实上不与模式匹配时的行为是未定义的,但是其 body 不会静默地跳过: 要么会发出一个错
误信号,或者是 body 会使用某些潜在的变量绑定值(例如 <code>nil</code>) 来运行.
</p>

<p>
pcase 模式对于解构那些用 <a href="#org9aff3fc">反引用风格的模式(Backquote-Style Patterns)</a> 描述的绑定是
很有用的, 因为他们表达的是将要匹配的对象的解构规范.
</p>

<p>
对于另一种可用的解构绑定的功能,参见 <a href="https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Sequence-Functions">elisp#Sequence Functions</a> 中的 <code>seq-let</code> 宏.
</p>

<dl class="org-dl">
<dt>宏 <code>(pcase-let bindings body...)</code></dt><dd><p>
根据 bindings 执行变量的解构绑定,然后执行
body.
</p>

<p>
bindings 是一个 <code>(pattern exp)</code> 形式的绑定列表, 其中 exp 是一个要求值的表达式,
pattern 是一个 pcase 模式.
</p>

<p>
所有的 exp 会先被求值,在这之后,他们会与相应的 pattern 匹配,并引入新的可以在后
面的 body 中使用的变量绑定. 变量绑定是通过解构 pattern 中的元素绑定到相应的
exp 求值的元素来生成的.
</p></dd>
<dt>宏 <code>(pcase-let* bindings body...)</code></dt><dd><p>
根据 bindings 执行变量的解构绑定,然后执
行 body.
</p>

<p>
bindings 是一个 <code>(pattern exp)</code> 形式的绑定列表,其中 exp 是一个要求值的表达式,
pattern 是一个 pcase 模式. 变量绑定是通过解构 pattern 中元素的绑定到 exp 相应
的元素的值来生成的.
</p>

<p>
与 <code>pcase-let</code> 不同,但与 <code>let*</code> 相似, 在处理 bindings 的下一个元素之前, 每个
exp 都会与对应的 pattern 匹配, 这样在每个 bindings 中引入的变量绑定都可以在后
续的 bidings 的 exp 中使用,此外还在 body 中可用.
</p></dd>
<dt>宏 <code>(pcase-dolist (pattern list) body...)</code></dt><dd>对 list 中的每个元素都执行一次
body, 在每个迭代中都执行将 pattern 中的变量解构绑定到相应的 list 中的元素的子
字段的值. 绑定的执行就像是 <code>pcase-let</code> 执行的一样. 当 pattern 是一个简单变量时,这
个宏的行为与 <code>dolist</code> 等价(参见 <a href="#orgcf83ad9">迭代(Iteration)</a>).</dd>
<dt>宏 <code>(pcase-setq pattern value...)</code></dt><dd>根据相应的 pattern 解构每个值,并将值以一
种 <code>setq</code> 的形式赋予给变量.</dd>
</dl>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgcf83ad9" class="outline-4">
<h4 id="orgcf83ad9"><span class="done DONE">DONE</span> 迭代(Iteration)</h4>
<div class="outline-text-4" id="text-orgcf83ad9">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-15 Fri 14:01]</span></span></li>
</ul>
<p>
while 循环
</p>

<p>
迭代意味着重复执行程序的某个部分. 例如, 可能想要为列表中每个元素或为从 0 到 N 的
每个整数重复一次某些计算. 在 Emacs Lisp 中你可以使用特殊表达式 <code>while</code> 来做这件
事:
</p>
<dl class="org-dl">
<dt><code>(while condition forms...)</code></dt><dd><p>
<code>while</code> 先对 condition 求值. 如果结果为非
<code>nil</code> , 则会按照文本顺序对 forms 求值. 然后它会对 condition 再次求值, 如果结果
为非 <code>nil</code>, 就再次对 forms 求值. 这个过程会一直重复,直到 condition 求值为
<code>nil</code> 才停止.
</p>

<p>
对于可能发生的迭代没有次数限制. 循环会一直继续,直到 condition 求值为 <code>nil</code> 或
遇到错误或者是 <code>throw</code> 跳出循环(参见 <a href="#org61d300d">非局部退出(Nonlocal Exits)</a>).
</p>

<p>
<code>while</code> 表达式的值永远都是 <code>nil</code>.
</p>

<pre class="example" id="org78d2fde">
  (setq num 0)
       ⇒ 0
  (while (&lt; num 4)
    (princ (format "Iteration %d." num))
    (setq num (1+ num)))
       ⊣ Iteration 0.
       ⊣ Iteration 1.
       ⊣ Iteration 2.
       ⊣ Iteration 3.
       ⇒ nil
</pre>

<p>
要编写一个先重复再判断的循环,也就是每个迭代先执行某些操作,然后进行结束测试的循环,
请将主体后面跟上一个结束测试放在一个 <code>progn</code> 中作为 <code>while</code> 的第一个参数,就像
下面这样:
</p>
<pre class="example" id="org0dc84e9">
  (while (progn
	   (forward-line 1)
	   (not (looking-at "^$"))))
</pre>
<p>
这个表达式会向下移动一行,并持续的一行行移动,直到到达一个空行停止.这里的特殊之
处在于 <code>while</code> 没有主体部分,只有结束测试(结束测试也承担着移动光标的真实工作)
</p></dd>
</dl>


<p>
<code>dolist</code> 和 <code>dotimes</code> 宏提供了方便的方式来编写两种常用的循环.
</p>

<dl class="org-dl">
<dt><code>(dolist (var list [result]) body...)</code></dt><dd><p>
这个构造会为 list 中的每个元素执行一
次 body, 将变量 var 局部绑定到用来储存当前的元素. 然后它会返回 result 的求值结
果,如果 result 省略则返回 <code>nil</code>. 例如,下面这个例子是你如何使用 <code>dolist</code> 来定义
一个反转函数的:
</p>
<pre class="example" id="org8893040">
  (defun reverse (list)
    (let (value)
      (dolist (elt list value)
	(setq value (cons elt value)))))
</pre></dd>
<dt><code>(dotimes (var count [result]) body)</code></dt><dd><p>
这个构造为每个从 0(含) 到 count(不含)
的整数执行一次 body, 并将变量 var 绑定到当前迭代的整数. 然后它返回 result 的求
值结果,如果 result 省略则返回 <code>nil</code>. 并不赞成使用 result. 下面是一个使用
<code>dotimes</code> 来将某事做 100 次的例子:
</p>
<pre class="example" id="orgbf3e5c8">
  (dotimes (i 100)
    (insert "I will not obey absurd orders\n"))
</pre>
<pre class="example" id="orgc04c45c">
  (dotimes (n 10)
	   (print (format "%s times" n))
  )
</pre></dd>
</dl>
</div>
</div>
<div id="outline-container-org964311a" class="outline-4">
<h4 id="org964311a"><span class="done DONE">DONE</span> 生成器(Generators)</h4>
<div class="outline-text-4" id="text-org964311a">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-21 Thu 14:08]</span></span></li>
</ul>
<p>
泛型序列和协程.
</p>

<p>
生成器是一个产生潜在无限值流的函数. 函数每次生成一个值,它都会挂起自己,并等待其调
用者请求下一个值.
</p>

<dl class="org-dl">
<dt>宏 <code>(iter-defun name args [doc] [declare] [interactive] body...)</code></dt><dd><p>
<code>iterdefun</code> 定义一个生成器函数. 一个生成器函数与普通函数有着同样的特征,但是工
作方式不同. 一个生成器不是在被调用时执行 body, 而是返回一个迭代器对象. 这个迭
代器会运行 body 来生成值,发送出值并在 <code>iter-yield</code> 或 <code>iter-yield-from</code> 出现的
地方暂停. 当 body 正常地返回值时, <code>iter-next</code> 会发出一个
<code>iter-end-of-sequence</code> 的信号以及 body 的返回值作为其状态数据.
</p>

<p>
在 body 中任意类型的 Lisp 代码都是有效的, 但是 <code>iter-yield</code> 和
<code>iter-yield-from</code> 不能出现在 <code>unwind-protect</code> 表达式中.
</p></dd>

<dt>宏 <code>(iter-lambda args [doc] [interactive] body...)</code></dt><dd><code>iter-lambda</code> 生成一个
未命名的生成器函数,就像 <code>iter-defun</code> 生成的生成器函数一样运行.</dd>

<dt>宏 <code>(iter-yield value)</code></dt><dd>当出现在一个生成器函数中时, <code>iter-yield</code> 表示当前的
迭代器应该暂停并从 <code>iter-next</code> 返回 value. <code>iter-yield</code> 求值为 <code>iter-next</code> 的
下一个调用的的 <code>value</code> 参数</dd>

<dt>宏 <code>(iter-yield-from iterator)</code></dt><dd><code>iter-yield-from</code> 生成 iterator 产生的所有
值,并求值为该 iterator 的生成器函数正常返回的返回值. 当它拥有控制权时,
iterator 接收用 <code>iter-next</code> 发送给迭代器的值.</dd>
</dl>


<p>
要使用一个生成器函数,首先正常调用它,产生一个 "迭代器" 对象. 一个迭代器就是生成器
的一个特定的实例. 然后使用 <code>iter-next</code> 来取得来自这个迭代器的值. 当从迭代器中无
法取出更多值时, <code>iter-next</code> 会使用迭代器最后的值来生成一个
<code>iter-end-of-sequence</code> 状态.
</p>

<p>
需要注意的很重要的一点是生成器函数的主体只会在对 <code>iter-next</code> 的调用中被执行.对一
个由 <code>iter-defun</code> 定义的函数进行调用生成的是一个迭代器; 你必须使用 <code>iter-next</code>
来驱动这个迭代器. 对生成器函数的每次调用都会产生一个 <b>不同</b> 的迭代器,每一个都有
着他们自己的状态.
</p>

<dl class="org-dl">
<dt><code>(iter-next iterator value)</code></dt><dd><p>
从 iterator 中获取下一个值. 如果没有更多值要生
成了(因为 iterator 的生成器函数已经返回值了), <code>iter-next</code> 就会发出一个
<code>iter-end-of-sequence</code> 的状态信号; 与这个状态相关联的数据值就是 iterator 的生
成器函数的返回值.
</p>

<p>
value 是被发送到生成器并成为 <code>iter-yield</code> 要求值的值. value 会被给定迭代器的第
一个 <code>iter-next</code> 调用忽略,因为在 iterrator 的生成器函数的开头, 生成器函数还没
有对任何 <code>iter-yield</code> 表达式求值.
</p></dd>

<dt><code>(iter-close iterator)</code></dt><dd>如果 iterator 是在一个 <code>unwind-protect</code> 的主体表达
式中被暂停的,而且变得不可用了,那么 Emacs 最后会在一次垃圾收集发生后运行 unwind
处理器.(请注意 <code>iter-yield</code> 在 <code>unwind-protect</code> 的 <code>unwindforms</code> 中是不合法的)
要保证这些处理器提前运行规格,可以使用 <code>iter-close</code>.</dd>
</dl>


<p>
下面这个方便的宏函数让使用迭代器更加容易了:
</p>
<dl class="org-dl">
<dt><code>(iter-do (var iterator) body ...)</code></dt><dd><p>
按照 var 绑定为 iterator 生成的每个值来
运行 body.
</p>

<p>
Common Lisp 循环功能也提供了使用迭代器的特性. 参见 <a href="https://www.gnu.org/software/emacs/manual/html_mono/cl.html#Loop-Facility">cl#Loop Facility</a>.
</p></dd>
</dl>


<p>
下面的代码片段阐释了使用迭代器的一些重要原则:
</p>
<pre class="example" id="orgf3882e0">
(require 'generator)
(iter-defun my-iter (x)
  (iter-yield (1+ (iter-yield (1+ x))))
   ;; Return normally
  -1)

(let* ((iter (my-iter 5))
       (iter2 (my-iter 0)))
  ;; Prints 6
  (print (iter-next iter))
  ;; Prints 9
  (print (iter-next iter 8))
  ;; Prints 1; iter and iter2 have distinct states
  (print (iter-next iter2 nil))

  ;; We expect the iter sequence to end now
  (condition-case x
      (iter-next iter)
    (iter-end-of-sequence
      ;; Prints -1, which my-iter returned normally
      (print (cdr x)))))

</pre>
</div>
</div>

<div id="outline-container-org61d300d" class="outline-4">
<h4 id="org61d300d"><span class="done DONE">DONE</span> 非局部退出(Nonlocal Exits)</h4>
<div class="outline-text-4" id="text-org61d300d">
<p>
跳出序列.
</p>

<p>
一个 "非局部退出" 是将控制权从程序的某处转移到另一个远程点处. 在 Emacs Lisp 中非
局部退出可以作为错误的一种结果出现; 你也可以在显式控制下使用他们. 非局部退出会接
绑所有由正在退出的构造绑定的变量绑定.
</p>
</div>


<ul class="org-ul">
<li><a id="org67133ff"></a><span class="done DONE">DONE</span> Catch and Throw<br />
<div class="outline-text-5" id="text-org67133ff">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-21 Thu 19:10]</span></span></li>
</ul>
<p>
用于程序自身的用途的非局部退出.
</p>

<p>
大部分的控制构造只影响控制构造自身里的控制流程. 函数 <code>throw</code> 就是这条函数正常执
行的规则的例外: 它会根据要求执行非局部退出.(还有其他例外,但是他们只用于错误处
理.) <code>throw</code> 是用在一个 <code>catch</code> 的内部的,并会跳转回该 <code>catch</code>. 例如:
</p>
<pre class="example" id="org57fd83b">
(defun foo-outer ()
  (catch 'foo
    (foo-inner)))

(defun foo-inner ()
  ...
  (if x
      (throw 'foo t))
  ...)
</pre>
<p>
如果 <code>throw</code> 表达式执行了,直接将控制权转交回相应的 <code>catch</code>, 这会让函数立即返
回. <code>throw</code> 后面的代码就不会执行了. <code>throw</code> 的第二个参数是被用作 <code>catch</code> 的返回
值的.
</p>

<p>
函数 <code>throw</code> 会基于其第一个参数查找其匹配的 <code>catch</code>: 它会查找一个首个参数 <code>eq</code>
于 <code>throw</code> 中指定的值的 <code>catch</code>. 如果有多于一个的可用 <code>catch</code> ,则最里层的那个优
先. 因此,在上面的例子中, <code>throw</code> 指定了 <code>foo</code>, <code>foo-outer</code> 中的 <code>catch</code> 指定了相
同的符号,因此这个 <code>catch</code> 就是可用的那个(假设这里没有其他匹配的 <code>catch</code> 了).
</p>

<p>
执行 <code>throw</code> 会退出所有的 Lisp 构造(包括函数调用),直到匹配的 <code>catch</code> 为止. 当绑
定构造(例如 <code>let</code>) 或函数调用是以这种方式退出时,绑定操作是未绑定成功的,就像这些
构造是正常退出的一样(参见 <a href="#org6826578">局部变量(Local Variables)</a>). 同样的, <code>throw</code> 会恢复由
<code>save-excursion</code> (参见 <a href="#orgb7f4793">Excursions</a>)保存的缓冲区和位置信息以及 <code>save-restriction</code>
保存的伸缩状态. 当它从表达式中退出时,它也会执行任意使用 <code>unwind-protect</code> 特殊表
达式建立的清理操作(参见 <a href="#orgc6a8780">清理(Cleanups)</a>).
</p>

<p>
<code>throw</code> 不需要在词法上出现在它要跳转到的 <code>catch</code> 内部. 它也可以从 <code>catch</code> 中调用
的另一个函数中调用. 只要 <code>throw</code> 按照时间顺序出现在进入 <code>catch</code> 之后,退出
<code>catch</code> 之前,它就可以访问该 <code>catch</code>. 这就是为什么 <code>throw</code> 可以用在
例如 <code>exit-recursive-edit</code> 这样的返回编辑器命令循环的命令中了(参见
<a href="#orgeb295fc">递归编辑((Recursive Editing)</a>).
</p>
<blockquote>
<p>
Common Lisp 注意: 大部分其他版本的 Lisp, 包括 Common Lisp 有几种非顺序地转义控制
权的方式:例如, <code>return</code>, <code>return-from</code> 和 <code>go</code>. Emcas Lisp 只有
<code>throw</code>. <code>cl-lib</code> 库提供了一些这些方式的 emacs lisp 版本. 参见 <a href="https://www.gnu.org/software/emacs/manual/html_mono/cl.html#Blocks-and-Exits">cl#Blocks and Exits</a>.
</p>
</blockquote>

<dl class="org-dl">
<dt>特殊表达式 <code>(catch tag body...)</code></dt><dd><p>
<code>catch</code> 为 <code>throw</code> 函数建立一个返回点. 返
回点由 tag 指定,与其他的返回点不同, 其他的返回点可以是任意除了 <code>nil</code> 之外的
Lisp 对象. 参数 tag 在返回点建立之前会被正常求值.
</p>

<p>
返回点生效后, <code>catch</code> 按照文本顺序对 body 中的表达式求值. 如果表达式正常执行
(没有错误或非局部退出),body 的最后一个表达式的值会从 <code>catch</code> 返回.
</p>

<p>
如果在执行 body 期间有一个 <code>throw</code> 被执行了,且指定了相同的值 tag, 那么 <code>catch</code>
表达式会立即退出; 它的返回值是 <code>throw</code> 的第二个参数指定的值.
</p></dd>

<dt><code>(throw tag value)</code></dt><dd><p>
<code>throw</code> 的用途是从前面用 <code>catch</code> 建立的返回点返回. 参数
tag 是用来从各种已有返回点中选择的; 它必需与 <code>catch</code> 指定的值 <code>eq</code>. 如果多个返
回点与 tag 匹配,则最里层的一个会被使用.
</p>

<p>
参数 value 是用来作为 <code>catch</code> 的返回值的.
</p>

<p>
如果没有对应 tag 的返回点生效,那么就会发出一个 <code>no-catch</code> 且带有 <code>(TAG VALUE)</code>
的错误信号.
</p></dd>
</dl>
</div>
</li>

<li><a id="org99379d0"></a><span class="done DONE">DONE</span> Catch 的示例<br />
<div class="outline-text-5" id="text-org99379d0">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-25 Mon 12:11]</span></span></li>
</ul>
<p>
展示非局部退出是如何编写的.
</p>

<p>
使用 <code>catch</code> 和 <code>throw</code> 的一种方式是从双重嵌套循环中退出(在大多数语言中,这是通过
<code>goto</code> 完成的). 下面的例子我们计算 <code>(foo I J)</code> , 其中 I,J 是从0 到 9:
</p>
<pre class="example" id="org80dd2f7">
(defun search-foo ()
  (catch 'loop
    (let ((i 0))
      (while (&lt; i 10)
        (let ((j 0))
          (while (&lt; j 10)
            (if (foo i j)
                (throw 'loop (list i j)))
            (setq j (1+ j))))
        (setq i (1+ i))))))
</pre>
<p>
如果 <code>foo</code> 返回一个非 <code>nil</code> 值, 我们立即停止并返回一个 I 和 J 的列表. 如果 <code>foo</code>
一直返回 <code>nil</code>, <code>catch</code> 会正常返回,且返回值为 <code>nil</code> , 因为 <code>nil</code> 是 <code>while</code> 的返
回值.
</p>

<p>
下面是两个复杂的例子,有些许不同,一次展示两个返回点. 首先,两个返回点有着相同的标
签(tag) <code>tag</code>:
</p>
<pre class="example" id="org84c423b">
(defun catch2 (tag)
  (catch tag
    (throw 'hack 'yes)))
⇒ catch2

(catch 'hack
  (print (catch2 'hack))
  'no)
⊣ yes
⇒ no
</pre>
<p>
因为两个返回点都有着与 <code>throw</code> 匹配的标签, <code>throw</code> 会返回到最里层的那个,也就是
<code>catch2</code> 建立的返回点. 因此 <code>cathc2</code> 正常返回,返回值为 <code>yes</code> ,这个值会被打印. 最
后,在外层 <code>catch</code> 中的第二个主体表达式,也就是 <code>'no</code>, 会被求值,并从外层 <code>catch</code>
返回.
</p>

<p>
现在,我们改变一下给定于 <code>cathc2</code> 的参数:
</p>
<pre class="example" id="orgeb4510d">
(catch 'hack
  (print (catch2 'quux))
  'no)
⇒ yes
</pre>
<p>
我们仍然有着两个返回点,但是这次只有外层的返回点有着标签 <code>hack</code>; 内层的是标签
<code>quux</code>. 因此 <code>throw</code> 会让外层的 <code>catch</code> 返回值 <code>yes</code>. 函数 <code>print</code> 不会执行,主体
表达式 <code>'no</code> 也不会被求值.
</p>
</div>
</li>

<li><a id="org060e07a"></a><span class="done DONE">DONE</span> 错误(Errors)<br />
<div class="outline-text-5" id="text-org060e07a">
<p>
如何处理错误以及发送错误信号.
</p>

<p>
当 Emacs Lisp 试图对一个由于某些原因不能被求值的表达式求值时,它会发出一个错误信
号.
</p>

<p>
当一个错误信号被发出时, Emacs 的默认反应是打印一个错误消息并终结当前命令的执行.
在大多数情况下这是正确的做法,例如,如果你在缓冲区的末尾键入了 <code>C-f</code>.
</p>

<p>
在复杂的程序中,简单的终至程序可能不是你想要的. 例如, 程序可能对数据结构做出了临
时的更改,或创建了一些在程序完成前应该被删除的临时缓冲区. 在这种情况下,你可以使用
<code>unwind-protect</code> 来建立一个如果错误发生就要被执行的 "清理表达式" .(参见
<a href="#orgc6a8780">清理(Cleanups)</a>). 有时,你可能希望程序不管子程序中的错误继续执行. 在这些情况下,你
可以使用 <code>condition-case</code> 来建立 "错误处理器" 来应对错误.
</p>

<p>
不想使用错误处理器来将控制权从程序的某处移交到另一处; 那么请使用 <code>catch</code> 和
<code>throw</code> . 参见 <a href="#org67133ff">Catch and Throw</a>.
</p>
</div>

<ul class="org-ul">
<li><a id="orgbb2b586"></a><span class="done DONE">DONE</span> 发出错误信号(Signaling Errors)<br />
<div class="outline-text-6" id="text-orgbb2b586">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-25 Mon 13:43]</span></span></li>
</ul>
<p>
如何报告一个错误.
</p>

<p>
发出错误信号意味着开始错误处理. 错误处理通常会中止所有或部分正在运行的程序,并返
回到一个设置好的处理错误的返回点(参见<a href="#org33a604f">错误的处理(Processing of Errors)</a>). 这一部分
我们描述如何发出一个错误信号.
</p>

<p>
在你出于某些用途调用的 Lisp 原始函数中,大部分错误信号会自动发出, 例如,如果你试图
从一个整数中获取 CAR 或在缓冲区末尾向前移动一个字符. 你也可以使用函数 <code>error</code> 和
<code>signal</code> 来显式发出错误信号.
</p>

<p>
退出操作,也就是当用户键入 <code>C-g</code> 时发生地事情,不被认为是错误,但是几乎是被当作错误
一样处理的. 参见 <a href="#orge169eec">退出(Quiting)</a>.
</p>

<p>
每个错误都会以某种形式指定一个错误信息. 该信息应该说明出了什么错("文件不存在"),
而不是事情应该是怎样("文件必需存在"). Emacs Lisp 中的惯例是,错误消息应该以一个大
写字母开始,但是不应该以任意标点符号结束.
</p>

<dl class="org-dl">
<dt><code>(error format-string &amp;rest args)</code></dt><dd><p>
这个函数发出一个带错误消息的错误信号,该
错误消息是通过将 <code>format-message</code> (参见 <a href="#org993d6e9">格式化字符串(Formatting Strings)</a>)应用
到 format-string 和 args 上构造而成的.
</p>

<p>
这几个示例展现了 <code>error</code> 的典型用法:
</p>
<pre class="example" id="orgb0a1b52">
  (error "That is an error -- try something else")
       error→ That is an error -- try something else

  (error "Invalid name `%s'" "A%%B")
       error→ Invalid name ‘A%%B’
</pre>

<p>
<code>error</code> 是通过调用带两个参数的 <code>signal</code> 函数工作的,两个参数是错误符号 <code>error</code>
和一个由 <code>format-message</code> 返回的包含字符串的列表.
</p>

<p>
格式中的重音符和撇号通常会转换成匹配的弯括号,例如 "Missing `%s'" 可能会生成
"Missing ‘foo’". 关于如何影响或禁止这种转换,请参见
 <a href="#orgb8798d2">文本引用格式(Text Quoting Style)</a>.
</p>

<p>
 <b>警告</b> : 如果你想要使用你自己的字符串作为一个错误消息原型,不要直接编写
<code>(error string)</code>. 如果 string 中包含 <code>%</code>, <code>`</code> 或 <code>'</code>, 它可能会被重新格式化,造
成不想要的结果. 请使用 <code>(error "%s" string)</code>.
</p></dd>

<dt><code>(signal error-symbol data)</code></dt><dd><p>
这个函数发出一个由 error-symbol 命名的错误信号.参
数 data 是一个与错误的环境相关的额外 Lisp 对象的列表.
</p>

<p>
参数 error-symbol 必需是一个 "错误符号" ,一个由 <code>define-error</code> 定义的符号. 这
是 Emacs Lisp 如何将不同种类的错误分类的方式. 关于错误符号,错误状态和状态名的
信息,请参见 <a href="#org352a3c8">错误符号(Error Symbols)</a>.
</p>

<p>
函数 <code>(signal)</code> 永远没有返回值(试着执行下面的 signal 代码片段,会直接进入 Emacs
Lisp 的调试器).
</p>
<pre class="example" id="org04b0efe">
  (signal 'wrong-number-of-arguments '(x y))
       error→ Wrong number of arguments: x, y

  (signal 'no-such-error '("My unknown error condition"))
       error→ peculiar error: "My unknown error condition"
</pre></dd>

<dt><code>(user-error format-string &amp;rest args)</code></dt><dd><p>
这个函数与 <code>error</code> 的表现完全一致,
只不过它使用的是错误符号 <code>user-error</code> 而不是 <code>error</code>. 同样的建议, 这个函数是用
来在用户的部分报告错误的,而不是代码本身的错误.例如,如果你试图使用命令
<code>info-history-back (l)</code> 来移回到你的 info 浏览历史的开头, Emacs 会发出一个
<code>user-error</code> 的错误信号. 即使 <code>debug-on-error</code> 是非 <code>nil</code>, 这样的错误也不会导
致进入调试器. 参见 <a href="#org931ad9f">调试错误(Error Debugging)</a>.
</p>

<blockquote>
<p>
Common Lisp 提示: Emacs Lisp 里没有 Common Lisp 中可继续的错误的相关概念.
</p>
</blockquote></dd>
</dl>
</div>
</li>


<li><a id="org33a604f"></a><span class="done DONE">DONE</span> 错误的处理(Processing of Errors)<br />
<div class="outline-text-6" id="text-org33a604f">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2023-12-25 Mon 13:55]</span></span></li>
</ul>
<p>
当你报告错误时,Emcas 如何处理.
</p>

<p>
当发出错误信号时, <code>signal</code>  会为错误搜索一个激活的 "处理器". 处理器是专门设计来
处理 Lisp 程序中发生的错误的的一系列 Lisp 表达式. 如果错误有一个可用的处理器,则
该处理器会被执行,控制权会在处理器之后恢复. 处理器会在建立该处理器的
<code>condition-case</code> 的环境中执行; 该 <code>condition-case</code> 中所有被调用的函数都已经被退
出,处理器不能再返回到他们中.
</p>

<p>
如果错误没有可以应用的处理器. 它会中止当前的命令并将控制权返回给编辑器命令循
环.(命令循环有处理所有种类错误的隐式处理器.) 命令循环的错误处理器使用错误符号和
相关的数据来打印错误消息. 你可以使用变量 <code>command-error-function</code> 来控制这一过程
是如何完成的:
</p>
<dl class="org-dl">
<dt><code>command-error-function</code></dt><dd>如果这个变量非 <code>nil</code>, 则指定一个函数来处理将控制权
返回给 Emacs 命令循环的错误. 该函数应该接收三个参数: data, <code>condition-case</code> 会
绑定给其变量的相同表达式的列表; context , 一个字符串,描述错误发生的场景或(更常
见的) <code>nil</code>; caller, 调用发出错误信号的原始函数的 Lisp 函数.</dd>
</dl>


<p>
一个没有显式处理器的错误可能会调用 Lisp 调试器. 如果 <code>debug-on-error</code> (参见
<a href="#org931ad9f">调试错误(Error Debugging)</a>)变量非 <code>nil</code> , 与错误处理器不同, 调试器运行在错误发生
的环境中,因此,你可以精确地检查变量在错误发生时的值.
</p>
</div>
</li>

<li><a id="org715ee31"></a><span class="done DONE">DONE</span> 处理错误(Handling Errors)<br />
<div class="outline-text-6" id="text-org715ee31">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2024-01-10 Wed 17:05]</span></span></li>
</ul>
<p>
用户如何捕获错误并继续执行.
</p>

<p>
发出错误信号的常见影响是中止正在运行的命令并立即返回到 Emacs 编辑器命令循环. 你
可以通过使用特殊表达式 <code>condition-case</code> 来建立错误处理器去安排捕获发生在你的程序
中某个部分的错误.一个简单示例如下:
</p>
<pre class="example" id="orga20f5d8">
(condition-case nil
    (delete-file filename)
  (error nil))
</pre>
<p>
这个例子中删除了一个名为 filename 的文件,捕获任意错误,如果有错误发生则返回
<code>nil</code>. (你可以为这样的简单例子使用宏 <code>ignore-errors</code> ; 见下文.)
</p>

<p>
<code>condition-case</code> 构造通常用来捕获可以预测的错误, 例如在一个对
<code>insert-file-contents</code> 的调用中打开文件的失败. 它也用来捕获完全不可预测的错误,例
如,当程序执行一个读取自用户的表达式时.
</p>

<p>
<code>condition-case</code> 的第二个参数叫做 "被保护表达式".(在上面的例子中,被保护的表达式
是对 <code>delete-file</code> 的调用.) 错误处理器在该表达式开始执行时生效,在该表达式返回时
失效. 他们在这期间都是生效的. 特别地,他们在这个表达式调用的其他函数,其他子程序等
等的执行期间也是生效的. 这是一件好事,因为严格地讲,错误信号只能由被保护的表达式调
用的 Lisp 原始函数发出(包括 <code>signal</code> 和 <code>error</code>), 而不是由被保护的表达式自身发出.
</p>

<p>
被保护的表达式之后的参数是处理器. 每个处理器都列出一个或多个 "状态名" (符号类型)
来指定处理哪些错误. 当错误信号发出时,错误符号也指定一个状态名的列表. 如果他们有
着相同的状态名,则处理器就会应用到该错误上. 在上面的例子中,又一个处理器,指定了一
个状态名 <code>error</code>, 这个状态名涵盖了所有错误.
</p>

<p>
对于可应用的处理器的搜索会从最近建立的处理器开始检查所有已建立的处理器. 因此,如
果两个嵌套的 <code>condition-case</code> 表达式都提供了处理相同错误的处理器,两个处理器中最
里层的哪个会用来处理错误.
</p>

<p>
如果一个错误由某些 <code>condition-case</code> 表达式处理,这通常会阻止调试器的运行.即使
<code>debug-on-error</code> 说明这个错误应该激活调试器.
</p>

<p>
如果你想要能够调试由 <code>condition-case</code> 捕获的错误, 将变量 <code>debug-on-signal</code> 设置
为一个非 <code>nil</code> 值. 你也可以通过在状态中编写 <code>debug</code> 来指定某个特别的处理器应该让
调试器先运行,就像这样:
</p>
<pre class="example" id="org8a6581a">
(condition-case nil
    (delete-file filename)
  ((debug error) nil))
</pre>
<p>
这里的 <code>debug</code> 的作用只是阻止 <code>condition-case</code> 抑制调试器的调用. 只有当
<code>debug-on-error</code> 和其他常用的过滤机制说应该调用时,任意给定的错误才会激活调试器.
参见 <a href="#org931ad9f">调试错误(Error Debugging)</a>.
</p>

<dl class="org-dl">
<dt>宏 <code>(condition-case-unless-debug var protected-form handlers...)</code></dt><dd><code>condition-case-unless-debug</code> 宏提供了另一种方式来处理表达式的调试.它和
<code>condition-case</code> 的表现完全一样,除了当变量 <code>debug-on-error</code> 非 <code>nil</code> 时,在这种
情况下,它完全不会处理任何错误.</dd>
</dl>


<p>
一旦 Emcas 决定某个特定处理器处理错误,它会将控制权返回到该处理器. 为了这样做,
Emacs 会解除所有由正在退出的构造绑定的变量绑定,并执行所有正在被退出的
<code>unwind-protect</code> 表达式中的清理操作. 一旦控制权到达了处理器,处理器的主体会正常执
行.
</p>

<p>
在处理器的主体执行之后,执行操作从 <code>condition-case</code> 表达式返回. 因为被保护的表达
式在处理器执行之前已经完全退出了,处理器不能恢复到错误发生的位置的执行,也不能检查
被保护的表达式中的变量绑定.它能做的只有清理操作以及继续执行.
</p>

<p>
错误信号发出和错误的处理与 <code>throw</code> 和 <code>catch</code> 有相似之处(参见
<a href="#org67133ff">Catch and Throw</a>) ,但是他们是完全不同的功能. 错误不能被 <code>catch</code> 捕获, <code>throw</code> 不
能由错误处理器处理(尽管使用一个没有合适的 <code>catch</code> 的 <code>throw</code> 会导致一个可以被处
理的错误信号发出.).
</p>

<dl class="org-dl">
<dt><code>(condition-case var protected-form handlers...)</code></dt><dd><p>
这个特殊函数会围绕
protected-form 的执行建立一个错误处理器 handlers. 如果 protected-form 执行不出
错,它返回的值就是 <code>condition-case</code> 表达式的值(在这里缺失的错误处理器,在下面讨
论.); 在这种情况下 <code>condition-case</code> 没有(额外)效果. 当在 protected-form 执行期
间发生错误时, <code>condition-case</code> 才会对程序产生影响.
</p>

<p>
每个 handlers 都是一个表达式的列表 <code>(CONDITIONS BODY...)</code>. 这里的 CONDITIONS
是要处理的错误的状态名,或是一个状态名的列表(可以包括 <code>debug</code> 来允许调试器在处
理器之前运行). 状态名为 <code>t</code> 会匹配任意状态. BODY 是当处理器处理错误时要执行的
一个或多个 Lisp 表达式. 下面是一些 handlers 的示例:
</p>
<pre class="example" id="org9266cf8">
  (error nil)

  (arith-error (message "Division by zero"))

  ((arith-error file-error)
   (message
    "Either division by zero or failure to open a file"))
</pre>
<p>
每个发生的错误都有一个 "错误符号" 用来描述它是哪种错误,以及一个描述状态名的列
表(参见 <a href="#org352a3c8">错误符号(Error Symbols)</a> ). Emacs 会在所有激活的 <code>condition-case</code> 表达
式中查找某个处理器指定的一个或多个这样的状态名;最里层的与 <code>condition-case</code> 匹
配的处理器或处理这个错误. 在这个 <code>condition-case</code> 中, 第一个可应用的处理器会处
理错误.
</p>

<p>
在执行完处理器的主体后, <code>condition-case</code> 会正常返回, 使用处理器主体的最后一个
表达式的值作为(condition-case 这个表达式整体的)返回值.
</p>

<p>
参数 var 是一个变量. 在执行 protected-form 时, <code>condition-case</code> 不会绑定这个变
量,只有当错误发生时才会将其与值绑定. 在绑定它时,它会局部绑定为一个 "错误描述",
也就是一个给定了特定错误的列表. 错误描述的形式是 <code>(ERROR-SYMBOL . DATA)</code>. 处理
器可以引用该列表来决定怎么处理. 例如, 如果是打开文件失败的错误,文件名就是 DATA
的第二个元素,也就是错误描述的第三个元素.
</p>

<p>
如果 var 是 <code>nil</code>, 这意味着它没有进行变量绑定.那么错误符号和相关的数据对处理器
来说是不可用的.
</p>

<p>
作为一个特殊案例, handlers 可以是 <code>(:success BODY...)</code> 形式的列表,当
protected-form 结束且没有错误时, 这里的 BODY 就会执行,此时 var(如果非 <code>nil</code>)
是被绑定到 protected-form 的返回值的.
</p>

<p>
有时再次抛出一个由 <code>condition-case</code> 捕获的信号用于外层处理器来捕获是有必要的.
可以这样实现:
</p>
<pre class="example" id="org8cd7ce3">
  (signal (car err) (cdr err))
</pre>
<p>
这里的 <code>err</code> 是 "错误描述" 变量,也就是 <code>condition-case</code> 的第一个参数,其错误描
述就是你想要重新抛出的信号. 参见 <a href="#orgbb2b586">发出错误信号(Signaling Errors)</a>.
</p></dd>

<dt><code>(error-message-string error-descriptor)</code></dt><dd>这个函数为给定的错误描述符返回错
误消息字符串. 如果你想要为错误打印常见的错误信息,它会非常有用. 参见
<a href="#orgbb2b586">发出错误信号(Signaling Errors)</a></dd>
</dl>


<p>
下面是一个使用 <code>condition-case</code> 来处理由除以0导致的错误的示例. 处理器展示了错误
消息(但没有峰鸣声),然后返回一个非常大的数.
</p>
<pre class="example" id="orge3683b7">
(defun safe-divide (dividend divisor)
  (condition-case err
      ;; Protected form.
      (/ dividend divisor)
    ;; The handler.
    (arith-error                        ; Condition.
     ;; Display the usual message for this error.
     (message "%s" (error-message-string err))
     1000000)))
⇒ safe-divide

(safe-divide 5 0)
     ⊣ Arithmetic error: (arith-error)
⇒ 1000000
</pre>
<p>
这里的处理器指定了状态名 <code>arith-error</code> , 因此它只会处理被0除的错误. 其他的错误则
不会被(这个 <code>condition-case</code>)处理. 因此:
</p>
<pre class="example" id="org13710d2">
     (safe-divide nil 3)
          error→ Wrong type argument: number-or-marker-p, nil
</pre>
<p>
下面是一个捕获所有种类错误的 <code>condition-case</code> , 包括来自 <code>error</code> 的错误:
</p>
<pre class="example" id="orgc3b3798">
(setq baz 34)
     ⇒ 34

(condition-case err
    (if (eq baz 35)
        t
      ;; This is a call to the function ‘error’.
      (error "Rats!  The variable %s was %s, not 35" 'baz baz))
  ;; This is the handler; it is not a form.
  (error (princ (format "The error was: %s" err))
         2))
⊣ The error was: (error "Rats!  The variable baz was 34, not 35")
⇒ 2
</pre>


<dl class="org-dl">
<dt>宏 <code>(ignore-errors body...)</code></dt><dd><p>
这个构造会执行 body ,并忽略执行中发生的所有错
误. 如果执行中没有错误, <code>ignore-errors</code> 会返回 body 中最后一个表达式的值,否则,
会返回 <code>nil</code>.
</p>

<p>
下面的示例是使用 <code>ignore-errors</code> 重写的这个小节的开头的例子:
</p>
<pre class="example" id="orgbd22d2a">
  (ignore-errors
   (delete-file filename))
</pre></dd>

<dt>宏 <code>(ignore-error condition body...)</code></dt><dd><p>
这个宏与 <code>ignore-errors</code> 类似,但只会
忽略指定的错误状态.
</p>
<pre class="example" id="orga261684">
  (ignore-error end-of-file
    (read ""))
</pre>
<p>
condition 也可以是错误状态的列表.
</p></dd>

<dt>宏 <code>(with-demoted-errors format body...)</code></dt><dd>这个宏有点像是温和版本的
<code>ignore-errors</code> . 不是抑制所有的错误,而是将他们转换乘消息. format 是用来格式化
消息的字符串. format 应该包含一个 <code>%</code> 序列; 例如 <code>"Error: %S"</code>. 用
<code>with-demoted-errors</code> 包围预期不会发出错误信号的代码,可以在错误发生时保证代码
的健壮性. 请注意,这个宏内部使用的是 <code>condition-case-unless-debug</code> 宏而不是
特殊表达式 <code>condition-case</code>.</dd>
</dl>
</div>
</li>


<li><a id="org352a3c8"></a><span class="done DONE">DONE</span> 错误符号(Error Symbols)<br />
<div class="outline-text-6" id="text-org352a3c8">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2024-01-10 Wed 17:43]</span></span></li>
</ul>
<p>
如何对错误分类并捕获他们.
</p>

<p>
当你发出一个错误信号时,你应该指定一个 "错误符号" 来指定你心里的错误种类. 每个错
误都有且只有一个错误符号来将其分类. 这是 Emacs Lisp 语言定义的最好的错误分类方式.
</p>

<p>
这些狭义的分类被分组到一个更广泛的叫做 "错误状态" 的类层级结构,它们由 "状态名"
标识. 最狭义的这种分类是属于错误符号自身的: 每个错误符号也是状态名.还有更广泛的
分类的状态名,最广泛的状态名 <code>error</code> 包括了所有种类的错误(但没有 <code>quit</code>, 它类似错
误). 因此,每个错误都有一个或多个状态名: <code>error</code>, 如果与 <code>error</code> 不同,则是错误符
号,也许还有一些中间分类.
</p>

<dl class="org-dl">
<dt><code>(define-error name message &amp;optional parent)</code></dt><dd><p>
为了让一个符号成为错误符号,
它必需使用 <code>define-error</code> 进行定义,这会接受一个父级状态(默认为 <code>error</code>). 这个
parent 定义了这种错误所属的状态. 父级状态的传递集总是包含错误符号本身以及符号
<code>error</code>. 因为退出不被视为错误,所以 <code>quit</code> 的父级状态就是 <code>(quit)</code>.
</p>

<p>
除了父级状态之外,错误符号还有一个 message 参数,它是一个当发出错误信号但没有被
处理时要打印的字符串. 如果该消息(message) 是无效的,则会使用消息 <code>peculiar
  error</code> . 参见 <a href="https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Signaling-Errors">elisp#Signaling Errors</a>.
</p>

<p>
在函数内部,父级状态集合是储存在错误符号的 <code>error-conditions</code> 属性中的,message
是储存在错误符号的 <code>error-message</code> 属性中的.
</p>

<p>
下面是我们如何定义一个新的错误符号的例子, <code>new-error</code>:
</p>
<pre class="example" id="orgc6fdb27">
  (define-error 'new-error "A new error" 'my-own-errors)
</pre>
<p>
这个 error 有几个状态名: <code>new-error</code>, 最狭义的分类; <code>my-own-errors</code>, 我们假设
的一个更广泛的分类;以及 <code>my-own-errors</code> 中所有状态都应该包括的 <code>error</code>, 它是所
有状态中最广泛的.
</p>

<p>
错误字符串应该以大写字母开头,但不应该以句号结尾. 这是为了与 Emacs 的其他部分保
持一致.
</p>

<p>
通常来讲, Emacs 永远不会自己发出 <code>new-error</code> 的错误信号; 只有当你的代码中显式
调用了 <code>signal</code> 时才会发出这种错误信号:
</p>
<pre class="example" id="org539003d">
  (signal 'new-error '(x y))
       error→ A new error: x, y
</pre>
<p>
这个错误可以通过它的任意一个状态名来处理. 下面的例子处理 <code>new-error</code> 以及在
<code>my-own-errors</code> 中的其他错误:
</p>
<pre class="example" id="orgaf3ab51">
  (condition-case foo
      (bar nil t)
    (my-own-errors nil))
</pre>
<p>
对错符分类的重要方法是通过他们的状态名&#x2013;用于将错误与处理器匹配. 错误符号只是用
来指定与其的错误消息和状态名列表的一种方便的方式. 给 <code>signal</code> 一个状态名列表而
不是一个错误符号会很麻烦.
</p>

<p>
相反地,只使用不带状态名的错误符号会严重降低 <code>condition-case</code> 的 "威力". 当你编
写一个错误处理器时, 状态名能够对各种通用级别的错误进行分类. 单独使用错误符号将
消除最狭义的分类层级之外的所有分类.
</p></dd>
</dl>


<p>
关于主要的错误符号和他们的状态的列表,请参见 <a href="#org045e0c5">标准错误(Standard Errors)</a>.
</p>
</div>
</li>
</ul>
</li>

<li><a id="orgc6a8780"></a><span class="done DONE">DONE</span> 清理(Cleanups)<br />
<div class="outline-text-5" id="text-orgc6a8780">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2024-01-10 Wed 18:40]</span></span></li>
</ul>
<p>
如果有错误发生,安排运行一次表达式的清理.
</p>

<p>
每当你将一个数据结构临时置于一种不一致的状态时, <code>unwind-protect</code> 构造就是至关重
要的,它能让你在错误或抛出发生时使数据再次保持一致.(一个更具体的清理构造是原子变
化组,它仅仅用于缓冲区内容的改变; 参见 <a href="#org78e262a">原子变化(Atomic Changes)</a>)
</p>


<dl class="org-dl">
<dt>特殊表达式 <code>(unwind-protect body-form cleanup-forms...)</code></dt><dd><p>
<code>unwind-protect</code>
会执行 body-from 并保证如果控制权从 body-form 离开,则不管发生什么,都会对
cleanup-forms 求值. body-form 可能会正常完成,或执行一个 <code>unwind-protect</code> 之外
的 <code>throw</code>, 或造成一个错误;在所有这些情况下, cleanup-forms 都会被求值.
</p>

<p>
如果 body-form 正常结束, <code>unwind-protect</code> 在对 cleanup-forms 求值后会返回
body-form 的值. 如果 body-form 没有结束, <code>unwind-protect</code> 不会返回任何正常意义
上的值.
</p>

<p>
只有 body-form 是被 <code>unwind-protect</code> 保护的. 如果任意的 cleanup-forms 自身非局
部退出了(通过错误或 <code>throw</code>), <code>unwind-protect</code> 不会保证对剩下的部分求值. 如果
cleanup-forms 中的表达式的失败可能会造成麻烦,那么请将该表达式使用另一个
<code>unwind-protect</code> 保护起来.
</p>

<p>
当前激活的 <code>unwind-protect</code> 表达式数量以及局部变量绑定的数量会达到
<code>max-specpdl-size</code> 的限制(参见 <a href="#org6826578">局部变量(Local Variables)</a>).
</p>

<p>
例如, 这里我们为了暂时的用途生成了一个不可见的缓冲区,并确保在结束前关闭它:
</p>
<pre class="example" id="orga58f8fb">
  (let ((buffer (get-buffer-create " *temp*")))
    (with-current-buffer buffer
      (unwind-protect
	  BODY-FORM
	(kill-buffer buffer))))
</pre>
<p>
你可能会想,我们也可以编写 <code>(kill-buffer (current-buffer))</code> 并省却变量
<code>buffer</code>. 然而, 如果 body-form 碰巧在转换到一个不同的缓冲区后发生了错误!上面例
子中的方式是更安全的.(或者,你可以在 body-form 周围写入 <code>save-current-buffer</code>,
来确保在关闭缓冲区时临时缓冲区再次成为当前的缓冲区.)
</p></dd>
</dl>


<p>
Emacs 有一个标准宏,叫做 <code>with-temp-buffer</code> , 它会扩展为上面显示代码的更多或更少
(参见<a href="#org75e596b">当前缓冲区(Current Buffer)</a>). 这个手册中定义的几个宏是以这种方式使用
<code>unwind-protect</code> 的.
</p>

<p>
下面是一个来自 FTP 包的真实示例. 例子中创建了一个进程(参见 <a href="#org301788e">进程(Processes)</a>) 用来
试图创建一个与远程机器的连接. 因为函数 <code>ftp-login</code> 非常可能导致许多的程序的编写
者没能预料的问题,所以它被一个能保证在失败事件中删除该进行的表达式所保护着.否则,
Emacs 可能会被无用的子进程给填满.
</p>
<pre class="example" id="orgd72a2a6">
(let ((win nil))
  (unwind-protect
      (progn
        (setq process (ftp-setup-buffer host file))
        (if (setq win (ftp-login process host user password))
            (message "Logged in")
          (error "Ftp login failed")))
    (or win (and process (delete-process process)))))
</pre>

<p>
这个示例又一个小 bug: 如果用户键入 <code>C-g</code> 来退出,并且退出立即发生在函数
<code>ftp-setup-buffer</code> 返回之后,变量 <code>process</code> 设置之前, 那么进程就不会被关闭.没有简
单的方式来修复这个 bug, 但至少这种碰巧的情况不太可能发生.
</p>
</div>
</li>
</ul>
</div>
</div>


<div id="outline-container-org7e787fa" class="outline-3">
<h3 id="org7e787fa"><span class="todo NEXT">NEXT</span> 变量(Variables)</h3>
<div class="outline-text-3" id="text-org7e787fa">
<p>
在程序中使用符号来表示值.
</p>

<p>
一个 "变量" 是程序中用来代表一个值的名字. 在 Lisp 中, 每个变量是由一个 Lisp 符号
(参见 <a href="#orgf14e561">符号(Symbols)</a> .)表示的. 变量名只是符号的名字,变量的值是储存在符号的值单元
<sup><a id="fnr.9" class="footref" href="#fn.9" role="doc-backlink">9</a></sup>中的
</p>

<p>
正如在手册的前面提到的一样, 一个 Lsip 程序主要是由 Lisp 对象表示的,其次才是文本.
一个 Lisp 程序的文本形式是由组成程序的 Lisp 对象的读取语法给定的. 因此,在 Lisp
程序中,一个变量的文本形式是使用表示变量的符号的读取语法来编写的.
</p>
</div>

<div id="outline-container-org7542c90" class="outline-4">
<h4 id="org7542c90"><span class="done DONE">DONE</span> 全局变量(Global Variables)</h4>
<div class="outline-text-4" id="text-org7542c90">
<p>
永久存在,且无处不在的变量值.
</p>

<p>
使用变量最简单地方法是 "全局地" 使用. 这意味着该变量同一时间只有一个值,并且这个
值在整个 Lisp 系统中都有效(至少在当时有效). 直到你指定一个新值之前,该值都会保持
有效. 当新的值替换了旧的值时,旧值不会在这个变量中保留痕迹.
</p>

<p>
你可以使用 <code>setq</code> 来将一个值指定给一个符号. 例如:
</p>
<pre class="example" id="org1114140">
(setq x '(a b))
</pre>
<p>
这个例子将值 <code>(a b)</code> 赋予给变量 <code>x</code>. 请注意, <code>setq</code> 是一个特殊表达式(参见
<a href="#org1ce4062">特殊表达式(Special Forms)</a>); 它不会对其第一个参数求值,也就是变量的名字,但是它会对
第二个参数求值,也就是新的值 <code>(a b)</code>.
</p>

<p>
一旦变量有了值,你可以通过使用符号本身作为表达式来引用这个值. 因此,
</p>
<pre class="example" id="orga33b1ec">
     x ⇒ (a b)
</pre>
<p>
假设上面的 <code>setq</code> 表达式已经被执行过了.
</p>

<p>
如果你再次设置相同的变量,那么新的值将会替代旧的值:
</p>
<pre class="example" id="org16dea3a">
x
     ⇒ (a b)
(setq x 4)
     ⇒ 4
x
     ⇒ 4

</pre>
</div>
</div>

<div id="outline-container-orgde44202" class="outline-4">
<h4 id="orgde44202"><span class="done DONE">DONE</span> 常量(Constant Variable)</h4>
<div class="outline-text-4" id="text-orgde44202">
<ul class="org-ul">
<li>State "DONE"       from "NEXT"       <span class="timestamp-wrapper"><span class="timestamp">[2024-01-11 Thu 08:10]</span></span></li>
</ul>
<p>
永远不变的变量.
</p>

<p>
在 Emacs Lisp 中,某些符号通常求值为他们自身. 这些符号包括 <code>nil</code> 和 <code>t</code>, 以及任何
名字以 <code>:</code> 开头的符号(他们被叫做 "关键词"). 这些符号不能被重新绑定,他们的值也不
能被改变. 任何试图设置或者绑定 <code>nil</code> 或 <code>t</code> 的尝试都会发出一个
<code>setting-constant</code> 的错误信号. 对于关键词(以 <code>:</code> 作为名称开头的符号)也是如此, 如
果符号被插入到标准的 obarray 中,只有设置这样的符号为自身不是错误.
</p>
<pre class="example" id="org116ad22">
nil ≡ 'nil
     ⇒ nil
(setq nil 500)
error→ Attempt to set constant symbol: nil
</pre>

<dl class="org-dl">
<dt><code>(keywordp object)</code></dt><dd>如果 object 是一个名称以 <code>:</code> 开头的符号,且位于标准的
obarray 中, 则返回 <code>t</code>, 否则,返回 <code>nil</code> .</dd>
</dl>


<p>
这些常量从根本上与使用 <code>defconst</code> 特殊表达式定义的常量不同(参见
<a href="#org01c338c">定义变量(Defining Variables)</a>). 一个 <code>defconst</code> 表达式是用于告知人类阅读者你不应
该打算更改这个变量的值,但是如果你真的更改了, Emacs 不会发出错误信号.
</p>

<p>
处于各种实际的原因,少数额外的符号被设置为只读. 这些符号包括
<code>enbale-multibyte-characters</code> , <code>most-positive-fixnum</code> , <code>most-negative-fixnum</code>
, 和其他的少数几个. 任何设置或绑定这些符号的尝试都会发出一个 <code>setting-constant</code>
错误信号.
</p>
</div>
</div>

<div id="outline-container-org6826578" class="outline-4">
<h4 id="org6826578"><span class="done DONE">DONE</span> 局部变量(Local Variables)</h4>
<div class="outline-text-4" id="text-org6826578">
<p>
变量值只暂时存在的变量.
</p>

<p>
全局变量的值会一直保持,直到被新值显式替换. 有时给定一个变量 "局部值"(一种只在
Lisp 程序的特定部分中有效的值) 是很有用的. 当一个变量有着局部值时,我们称它是"局
部绑定" 到该值,称这个变量是 "局部变量".
</p>

<p>
例如,当一个函数被调用时,它的参数变量会接收局部值,也就是提供给函数调用的实际参数
值;这些局部绑定在函数的主体内有效. 另一个例子, 特殊表达式 <code>let</code> 会为特定变量显式
建立局部绑定,这种绑定也只在 <code>let</code> 表达式的主体内有效.
</p>

<p>
我们也谈到 "全局绑定",即全局值保存的地方(概念上).
</p>

<p>
建立一个局部绑定会保存变量先前的值(或值的缺失). 我们称先前的值被 "覆盖" 了.全局
和局部值都可能被覆盖. 如果一个局部绑定是生效的,对该局部变量使用 <code>setq</code> 会将特定
值储存在局部绑定中. 当局部绑定不再生效时,先前被覆盖的值(或值的缺失状态)会恢复.
</p>

<p>
一个变量在同一时间可以拥有超过多于一个的局部绑定(例如, 如果有嵌套的 <code>let</code> 表达式
绑定了该变量). "当前绑定" 是实际上正在生效的局部绑定.它会决定对变量符号求值返回
的值,并且是由 <code>setq</code> 进行的绑定.
</p>

<p>
多余大多数用途来说, 你可以将当前绑定视为最内层的局部绑定,或是一个没有局部绑定的
全局绑定. 更精确地讲,一个名为 "作用域规则" 的规则决定了局部绑定在程序的哪里有效.
Emacs 中默认的作用域规则叫做 "动态作用域", 该规则简单规定了一个程序的执行中任意
给定位置的当前绑定是仍然存在的变量的最近创建的绑定. 关于动态作用域的细节,以及另
外一种叫做 "词法作用域" 的规则,请参见 <a href="#orgc0f0806">变量范围(Variable Scoping)</a>.
</p>

<p>
特殊表达式 <code>let</code> 和 <code>let*</code> 是为了创建局部绑定存在的:
</p>
<dl class="org-dl">
<dt><code>(let (bindings...) forms...)</code></dt><dd><p>
这个特殊表达式为由 bindings 指定的特定的变量集设置局部绑定,然后按照文本顺序对
所有 forms 求值. 该表达式的返回值是 forms 最后一个表达式的值. 由 <code>let</code> 设置的
局部绑定只会在 forms 的主体内部生效.
</p>

<p>
bindings 中的每个绑定可以是:
</p>
<ul class="org-ul">
<li>符号,这种情况下,该符号局部绑定到 <code>nil</code>.</li>

<li><code>(SYMBOL VALUE-FORM)</code> 的列表, 这种情况下, SYMBOL 会被局部绑定到 VALUE-FORM
的求值结果, 如果 VALUE-FORM 省略,则绑定到 <code>nil</code>.</li>
</ul>

<p>
bindings 中所有的 VALUE-FORM 在绑定到任意符号之前会先按照它们出现的顺序进行求
值. 下面是一个示例: <code>z</code> 被绑定到 <code>y</code> 的旧有的值,也就是 2, 而不是 y 的新值,1
</p>
<pre class="example" id="org5e61523">
  (setq y 2)
       ⇒ 2

  (let ((y 1)
	(z y))
    (list y z))
       ⇒ (1 2)
</pre>
<p>
另一方面,绑定的顺序是未指定的: 下面的示例中, 1 或 2 都可能被打印:
</p>
<pre class="example" id="orgbba5203">
  (let ((x 1)
	(x 2))
    (print x))
</pre>
<p>
因此,要避免在一个 <code>let</code> 表达式中对一个变量多次绑定.
</p></dd>

<dt><code>(let* (bindings...) forms...)</code></dt><dd><p>
这个特殊表达式与 <code>let</code> 很像,但是它在每个变量的局部值计算完毕之后, 下一个变量的
局部值计算之前立即绑定该变量. 因此,在 <code>let*</code> 表达式中, bindings 里的表达式可以
引用前面的符号绑定. 将下面例子与 <code>let</code> 比较:
</p>
<pre class="example" id="orga588bee">
  (setq y 2)
       ⇒ 2

  (let* ((y 1)
	 (z y))    ; Use the just-established value of ‘y’.
    (list y z))
       ⇒ (1 1)
</pre></dd>

<dt><code>(letrec (bindings...) forms...)</code></dt><dd><p>
这个特殊表达式与 <code>let*</code> 很像, 但是所有的
变量会在局部值计算之前进行绑定. 然后这些值才会被分配给局部绑定的变量.  这只在
词法绑定生效,且你想要创建一个闭包结构来引用一些使用 <code>let*</code> 无法生效的绑定时有
用.
例如, 下面是一个闭包结构,它在运行一次之后从将它自己从钩子中移除:
</p>
<pre class="example" id="orge7b3600">
  (letrec ((hookfun (lambda ()
		      (message "Run once")
		      (remove-hook 'post-command-hook hookfun))))
    (add-hook 'post-command-hook hookfun))
</pre></dd>

<dt><code>(dlet (bindings...) forms...)</code></dt><dd><p>
这个特殊表达式与 <code>let</code> 很像,但是它将所有变
量动态绑定. 这个表达式在很少的情况下有用-你通常会想要词法绑定正常变量,而动态绑
定特殊变量(也就是使用 <code>defvar</code> 定义的变量),而这正是 <code>let</code> 的用法.
</p>

<p>
当与假定特定的变量是动态绑定(参见 <a href="#org5437ee7">动态绑定(Dynamic Binding)</a>), 但无法将这些变量
用 <code>defvar</code> 重新定义的旧代码进行交互时, <code>dlet</code> 会有用处. <code>dlet</code> 会暂时将绑定的
变量标记为特殊变量,执行表达式,然后再将变量标记为非特殊.
</p></dd>

<dt><code>(named-let name bindings &amp;reset body)</code></dt><dd><p>
这个特殊表达式是一个受 Scheme 语言启发的循环构造. 它与 <code>let</code> 相似: 它会绑定
bindings 中的变量,然后执行 body. 然而, <code>named-let</code> 也会将 name 绑定到一个局部
函数中,这个函数的正式参数是 bindings 中的变量,函数主体是 body. 这就可以让 body
通过调用 name 来调用它自身,而传递给 name 的参数会用作递归调用中绑定变量的新值.
</p>

<p>
一个对数字列表循环求和的例子:
</p>
<pre class="example" id="orgc900330">
  (named-let sum ((numbers '(1 2 3 4))
		  (running-sum 0))
    (if numbers
	(sum (cdr numbers) (+ running-sum (car numbers)))
      running-sum))
  ⇒ 10
</pre>
<p>
出现在 body 尾部位置对 name 的递归调用必然会被优化为尾部调用, 这意味着不管递归
运行到多深层级,他们都不会消耗任何额外的栈空间. 这样的递归调用会高效地跳转到带
有变量新值的循环的顶部.
</p>

<p>
如果一个函数的调用是最后完成的事情,那么该函数调用就是尾部位置,因此该调用返回的
值就是 body 自身的值,就和上面对 <code>sum</code> 的调用一样.
</p></dd>
</dl>


<p>
下面是一个创建局部绑定的其他功能的列表:
</p>
<ul class="org-ul">
<li>函数调用(参见 <a href="#org5921345">函数(Functions)</a>).</li>
<li>宏调用(参见 <a href="#org15d607f">宏(Macros)</a>).</li>
<li><code>condition-case</code> (参见 <a href="#org060e07a">错误(Errors)</a>).</li>
</ul>


<p>
变量也可以有缓冲区局部绑定(参见 <a href="#org002980b">缓冲区局部变量(Buffer-Local Variables)</a>); 少数变
量有终端局部绑定(参见 <a href="#org70d6964">多终端(Multiple Terminals)</a>). 这些绑定某种程度上像原始的局
部绑定一样运作,但是他们的 "局部化" 取决于你在 Emacs 中的位置.
</p>

<dl class="org-dl">
<dt>用户选项 <code>max-specpdl-size</code></dt><dd><p>
这个变量定义了局部变量绑定和 <code>unwind-protect</code>
清理(参见 <a href="#orgc6a8780">清理(Cleanups)</a>)的总共数量限制.在达到限制后, Emacs 会发出一个错误信号
(带着数据 <code>"Variable binding depth exceeds max-specpdl-size"</code>)
</p>

<p>
这个限制以及当超出限制时的相关错误,是 Lisp 避免错误定义的函数产生无限递归的一
种方式. <code>max-lisp-eval-depth</code> 为嵌套提供了另一种限制. 参见 <a href="#org823d079">执行(Eval)</a>.
</p>

<p>
其默认值是 1600. 如果只有少许空间可用了,那么进入到 Lisp 调试器后会增加该值,来
保证调试器自身有足够的空间去执行.
</p></dd>
</dl>
</div>
</div>

<div id="outline-container-org5fe7735" class="outline-4">
<h4 id="org5fe7735"><span class="done DONE">DONE</span> 空变量(Void Variables)</h4>
<div class="outline-text-4" id="text-org5fe7735">
<p>
缺少值的符号.
</p>

<p>
如果一个变量的符号有着一个未分配的值单元(参见 <a href="#org971770a">符号组成(Symbol Components)</a>),则我
们称这个变量是"空的".
</p>

<p>
在 Emacs Lisp 的默认动态作用域规则(参见 <a href="#orgc0f0806">变量范围(Variable Scoping)</a>)下, 值单元会
储存变量的当前值(全局或局部). 请注意,一个未分配的值单元与值单元为 <code>nil</code> 是不同的.
符号 <code>nil</code> 是一个 Lisp 对象,可以作为变量的值,就如同其他对象一样; 但它仍然是一个
值. 如果变量为空, 那么对变量的求值会发出一个 <code>void-variable</code> 的错误信号, 而不是
返回一个值.
</p>

<p>
在可选的词法作用域规则下, 值单元只会保存变量的全局值-也就是在任意词法绑定构造之
外的值. 当一个变量被词法绑定时, 局部值由词法环境决定; 因此,即使符号的值单元没有
被分配值,变量也可以拥有局部值.
</p>

<dl class="org-dl">
<dt><code>(makunbound symbol)</code></dt><dd><p>
这个函数会清空 symbol 的值单元,让该变量为空.并返回
symbol.
</p>

<p>
如果 symbol 是动态局部绑定的, <code>makunbound</code> 会清空当前绑定,并且这个"空"只要局部
绑定生效就会持续.之后,前面"覆盖"的局部或全局绑定会重新"暴露"; 然后变量就不再为
空了,除非这个重新"暴露"的绑定也将其设置为空.
</p>

<p>
下面是一些示例(假定动态绑定在生效):
</p>
<pre class="example" id="org189fece">
  (setq x 1)               ; Put a value in the global binding.
       ⇒ 1
  (let ((x 2))             ; Locally bind it.
    (makunbound 'x)        ; Void the local binding.
    x)
  error→ Symbol's value as variable is void: x
  x                        ; The global binding is unchanged.
       ⇒ 1

  (let ((x 2))             ; Locally bind it.
    (let ((x 3))           ; And again.
      (makunbound 'x)      ; Void the innermost-local binding.
      x))                  ; And refer: it’s void.
  error→ Symbol's value as variable is void: x

  (let ((x 2))
    (let ((x 3))
      (makunbound 'x))     ; Void inner binding, then remove it.
    x)                     ; Now outer ‘let’ binding is visible.
       ⇒ 2
</pre></dd>

<dt><code>(boundp variable)</code></dt><dd><p>
如果 variable (一个符号) 不是空的,则返回 <code>t</code> ,否则,返
回 <code>nil</code>.
</p>

<p>
下面是一些示例(假定动态绑定生效):
</p>
<pre class="example" id="org170dd7f">
  (boundp 'abracadabra)          ; Starts out void.
       ⇒ nil
  (let ((abracadabra 5))         ; Locally bind it.
    (boundp 'abracadabra))
       ⇒ t
  (boundp 'abracadabra)          ; Still globally void.
       ⇒ nil
  (setq abracadabra 5)           ; Make it globally nonvoid.
       ⇒ 5
  (boundp 'abracadabra)
       ⇒ t
</pre></dd>
</dl>
</div>
</div>

<div id="outline-container-org01c338c" class="outline-4">
<h4 id="org01c338c"><span class="todo TODO">TODO</span> 定义变量(Defining Variables)</h4>
<div class="outline-text-4" id="text-org01c338c">
<p>
用来说明符号被用作变量的定义.
</p>

<p>
一个 "变量定义" 就是一个宣告你要将该符号作为一个全局变量的构造. 它使用特殊表达式
<code>defvar</code> 或 <code>defconst</code> 来构建,这两个特殊表达式在下面有文档描述.
</p>

<p>
变量定义有三种用途. 第一种,它告知阅读代码的人该符号被用作特定用途(变量).第二种用
途, 它告知 Lisp 系统该符号被用作特定用途,还可能会提供一个初始值以及文档字符串.
第三种用途, 它为编程工具(例如 <code>etags</code>) 提供信息,来让这些工具能够找到变量在哪里被
定义的.
</p>

<p>
<code>defconst</code> 和 <code>defvar</code> 之间的区别主要在于意图,用来告知人类阅读者变量值是否应该更
改. Emacs Lisp 实际上并不会阻止你修改一个用 <code>defconst</code> 定义的变量的值. 这两个表
达式之间值得注意的一点是, <code>defconst</code> 会无条件地初始化变量,而 <code>defvar</code> 只会在变量
原本为空时初始化变量.
</p>

<p>
要定义一个自定义的变量,你应该使用 <code>defcustom</code> (该表达式会调用 <code>defvar</code> 作为子程
序). 参见 <a href="#orga9166ed">变量定义(Variabel Definitions)</a>.
</p>

<dl class="org-dl">
<dt><code>(defvar symbol [value [doc-string]])</code></dt><dd><p>
这个特殊表达式将 symbol 定义为一个变量. 请注意, symbol 不会被求值; 要定义的符
号应该显式地出现在 <code>defvar</code> 表达式中. 该变量会被标记为 "特殊的", 意味着它应该
一直都是动态绑定的(参见 <a href="#orgc0f0806">变量范围(Variable Scoping)</a>).
</p>

<p>
如果指定了 value, 而且 symbol 是空的(也就是没有动态绑定的值,参见
<a href="#org5fe7735">空变量(Void Variables)</a>), 那么 value 就会被求值而且 symbol 会被设置为求值结果.
如果 symbol 不是空的,那么 value 就不会被求值,并且 symbol 的值会保持不变. 如果
value 省略, symbol 的值在任何情况下都不会变化.
</p>

<p>
请注意,即使指定的值是 <code>nil</code> 也会将该变量永久标记为特殊的. 而如果 value 被省略,
那么变量只会被局部标记为特殊的(也就是在当前的词法作用域范围,或是整个文件,如果
该变量位于文件顶部). 这对于阻止字节码编译的警告信息可能会有用, 参见
<a href="#org218f0cd">编译器错误(Compiler Errors)</a>
</p>

<p>
如果 symbol 在当前缓冲区有缓冲区局部绑定, <code>defvar</code> 会作用在默认值上, 也就是独
立于缓冲区的值,而不是缓冲区局部绑定的.如果默认值是空的,那么它会设置默认值. 参
见 <a href="#org002980b">缓冲区局部变量(Buffer-Local Variables)</a>.
</p>

<p>
如果 symbol 已经在词法上绑定了(例如,如果 <code>defvar</code> 表达式出现在一个启用了词法绑
定的 <code>let</code> 表达式中), 那么 <code>defvar</code> 会设置动态值. 而词法绑定会保持生效,直到该
绑定构造退出. 参见 <a href="#orgc0f0806">变量范围(Variable Scoping)</a>.
</p>

<p>
当你在 Emacs Lisp 模式下使用 <code>C-M-x</code> (<code>eval-defun</code>) 或 <code>C-x C-e</code>
(<code>eval-last-sexp</code>)  对一个位于顶部的 <code>defvar</code> 求值时, 这两个命令的特殊特性会在
没有测试其值是否为空的情况下无条件地设置该变量.
</p>

<p>
如果提供了 doc-string 参数, 那么该参数会为该变量指定文档字符串(储存在符号的
<code>variable-documentation</code> 属性中). 参见 <a href="#orgb14dd88">文档(Documentation)</a>.
</p>

<p>
下面是一些示例.
</p>

<p>
这个表达式定义了 <code>foo</code> 但是没有初始化它:
</p>
<pre class="example" id="org7cdbf95">
  (defvar foo)
       ⇒ foo
</pre>
<p>
这个例子将 <code>bar</code> 的值初始化为 <code>23</code> ,并提供了文档字符串:
</p>
<pre class="example" id="org8f668c7">
  (defvar bar 23
    "The normal weight of a bar.")
       ⇒ bar
</pre>
<p>
<code>defvar</code> 表达式返回 symbol ,但通常用在文件的最顶部,因为这里它们的值不重要.
</p>

<p>
一个关于使用不带值的 <code>defvar</code> 的更复杂的例子,请参阅
<a href="#org3be07f1">使用词法绑定(Using Lexical Binding)</a>.
</p></dd>

<dt><code>(defconst symbol value [doc-string])</code></dt><dd><p>
这个特殊表达式将 symbol 定义为一个值 value 并初始化它. 它告知阅读代码的人
symbol 在这里建立了一个标准的全局值, 该值不应该被其他程序或用户修改. 请注意,
symbol 不会被求值; 要被定义的符号必需显式出现在 <code>defconst</code> 中.
</p>

<p>
<code>defconst</code> 表达式和 <code>defvar</code> 一样,会将变量标记为 "特殊", 意味着它应该一直都是
动态绑定(参见 <a href="#orgc0f0806">变量范围(Variable Scoping)</a>). 此外,它还将该变量标记为 "危险的"(参
见 <a href="#org6a93d16">文件局部变量(File Local Variables)</a>).
</p>

<p>
<code>defconst</code> 总是会对 value 求值,并将 symbol 的值设置为求值结果. 如果 symbol 在
当前缓冲区有了缓冲区局部绑定, <code>defconst</code> 会设置 symbol 的默认值而不是缓冲区局
部值. (但是你不应该为一个用 <code>defconst</code> 定义的符号生成缓冲区局部绑定.)
</p>

<p>
一个 <code>defconst</code> 的使用示例是 Emacs 的 <code>float-pi</code> (数学常量 pi)的定义, 它不应该
被任何人改变(尽管印第安纳州议会做出了尝试.).然而,正如下面第二个表达式所示,
<code>defconst</code> 只是建议性的:
</p>
<pre class="example" id="org9e91793">
  (defconst float-pi 3.141592653589793 "The value of Pi.")
       ⇒ float-pi
  (setq float-pi 3)
       ⇒ float-pi
  float-pi
       ⇒ 3
</pre></dd>
</dl>


<p>
<b>警告</b> : 如果你使用了 <code>defconst</code> 或 <code>defvar</code> 特殊表达式,而变量有局部绑定(由
<code>let</code> 或函数参数绑定的), 那么这个表达式会设置局部绑定而不是全局绑定. 这通常是你
不希望的. 要阻止这一行为, 请在文件的顶部使用这些特殊表达式,这里通常不会有局部绑
定正在生效,并确保在为变量生成局部绑定之前加载文件.
</p>
</div>

<ul class="org-ul">
<li><a id="org0b05b14"></a><span class="todo TODO">TODO</span> 疑问<br />
<div class="outline-text-5" id="text-org0b05b14">
<blockquote>
<p>
最后这个警告的意思,好像和前面 defconst 的说明里提到的 let 的地方矛盾, 但我推测是
因为我还没有看到词法绑定的内容,没有理解词法绑定和动态绑定, defconst 的文档说明里
提到的是在有词法绑定的前提下使用 defconst 会绑定动态值,而这个警告里提到的是局部
绑定,等我搞懂局部绑定,全局绑定,动态绑定和词法绑定的区别再来看看这个地方
</p>
</blockquote>
</div>
</li>
</ul>
</div>


<div id="outline-container-org9c62aa8" class="outline-4">
<h4 id="org9c62aa8"><span class="done DONE">DONE</span> 关于定义的提示(Tips for Defining)</h4>
<div class="outline-text-4" id="text-org9c62aa8">
<p>
当你定义一个变量时应该考虑的事情.
</p>

<p>
当你定义一个值是函数或函数列表的变量时,请分别使用以 <code>-function</code> 或 <code>-functions</code>
结尾的名字.
</p>

<p>
还有其他几种变量名称惯例; 下面是完整的列表:
</p>
<dl class="org-dl">
<dt><code>...-hook</code></dt><dd>变量是一个普通钩子(参见<a href="#org8f73bee">钩子(Hooks)</a>)</dd>
<dt><code>...-function</code></dt><dd>变量值是一个函数列表.</dd>
<dt><code>...-form</code></dt><dd>变量值是一个表达式.</dd>
<dt><code>...-forms</code></dt><dd>变量值是表达式列表.</dd>
<dt><code>...-predicate</code></dt><dd>变量值是一个断言(只有一个参数的函数,如果成功返回非 <code>nil</code> 失
败返回 <code>nil</code>).</dd>
<dt><code>...-flag</code></dt><dd>变量值的意义仅在与它是否为 <code>nil</code> . 因为这中变量通常随着时间推移
会获得更多的值,因此该惯例并不强烈推荐使用.</dd>
<dt><code>...-program</code></dt><dd>变量值是一个程序名.</dd>
<dt><code>...-command</code></dt><dd>变量值是一个完整的 shell 命令.</dd>
<dt><code>...-switches</code></dt><dd>变量值指定一个命令的选项.</dd>
<dt><code>...-internal</code></dt><dd>变量是用于内部使用并且是 C 代码定义的.(2018 年之前提交的
Emacs 代码可能遵循其他惯例,但都已经逐步停止使用了.)</dd>
<dt><code>PREFIX--...</code></dt><dd>变量用于内部使用且是在文件 <code>PREFIX.el</code> 中定义的.(2018 年之前
提交的 Emacs 代码可能遵循其他惯例,但都已经逐步停止使用了.)</dd>
</dl>


<p>
当你定义一个变量时,永远要考虑你是否应该将其标记为安全的或危险的; 参见
<a href="#org6a93d16">文件局部变量(File Local Variables)</a>.
</p>

<p>
当定义以及初始化一个储存复杂值(例如一个带有绑定的按键映射)的变量时,最好是将整个
值的计算放置到 <code>defvar</code> 中, 就像这样:
</p>
<pre class="example" id="org21bd739">
(defvar my-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map "\C-c\C-a" 'my-command)
    ...
    map)
  DOCSTRING)
</pre>
<p>
这种做法有几个好处. 首先,如果用户在加载文件时退出,这个变量要么仍然是未初始化的要
么是完全地初始化了,绝对不会介于两者之间. 如果变量仍然未初始化,重新加载文件会完全
地初始化它. 第二, 重新加载变量已经初始化了的文件一次不会改变变量; 如果用户已经运
行了钩子函数来修改部分内容(例如,重新绑定按键),那么这一点就非常重要. 第三, 使用
<code>C-M-x</code> 对 <code>defvar</code> 表达式求值会完全重新初始化映射.
</p>

<p>
将这么多代码放入 <code>defvar</code> 表达式中有一个缺点: 它会将文档字符串与命名变量的行隔得
很远. 下面是一个安全的方式来避免这一点:
</p>
<pre class="example" id="org9a40cac">
(defvar my-mode-map nil
  DOCSTRING)
(unless my-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map "\C-c\C-a" 'my-command)
    ...
    (setq my-mode-map map)))
</pre>
<p>
这个例子有着将初始化放入 <code>defvar</code> 的所有优点,除了如果你真的想要重新初始化变量,那
么你必需键入 <code>C-M-x</code> 两次(一个表达式一次).
</p>
</div>
</div>

<div id="outline-container-org936f45c" class="outline-4">
<h4 id="org936f45c"><span class="todo TODO">TODO</span> 访问变量(Accessing Variables)</h4>
<div class="outline-text-4" id="text-org936f45c">
<p>
检查在运行时已知名称的变量的值.
</p>

<p>
引用一个变量的常用方法是写入命名它的符号. 参见 <a href="#org59ab721">符号表达式(Symbol Forms)</a>.
</p>

<p>
有时你可能想要引用一个变量值只会在运行时决定的变量. 在这种情况下, 你不能在程序的
文本中指定变量名. 你可以使用 <code>symbol-value</code> 函数来提取变量值.
</p>

<dl class="org-dl">
<dt><code>(symbol-value symbol)</code></dt><dd><p>
这个函数返回储存在 symbol 的值单元中的值. 值单元是变量当前的(动态)值储存的地方.
如果变量没有局部绑定,那么就是变量的全局值.如果变量为空,就会发出一个
<code>void-variable</code> 的错误信号.
</p>

<p>
如果变量是词法绑定的,那么 <code>symbol-value</code> 返回的值不是必需与变量的词法值相等,变
量的词法值是由词法环境决定的,而不是符号的值单元.参见
<a href="#orgc0f0806">变量范围(Variable Scoping)</a>.
</p>
<pre class="example" id="orge6e62fe">
  (setq abracadabra 5)
       ⇒ 5
  (setq foo 9)
       ⇒ 9

  ;; Here the symbol ‘abracadabra’
  ;;   is the symbol whose value is examined.
  (let ((abracadabra 'foo))
    (symbol-value 'abracadabra))
       ⇒ foo

  ;; Here, the value of ‘abracadabra’,
  ;;   which is ‘foo’,
  ;;   is the symbol whose value is examined.
  (let ((abracadabra 'foo))
    (symbol-value abracadabra))
       ⇒ 9

  (symbol-value 'abracadabra)
       ⇒ 5

</pre></dd>
</dl>
</div>


<ul class="org-ul">
<li><a id="org7eb821c"></a><span class="todo TODO">TODO</span> 疑问<br />
<div class="outline-text-5" id="text-org7eb821c">
<blockquote>
<p>
这个例子我看得也是似懂非懂的,是因为 <code>'</code> 引用的作用让第一个 let 中的
abracadabra 只被求值一次,还是因为什么 let 导致的词法绑定之类的? 等看到词法绑定
那里再回头看吧
</p>
</blockquote>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgbd90c15" class="outline-4">
<h4 id="orgbd90c15"><span class="done DONE">DONE</span> 设置变量(Setting Variables)</h4>
<div class="outline-text-4" id="text-orgbd90c15">
<p>
在变量中储存新的值.
</p>

<p>
改变一个变量的值常用的方式是使用特殊表达式 <code>setq</code> . 当你需要在运行时计算变量的可
能值时,请使用函数 <code>set</code> .
</p>

<dl class="org-dl">
<dt><code>(setq [symbol form]...)</code></dt><dd><p>
这个特殊表达式是改变变量值最常用的方法. 每个 symbol 都会被定一个新的值,这个值
就是对相应 form 求值的结果枝. symbol 的当前绑定会被改变.
</p>

<p>
<code>setq</code> 不会对 symbol 求值; 它会设置你写入的 symbol. 我们称这个参数叫做 "自动引
用的". <code>setq</code> 中的 <code>q</code> 表示 <code>quoted</code>.
</p>

<p>
<code>setq</code> 表达式的值就是最后一个 form 的值.
</p>
<pre class="example" id="org8807398">
  (setq x (1+ 2))
       ⇒ 3
  x                   ; ‘x’ now has a global value.
       ⇒ 3
  (let ((x 5))
    (setq x 6)        ; The local binding of ‘x’ is set.
    x)
       ⇒ 6
  x                   ; The global value is unchanged.
       ⇒ 3
</pre>
<p>
请注意,第一个表达式 form 会被求值,然后第一个 symbol 会被设置,再然后第二个 form
会被求值,然后第二个 symbol 会被设置,依此类推:
</p>
<pre class="example" id="org1289dd9">
  (setq x 10          ; Notice that ‘x’ is set before
	y (1+ x))     ;   the value of ‘y’ is computed.
       ⇒ 11
</pre></dd>

<dt><code>(set symbol value)</code></dt><dd><p>
这个函数将 value 放置到 symbol 的值单元中. 因为这是一
个函数而不是特殊表达式, 为 symbol 编写的表达式会被求值从而获取要设置的符号. 返
回值就是 value.
</p>

<p>
当动态变量绑定生效时(默认情况), <code>set</code> 与 <code>setq</code> 有着相同的效果,不同之处在于
<code>set</code> 会对 symbol 参数求值,而 <code>setq</code> 不会. 但是,当一个变量是词法绑定的时候,
<code>set</code> 会影响变量的动态值,而 <code>setq</code> 影响的是变量的当前(词法)值. 参见
<a href="#orgc0f0806">变量范围(Variable Scoping)</a>.
</p>

<pre class="example" id="org51d21f5">
  (set one 1)
  error→ Symbol's value as variable is void: one
  (set 'one 1)
       ⇒ 1
  (set 'two 'one)
       ⇒ one
  (set two 2)         ; ‘two’ evaluates to symbol ‘one’.
       ⇒ 2
  one                 ; So it is ‘one’ that was set.
       ⇒ 2
  (let ((one 1))      ; This binding of ‘one’ is set,
    (set 'one 3)      ;   not the global value.
    one)
       ⇒ 3
  one
       ⇒ 2
</pre>

<p>
如果给定的 symbol 事实上不是一个符号,则会发出一个 <code>wrong-type-argument</code> 的错误
信号.
</p>
<pre class="example" id="org6e4c05d">
  (set '(x y) 'z)
  error→ Wrong type argument: symbolp, (x y)
</pre></dd>
</dl>
</div>
</div>

<div id="outline-container-org0d27d4f" class="outline-4">
<h4 id="org0d27d4f"><span class="done DONE">DONE</span> 监视变量(Watching Variables)</h4>
<div class="outline-text-4" id="text-org0d27d4f">
<p>
当变量改变时运行函数.
</p>

<p>
当一个变量的值改变时能执行某些操作有时是很有用的. "变量监视点" 功能提供了这样做
的方法. 这个特性可能的用法包括保持变量设置的同步显示;激活调试器来追踪预料之外的
变量改变(参见 <a href="#orgff63586">变量调试(Variable Debugging)</a>).
</p>

<p>
下面的函数可以被用来操作和请求变量的监视函数.
</p>

<dl class="org-dl">
<dt><code>(add-variable-watcher symbol watch-function)</code></dt><dd><p>
这个函数会将 watch-function 设置为当 symbol 被修改就会被调用.即使是通过别名(参
见 <a href="#org4257d69">变量别名(Variable Aliases)</a>) 的修改也是一样的.
</p>

<p>
watch-function 会在 symbol 的值被修改之前调用.且带有四个参数: symbol , newval
, operation , 和 where. symbol 是正在被改变的变量. newval 是它要变为的值.(对
watch-function 来说, symbol 的值是旧的值,因为它还没有被改成 newval.) operation
是一个符号代表了是哪种类型的改变,可以是下面的其中一种: <code>set</code> , <code>let</code> , <code>unlet</code>
, <code>makunbound</code> 或 <code>defvaralias</code> .如果变量的缓冲区局部值正在被修改,则 where 是
缓冲区,否则 where 是 <code>nil</code>.
</p></dd>
<dt><code>(remove-variable-watcher symbol watch-function)</code></dt><dd>这个函数会从 symbol 的监视器列表中移除 watch-function.</dd>
<dt><code>(get-variable-watcher symbol)</code></dt><dd>这个函数返回 symbol 的有效监视器函数的列表.</dd>
</dl>
</div>


<ul class="org-ul">
<li><a id="org4825bc9"></a><span class="done DONE">DONE</span> 限制(Limitations)<br />
<div class="outline-text-5" id="text-org4825bc9">
<p>
有几种可以不触发监视器但能修改变量(或至少看起来被修改了)的方法.
</p>

<p>
因为监视器是附加在符号上的, 所以对变量内部包含的对象的修改(例如, 通过一个列表修
改函数, 参见 <a href="#org65e7d81">修改列表(Modifying Lists)</a>) 就不会被这种机制捕捉到.
</p>

<p>
此外, C 代码可以绕过监视点机制直接修改变量的值.
</p>

<p>
这个功能的一个小的限制,同样是因为它针对的是符号,所以只有动态作用域的变量可以被监
视.这就造成了一点小麻烦, 因为对词法变量的修改可以很容易通过检查在变量作用域范围
内的代码发现(与动态变量不同,动态变量可以被任何代码修改, 参见
<a href="#orgc0f0806">变量范围(Variable Scoping)</a>).
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgc0f0806" class="outline-4">
<h4 id="orgc0f0806"><span class="todo NEXT">NEXT</span> 变量范围(Variable Scoping)</h4>
<div class="outline-text-4" id="text-orgc0f0806">
<p>
Lisp 如何选择局部和全局值的.
</p>

<p>
当你为变量创建一个局部绑定时,该绑定只会在程序的有限部分内有效(参见
<a href="#org6826578">局部变量(Local Variables)</a>) 这一部分会描述这个局部有效到底是什么意思.
</p>

<p>
每个局部绑定都有特定的 "scope" 和 "extent". "Scope" 指的是在文本源代码中绑定可以
被访问的位置. "Extent" 指的是在程序执行时绑定存在的时间.
</p>
<blockquote>
<p>
国内貌似都直接用一个 "作用域" 来代替这个可访问的源代码范围和运行时的存在范围这两
个概念.并且 Extent 很少见,一般都是 scope. 在词典中查到 extent 是某个事物占用的区
域(范围,程度,规模,大小), 而 scope 的解释直接引用了 extent 表示是某个区域或对象影
响的或相关的范围领域. 我也习惯了使用 scope 并且直接当作作用域来使用了.
</p>
</blockquote>

<p>
默认情况下, Emacs 创建的局部绑定是 "动态绑定" . 这种绑定有着 "动态作用域
(scope)", 意味着程序的任何部分都 <b>可能</b> 访问该变量绑定. 这种绑定也有着 "动态作用
域 (extent)" ,意味着该绑定仅仅在绑定构造(例如 <code>let</code> 表达式的主体)执行时持续.
</p>

<p>
Emacs 可以选择创造 "词法绑定". 词法绑定有着 "词法作用域", 意味着任意对该变量的引
用都必须在文本位置上位于绑定构造的内部<sup><a id="fnr.10" class="footref" href="#fn.10" role="doc-backlink">10</a></sup>. 这种绑定有着 "不确定范围" ,意味着在某些情况下,通过一种叫
做 "closures"(闭包?)的特殊对象, 即使在绑定构造结束执行之后,该绑定仍然可以存在.
</p>

<p>
下面的小节中会更详尽地描述动态绑定和词法绑定,以及如何在 Emacs Lisp 程序中启用词
法绑定.
</p>
</div>

<ul class="org-ul">
<li><a id="org5437ee7"></a><span class="done DONE">DONE</span> 动态绑定(Dynamic Binding)<br />
<div class="outline-text-5" id="text-org5437ee7">
<p>
Emacs 中绑定局部变量的默认行为.
</p>

<p>
默认情况下, 由 Emacs 生成的局部变量绑定是动态绑定. 当一个变量是动态绑定的时,在
Lisp 程序的执行过程中的任意位置,它当前的绑定就是最近为该符号创建的动态局部绑定,
或是全局绑定(如果没有最近创建的局部绑定.).
</p>

<p>
动态绑定有着下面例子所示的动态作用域:
</p>
<pre class="example" id="org39d1e15">
(defvar x -99)  ; ‘x’ receives an initial value of −99.

(defun getx ()
  x)            ; ‘x’ is used free in this function.

(let ((x 1))    ; ‘x’ is dynamically bound.
  (getx))
     ⇒ 1

;; After the ‘let’ form finishes, ‘x’ reverts to its
;; previous value, which is −99.

(getx)
     ⇒ -99
</pre>
<p>
函数 <code>getx</code> 引用了 <code>x</code>. 这是一个 "自由" 引用,因为在 <code>defun</code> 构造中没有对 <code>x</code> 的
绑定. 当我们在一个 <code>x</code> 是(动态)绑定的 <code>let</code> 表达式中调用 <code>getx</code> 表达式时, <code>getx</code>
接收到的是局部值(也就是 1). 但是当我们从 <code>let</code> 表达式之外调用 <code>getx</code> 时, 它收到
的是全局值(也就是 -99).
</p>

<p>
下面是另一个例子,该例展示了使用 <code>setq</code> 设置一个动态绑定变量:
</p>
<pre class="example" id="org99fc06d">
(defvar x -99)      ; ‘x’ receives an initial value of −99.

(defun addx ()
  (setq x (1+ x)))  ; Add 1 to ‘x’ and return its new value.

(let ((x 1))
  (addx)
  (addx))
     ⇒ 3           ; The two ‘addx’ calls add to ‘x’ twice.

;; After the ‘let’ form finishes, ‘x’ reverts to its
;; previous value, which is −99.

(addx)
     ⇒ -98
</pre>

<p>
在 Emacs Lisp 中动态绑定是以一种简单方式实现的. 每个符号都有一个值单元,该单元指
定了符号当前的动态值(或值的缺失). 参见 <a href="#org971770a">符号组成(Symbol Components)</a>. 当一个符号被
给定一个动态局部绑定时, Emacs 会在一个堆栈中记录值单元的内容(或它的缺失),并将新
的局部值储存在值单元中. 当绑定构造结束之后时, Emacs 会将旧的值弹出堆栈,然后将该
值放入到值单元中.
</p>

<p>
请注意,当使用动态绑定的代码是本机编译的时,本机的编译器不会执行任何 Lisp 特定的优
化.
</p>
</div>
</li>



<li><a id="orgbc541e3"></a><span class="done DONE">DONE</span> 动态绑定提示(Dynamic Bindings Tips)<br />
<div class="outline-text-5" id="text-orgbc541e3">
<p>
避免使用动态绑定的问题.
</p>

<p>
动态绑定是一个强大的特性,因为它允许程序引用那些并不是定义在他们的局部文本范围之
内的变量. 然而, 如果没有限制的使用,也会导致程序很难理解. 有两种 clean 的方法来使
用这种技术:
</p>
<ul class="org-ul">
<li>如果变量没有全局定义,则只在绑定构造中将它用作局部变量,例如在变量被绑定的 <code>let</code>
表达式的主体中. 如果在整个程序中始终遵循此惯例,则变量的值不会影响到程序中其他
位置相同变量符号的使用,也不会受到程序中其他地方的使用相同的变量符号的影响.</li>
<li><p>
另一种方式就是,使用 <code>defvar</code> , <code>defconst</code> (参见 <a href="#org01c338c">定义变量(Defining Variables)</a>)
或 <code>defcustom</code> (参见 <a href="#orga9166ed">变量定义(Variabel Definitions)</a>) 来定义变量. 通常来讲,这些
定义应该位于 Emacs Lisp 文件的最顶部. 而且它应该尽可能地包含一个解释变量用途和
意义的文档字符串. 你也应该选择合适的变量名来避免名称冲突(参见 <a href="#org5cfe896">编码惯例(Coding Conventions)</a>).
</p>

<p>
然后你可以在程序的任意位置绑定变量,并且很可靠地知道绑定的效果. 不管你在那里遇
到这些变量,都会很容易引用回到其定义位置, 例如, 通过 <code>C-h v</code> 命令(前提是变量定
义已经被加载到 Emacs 中了).参见 <a href="https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Name-Help">emacs#Name Help</a>.
</p>

<p>
例如,对像 <code>case-fold-search</code> 这样的可自定义变量使用局部绑定是很常见的:
</p>
<pre class="example" id="org2059356">
  (defun search-for-abc ()
    "Search for the string \"abc\", ignoring case differences."
    (let ((case-fold-search t))
      (re-search-forward "abc")))
</pre></li>
</ul>
</div>
</li>

<li><a id="orge2ebb68"></a><span class="done DONE">DONE</span> 词法绑定(Lexical Bindings)<br />
<div class="outline-text-5" id="text-orge2ebb68">
<p>
一种不同类型的局部变量绑定.
</p>

<p>
词法绑定是作为一个可选的特性在 24.1 版本引入到 Emacs 里的. 我们预测它的重要性会
随着时间推移而增加. 词法绑定为优化提供了更多的机会,因此使用词法绑定的程序在未来
的 Emacs 版本中可能会运行得更快. 词法绑定也与并发(在 26.1 版本添加到 Emacs 的)更
为兼容.
</p>

<p>
一个词法绑定的变量有着 "词法作用域", 意味着任意对该变量的引用都必须在文本位置上
位于绑定构造内部. 下面是一个示例(关于如何真正启用词法绑定,请参阅
<a href="#org3be07f1">使用词法绑定(Using Lexical Binding)</a> ):
</p>
<pre class="example" id="org54e866d">
(let ((x 1))    ; ‘x’ is lexically bound.
  (+ x 3))
     ⇒ 4

(defun getx ()
  x)            ; ‘x’ is used free in this function.

(let ((x 1))    ; ‘x’ is lexically bound.
  (getx))
error→ Symbol's value as variable is void: x
</pre>

<p>
这里,变量 <code>x</code> 没有全局值. 当它在 <code>let</code> 表达式里被词法绑定时, 它可以在该 <code>let</code> 表
达式的文本限制范围内使用. 但是它 <b>不能</b> 在在 <code>let</code> 表达式中调用的 <code>getx</code> 函数里
使用,因为 <code>getx</code> 的函数定义是出现在 <code>let</code> 表达式自身以外的地方的.
</p>

<p>
词法绑定是这样运作的. 每个绑定构造都会定义一个 "词法环境", 指定了要在绑定构造中
绑定的变量和他们的局部值. 当 Lisp 求值器想要变量的当前值时, 它会先在词法环境中查
找; 如果变量没有在词法环境中指定,求值器会在符号的值单元中查找,而值单元就是动态绑
定的值储存的地方.
</p>

<blockquote>
<p>
在内部实现中,词法环境就是一个 "符号-值" 对的关联列表, 该关联列表最后一个元素是
<code>t</code> 而不是一个构造单元(cons cell). 这样的关联列表可以作为传递给 <code>eval</code> 函数的第
二个参数. 参见 <a href="#org823d079">执行(Eval)</a>. 然而,大部分的 Emacs Lisp 程序,都不应该使用这种方式直
接与词法环境交互; 只有像调试器这种特殊程序才应该这样做.
</p>
</blockquote>

<p>
词法绑定有着不确定的作用域. 即使绑定构造已经结束执行了,其词法环境也可能保留在叫
做 "Closures" (闭包?) 的 Lisp 对象中. 当你在词法绑定启用时定义一个命名或匿名函数
时,就会创建一个 closure. 关于 closures 的细节,请参考 <a href="#orgfa246ab">闭包(Closures)</a>.
</p>

<p>
当闭包作为函数调用时,闭包定义中的任意词法变量的引用会使用其持有的词法环境. 下面
是一个示例:
</p>
<pre class="example" id="orgae229cc">
(defvar my-ticker nil)   ; We will use this dynamically bound
                         ; variable to store a closure.

(let ((x 0))             ; ‘x’ is lexically bound.
  (setq my-ticker (lambda ()
                    (setq x (1+ x)))))
    ⇒ (closure ((x . 0) t) ()
          (setq x (1+ x)))

(funcall my-ticker)
    ⇒ 1

(funcall my-ticker)
    ⇒ 2

(funcall my-ticker)
    ⇒ 3

x                        ; Note that ‘x’ has no global value.
error→ Symbol's value as variable is void: x
</pre>
<p>
例子中的 <code>let</code> 绑定定义了一个词法环境,在这个词法环境中, <code>x</code> 是被局部绑定到 0 的.
在这个绑定构造中,我们定义了一个 lambda 表达式,它会将 <code>x</code> 加一并返回增加后的值.
这个 lambda 表达式是自动成为一个闭包的, 在这个闭包中, 即使在绑定构造 <code>let</code> 已经
退出之后,词法环境依然会存在. 每当我们对闭包求值时, 它就会使用那个仍然存在的词法
环境中的 <code>x</code> 的绑定来增加 <code>x</code> 的值.
</p>

<p>
请注意,与动态变量不同的是,动态变量是与符号对象自身绑定的,词法变量和符号之间的关
系只存在与解释器(或编译器)中. 因此,接收符号参数的函数(例如 <code>symbol-value</code> ,
<code>boundp</code> 和 <code>set</code>) 只能获取或修改变量的动态绑定(也就是符号的值单元中的内容).
</p>
</div>
</li>

<li><a id="org3be07f1"></a><span class="done DONE">DONE</span> 使用词法绑定(Using Lexical Binding)<br />
<div class="outline-text-5" id="text-org3be07f1">
<p>
如何启用词法绑定.
</p>

<p>
如果缓冲区局部变量 <code>lexical-binding</code> 为非 <code>nil</code> 值,则当加载一个 Emacs Lisp 文件
或对一个 Lisp 缓冲区求值时, 词法绑定就会被启用:
</p>
<dl class="org-dl">
<dt><code>lexical-binding</code></dt><dd>如果这个缓冲区局部变量为非 <code>nil</code> 值,那么对 Emacs Lisp 文件和缓冲区求值就会使用
词法绑定而不是动态绑定.(然而,特殊变量仍然是动态绑定的;见下面描述.) 如果为
<code>nil</code> ,则动态绑定用于所有局部变量. 这个变量通常是作为一个文件局部变量(参见
<a href="#org6a93d16">文件局部变量(File Local Variables)</a>)为整个 Emacs Lisp 文件设置的. 请注意,与其他
这样的变量不同,这个变量必需设置在文件的第一行.</dd>
</dl>


<p>
当使用一个 <code>eval</code> 调用直接对 Emacs Lisp 代码求值时, 如果 <code>eval</code> 的 LEXICAL 参数
设置为非 <code>nil</code> 值,则词法绑定会被启用. 参见 <a href="#org823d079">执行(Eval)</a>.
</p>

<p>
词法绑定也会在 Lisp Interaction (用于 <code>*scratch*</code> 缓冲区)和 IELM (用于 <code>*ielm*</code>
缓冲区)模式下启用. 在通过 <code>M-:</code> <code>(eval-expression)</code> 对表达式求值以及在处理
Emacs( 参见 <a href="https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Action-Arguments">emacs#Action Arguments</a> ) 和 emacsclient (参见
<a href="https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#emacsclient-Options">emacs#emacsclient Options</a>)的 <code>--eval</code> 命令行选项时也会启用词法绑定.
</p>

<p>
即使启用了词法绑定,有些特定变量也仍然继续保持为动态绑定. 这些变量叫做 "特殊变量
". 每个由 <code>defvar</code> , <code>defcustom</code> 或 <code>defconst</code> 定义的变量都是特殊变量(参见
<a href="#org01c338c">定义变量(Defining Variables)</a>)
</p>

<p>
使用不带值的 <code>defvar</code> , 可以将一个变量在一个文件或只在文件的某个部分中动态绑定,
尽管该变量在其他地方是词法绑定的. 例如:
</p>
<pre class="example" id="org72862a1">
(let (_)
  (defvar x)      ; Let-bindings of ‘x’ will be dynamic within this let.
  (let ((x -99))  ; This is a dynamic binding of ‘x’.
    (defun get-dynamic-x ()
      x)))

(let ((x 'lexical)) ; This is a lexical binding of ‘x’.
  (defun get-lexical-x ()
    x))

(let (_)
  (defvar x)
  (let ((x 'dynamic))
    (list (get-lexical-x)
          (get-dynamic-x))))
    ⇒ (lexical dynamic)
</pre>

<blockquote>
<p>
第一个表达式中, get-dynamic-x 函数的定义是在 x 是动态绑定的情况下定义的; 第二个
表达式中, get-lexical-x 函数的定义是在词法绑定启用的情况下绑定的;因
此,get-dynamic-x 函数执行的结果返回的是 x 当前动态绑定的值, get-lexical-x 函数执
行的结果返回的是函数定义时转换成的闭包对象中保存的 x 的词法绑定; 第三个表达式中,
先将 x 设置为动态绑定, 然后将 x 动态绑定为 dynamic, 执行 get-lexical-x ,返回的是
get-lexical-x 生成的闭包结构中的词法环境里 x 的值,也就是第二个表达式中的
lexical, 而 get-dynamic-x 的执行是返回 x 当前动态绑定的值,也就是第三个表达式中动
态绑定的 dynamic.
</p>
</blockquote>

<dl class="org-dl">
<dt><code>(special-variable-p symbol)</code></dt><dd><p>
如果 symbol 是一个特殊变量(也就是使用了 <code>defvar</code> , <code>defcustom</code> 或 <code>defconst</code>
的变量定义), 则这个函数返回非 <code>nil</code> 值, 否则,返回 <code>nil</code>.
</p>

<p>
请注意,因为这是一个函数,所以它只能对于那些永远特殊的变量返回非 <code>nil</code> ,但那些只
在当前词法作用域下是特殊的变量则不会返回非 <code>nil</code>.
</p></dd>
</dl>


<p>
将特殊变量作为一个函数的形式参数是不支持的.
</p>
</div>
</li>

<li><a id="orgf474c99"></a><span class="todo NEXT">NEXT</span> 转换成词法绑定(Converting to Lexical Bindings)<br />
<div class="outline-text-5" id="text-orgf474c99">
<p>
将已有代码转换成词法绑定.
</p>

<p>
将一个 Emacs Lisp 程序转换成词法绑定很容易. 首先,在 Emacs Lisp 源文件的标题行(第
一行)添加一个 <code>lexical-binding</code> 设置为 <code>t</code> 的文件局部变量设置(参见
<a href="#org6a93d16">文件局部变量(File Local Variables)</a>). 然后,检查程序中的每个需要动态绑定的变量是否
都有变量定义,这样就不会无意中对其进行词法绑定.
</p>

<p>
一个可以找出哪个变量需要变量定义的简单方法是将源文件进行字节编译.参见
<a href="#org83b295a">字节编译(Byte Compilation)</a>. 如果一个非特殊字符是在 <code>let</code> 表达式之外使用的,那么字
节编译器会发出关于引用或赋值给自由变量的警告. 如果一个非特殊变量是绑定在 <code>let</code>
表达式中,但未使用,字节编译器会发出一个未使用的词法变量的警告. 如果你将特殊变量作
为函数参数,字节编译器也会发出警告.
</p>

<p>
关于对自由变量引用或赋值的警告通常是一个明确的标志,表明该变量标记为动态作用域,因
此你需要在首次使用该变量之前添加一个适当的 <code>defvar</code> .
</p>
</div>
</li>
</ul>
</div>


<div id="outline-container-org002980b" class="outline-4">
<h4 id="org002980b"><span class="todo NEXT">NEXT</span> 缓冲区局部变量(Buffer-Local Variables)</h4>
<div class="outline-text-4" id="text-org002980b">
<p>
只在一个缓冲区中有效的变量值.
</p>
</div>
<ul class="org-ul">
<li><a id="org936c969"></a>NEXT<br /></li>
<li><a id="org85bfae2"></a><span class="todo NEXT">NEXT</span> Creating Buffer-Local<br />
<div class="outline-text-5" id="text-org85bfae2">
<p>
创建和销毁缓冲区局部绑定.
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org6a93d16" class="outline-4">
<h4 id="org6a93d16"><span class="todo NEXT">NEXT</span> 文件局部变量(File Local Variables)</h4>
<div class="outline-text-4" id="text-org6a93d16">
<p>
处理文件中的局部变量列表.
</p>
</div>
</div>
<div id="outline-container-orgba5e1a5" class="outline-4">
<h4 id="orgba5e1a5"><span class="todo NEXT">NEXT</span> 目录局部变量(Directory Local Variables)</h4>
<div class="outline-text-4" id="text-orgba5e1a5">
<p>
目录中所有文件共用的局部变量.
</p>
</div>
</div>
<div id="outline-container-org0e2cd29" class="outline-4">
<h4 id="org0e2cd29"><span class="todo NEXT">NEXT</span> 连接局部变量(Connection Local Variables)</h4>
<div class="outline-text-4" id="text-org0e2cd29">
<p>
远程连接共用的局部变量.
</p>
</div>
</div>
<div id="outline-container-org4257d69" class="outline-4">
<h4 id="org4257d69"><span class="todo NEXT">NEXT</span> 变量别名(Variable Aliases)</h4>
<div class="outline-text-4" id="text-org4257d69">
<p>
作为其他变量别名的变量.
</p>
</div>
</div>
<div id="outline-container-org15b5af2" class="outline-4">
<h4 id="org15b5af2"><span class="todo NEXT">NEXT</span> 有限制值的变量(Variables with Restricted Values)</h4>
<div class="outline-text-4" id="text-org15b5af2">
<p>
变量值不能是任意 Lisp 对象的非常量变量.
</p>
</div>
</div>
<div id="outline-container-org728a322" class="outline-4">
<h4 id="org728a322"><span class="todo NEXT">NEXT</span> 广义变量(Generalized Variables)</h4>
<div class="outline-text-4" id="text-org728a322">
<p>
扩展变量的概念.
</p>
</div>
</div>
</div>

<div id="outline-container-org5921345" class="outline-3">
<h3 id="org5921345"><span class="todo TODO">TODO</span> 函数(Functions)</h3>
<div class="outline-text-3" id="text-org5921345">
<p>
函数是一个可以从其他函数调用的 Lisp 程序.
</p>
</div>

<div id="outline-container-orgb4e7d90" class="outline-4">
<h4 id="orgb4e7d90"><span class="todo TODO">TODO</span> 什么是函数(What Is a Function)</h4>
<div class="outline-text-4" id="text-orgb4e7d90">
<p>
Lisp 函数 vs. 原始函数; 术语.
</p>
</div>
</div>
<div id="outline-container-org8ae8a6d" class="outline-4">
<h4 id="org8ae8a6d"><span class="todo TODO">TODO</span> Lambda 表达式(Lambda Expressions)</h4>
<div class="outline-text-4" id="text-org8ae8a6d">
<p>
函数是如何表达为 Lisp 对象的.
</p>
</div>
</div>

<div id="outline-container-orga05ec51" class="outline-4">
<h4 id="orga05ec51"><span class="todo TODO">TODO</span> 定义函数(Defining Functions)</h4>
<div class="outline-text-4" id="text-orga05ec51">
<p>
用来定义函数的 Lisp 表达式.
</p>
</div>
</div>

<div id="outline-container-orgb7df300" class="outline-4">
<h4 id="orgb7df300"><span class="todo TODO">TODO</span> 函数名(Function Names)</h4>
<div class="outline-text-4" id="text-orgb7df300">
<p>
符号可以作为函数的名字.
</p>
</div>
</div>

<div id="outline-container-orgfb3c20f" class="outline-4">
<h4 id="orgfb3c20f"><span class="todo TODO">TODO</span> 调用函数(Calling Functions)</h4>
<div class="outline-text-4" id="text-orgfb3c20f">
<p>
如何使用已有的函数.
</p>
</div>
</div>
<div id="outline-container-orgbf27a2a" class="outline-4">
<h4 id="orgbf27a2a"><span class="todo TODO">TODO</span> 匿名函数(Anonymous Functions)</h4>
<div class="outline-text-4" id="text-orgbf27a2a">
<p>
Lambda 表达式是没有名字的函数.
</p>
</div>
</div>
<div id="outline-container-orgd2781b6" class="outline-4">
<h4 id="orgd2781b6"><span class="todo TODO">TODO</span> 映射函数(Mapping Functions)</h4>
<div class="outline-text-4" id="text-orgd2781b6">
<p>
将函数应用于列表(以及其他数据类型)的每个元素.
</p>
</div>
</div>

<div id="outline-container-org0e545a5" class="outline-4">
<h4 id="org0e545a5">TODO</h4>
</div>
<div id="outline-container-org991a09f" class="outline-4">
<h4 id="org991a09f">TODO</h4>
</div>
<div id="outline-container-org86bef4b" class="outline-4">
<h4 id="org86bef4b"><span class="todo TODO">TODO</span> 函数单元(Function Cells)</h4>
<div class="outline-text-4" id="text-org86bef4b">
<p>
访问或设置一个符号的函数定义.
</p>
</div>
</div>

<div id="outline-container-orgfa246ab" class="outline-4">
<h4 id="orgfa246ab"><span class="todo TODO">TODO</span> 闭包(Closures)</h4>
<div class="outline-text-4" id="text-orgfa246ab">
<p>
包含词法环境的函数.
</p>
</div>
</div>
<div id="outline-container-org2840aef" class="outline-4">
<h4 id="org2840aef">TODO</h4>
</div>
<div id="outline-container-orge7a93e3" class="outline-4">
<h4 id="orge7a93e3">TODO</h4>
</div>
<div id="outline-container-orge58db4b" class="outline-4">
<h4 id="orge58db4b">TODO</h4>
</div>
<div id="outline-container-org69ddd2a" class="outline-4">
<h4 id="org69ddd2a">TODO</h4>
</div>
<div id="outline-container-orge121275" class="outline-4">
<h4 id="orge121275">TODO</h4>
</div>
<div id="outline-container-org5af1f92" class="outline-4">
<h4 id="org5af1f92">TODO</h4>
</div>
</div>
<div id="outline-container-org15d607f" class="outline-3">
<h3 id="org15d607f"><span class="todo TODO">TODO</span> 宏(Macros)</h3>
<div class="outline-text-3" id="text-org15d607f">
<p>
宏是一种扩展 Lisp 语言的方式.
</p>
</div>
</div>
<div id="outline-container-orgc5a4660" class="outline-3">
<h3 id="orgc5a4660"><span class="todo TODO">TODO</span> 自定义(Customization)</h3>
<div class="outline-text-3" id="text-orgc5a4660">
<p>
让变量和面可自定义.
</p>
</div>
<div id="outline-container-org4c105ee" class="outline-4">
<h4 id="org4c105ee">TODO</h4>
</div>
<div id="outline-container-org878ff12" class="outline-4">
<h4 id="org878ff12">TODO</h4>
</div>
<div id="outline-container-orga9166ed" class="outline-4">
<h4 id="orga9166ed"><span class="todo TODO">TODO</span> 变量定义(Variabel Definitions)</h4>
<div class="outline-text-4" id="text-orga9166ed">
<p>
声明用户选项.
</p>
</div>
</div>
</div>

<div id="outline-container-orgfe470e1" class="outline-3">
<h3 id="orgfe470e1"><span class="todo TODO">TODO</span> 加载(Loading)</h3>
<div class="outline-text-3" id="text-orgfe470e1">
<p>
将 Lisp 代码文件读取到(为) Lisp.
</p>
</div>

<div id="outline-container-orgb7a9174" class="outline-4">
<h4 id="orgb7a9174"><span class="todo TODO">TODO</span> 程序如何执行加载(How Programs Do Loading)</h4>
<div class="outline-text-4" id="text-orgb7a9174">
<p>
<code>load</code> 函数和其他函数.
</p>
</div>
</div>

<div id="outline-container-org1926660" class="outline-4">
<h4 id="org1926660">TODO</h4>
</div>

<div id="outline-container-orgae87e98" class="outline-4">
<h4 id="orgae87e98">TODO</h4>
</div>

<div id="outline-container-org1682114" class="outline-4">
<h4 id="org1682114">TODO</h4>
</div>
<div id="outline-container-org910e488" class="outline-4">
<h4 id="org910e488"><span class="todo TODO">TODO</span> 自动加载(Autoload)</h4>
<div class="outline-text-4" id="text-org910e488">
<p>
将一个函数设置为自动加载.
</p>
</div>
</div>
<div id="outline-container-org54993f9" class="outline-4">
<h4 id="org54993f9">TODO</h4>
</div>
<div id="outline-container-org2430434" class="outline-4">
<h4 id="org2430434">TODO</h4>
</div>
<div id="outline-container-orge38a4a3" class="outline-4">
<h4 id="orge38a4a3">TODO</h4>
</div>
<div id="outline-container-org0148acb" class="outline-4">
<h4 id="org0148acb"><span class="todo TODO">TODO</span> 卸载(Unloading)</h4>
<div class="outline-text-4" id="text-org0148acb">
<p>
如何卸载已经加载的库.
</p>
</div>
</div>
<div id="outline-container-org1a742c1" class="outline-4">
<h4 id="org1a742c1">TODO</h4>
</div>
<div id="outline-container-orgea07986" class="outline-4">
<h4 id="orgea07986">TODO</h4>
</div>
</div>
<div id="outline-container-org83b295a" class="outline-3">
<h3 id="org83b295a"><span class="todo TODO">TODO</span> 字节编译(Byte Compilation)</h3>
<div class="outline-text-3" id="text-org83b295a">
<p>
(sound-wav-play org-pomodoro-short-break-sound)
</p>
</div>

<div id="outline-container-org3638602" class="outline-4">
<h4 id="org3638602"><span class="todo TODO">TODO</span> 文档和编译(Docs and Compilation)</h4>
<div class="outline-text-4" id="text-org3638602">
<p>
文档字符串的动态加载.
</p>
</div>
</div>

<div id="outline-container-org58e91b7" class="outline-4">
<h4 id="org58e91b7"><span class="todo TODO">TODO</span> 字节码对象(Byte-Code Objects)</h4>
<div class="outline-text-4" id="text-org58e91b7">
<p>
用于字节编译函数的数据类型
</p>
</div>
</div>

<div id="outline-container-orgf8d6226" class="outline-4">
<h4 id="orgf8d6226">TODO</h4>
</div>

<div id="outline-container-orgb4b6576" class="outline-4">
<h4 id="orgb4b6576">TODO</h4>
</div>

<div id="outline-container-org98ca786" class="outline-4">
<h4 id="org98ca786">TODO</h4>
</div>

<div id="outline-container-org218f0cd" class="outline-4">
<h4 id="org218f0cd"><span class="todo TODO">TODO</span> 编译器错误(Compiler Errors)</h4>
<div class="outline-text-4" id="text-org218f0cd">
<p>
处理编译器错误消息.
</p>
</div>
</div>
</div>

<div id="outline-container-orgff349d0" class="outline-3">
<h3 id="orgff349d0">TODO</h3>
</div>

<div id="outline-container-org964807e" class="outline-3">
<h3 id="org964807e">TODO</h3>
</div>

<div id="outline-container-org4b93f42" class="outline-3">
<h3 id="org4b93f42">TODO</h3>
</div>

<div id="outline-container-orgc25d34c" class="outline-3">
<h3 id="orgc25d34c">TODO</h3>
</div>

<div id="outline-container-org716d8f7" class="outline-3">
<h3 id="org716d8f7">TODO</h3>
</div>

<div id="outline-container-orgb639419" class="outline-3">
<h3 id="orgb639419">TODO</h3>
</div>

<div id="outline-container-orge99f6f6" class="outline-3">
<h3 id="orge99f6f6"><span class="todo TODO">TODO</span> 模式(Modes)</h3>
<div class="outline-text-3" id="text-orge99f6f6">
<p>
定义主模式和副模式.
</p>
</div>

<div id="outline-container-org8f73bee" class="outline-4">
<h4 id="org8f73bee"><span class="todo TODO">TODO</span> 钩子(Hooks)</h4>
<div class="outline-text-4" id="text-org8f73bee">
<p>
如何使用钩子,如何编写提供钩子的代码.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb14dd88" class="outline-3">
<h3 id="orgb14dd88"><span class="todo TODO">TODO</span> 文档(Documentation)</h3>
<div class="outline-text-3" id="text-orgb14dd88">
</div>
<div id="outline-container-org8a84f14" class="outline-4">
<h4 id="org8a84f14"><span class="todo TODO">TODO</span> 描述字符(Describing Characters)</h4>
<div class="outline-text-4" id="text-org8a84f14">
<p>
生成不可打印的字符和按键序列的可打印描述.
</p>
</div>
</div>

<div id="outline-container-org9c3df19" class="outline-4">
<h4 id="org9c3df19">TODO</h4>
</div>

<div id="outline-container-orgf5103df" class="outline-4">
<h4 id="orgf5103df">TODO</h4>
</div>

<div id="outline-container-orgb8798d2" class="outline-4">
<h4 id="orgb8798d2"><span class="todo TODO">TODO</span> 文本引用格式(Text Quoting Style)</h4>
<div class="outline-text-4" id="text-orgb8798d2">
<p>
文档字符串和消息中的引用符号.
</p>
</div>
</div>
</div>
<div id="outline-container-org0bf9401" class="outline-3">
<h3 id="org0bf9401"><span class="todo TODO">TODO</span> 调试(Debugging)</h3>
<div class="outline-text-3" id="text-org0bf9401">
<p>
调试 Lisp 程序的工具和提示.
</p>
</div>
<div id="outline-container-orge70b4e9" class="outline-4">
<h4 id="orge70b4e9"><span class="todo TODO">TODO</span> 调试器(Debugger)</h4>
<div class="outline-text-4" id="text-orge70b4e9">
<p>
Emacs Lisp 求值器的调试器.
</p>
</div>
<ul class="org-ul">
<li><a id="org931ad9f"></a><span class="todo TODO">TODO</span> 调试错误(Error Debugging)<br />
<div class="outline-text-5" id="text-org931ad9f">
<p>
当错误发生时进入调试器.
</p>
</div>
</li>
<li><a id="orgf64c221"></a>TODO<br /></li>
<li><a id="org1558ba1"></a>TODO<br /></li>
<li><a id="orgff63586"></a><span class="todo TODO">TODO</span> 变量调试(Variable Debugging)<br />
<div class="outline-text-5" id="text-orgff63586">
<p>
当变量被修改时进入调试器.
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgf48e6af" class="outline-3">
<h3 id="orgf48e6af">TODO</h3>
</div>
<div id="outline-container-org655c91e" class="outline-3">
<h3 id="org655c91e">TODO</h3>
</div>
<div id="outline-container-org6ebe914" class="outline-3">
<h3 id="org6ebe914"><span class="todo TODO">TODO</span> 命令循环(Command Loop)</h3>
<div class="outline-text-3" id="text-org6ebe914">
</div>
<div id="outline-container-org7aa3c11" class="outline-4">
<h4 id="org7aa3c11">TODO</h4>
</div>
<div id="outline-container-org4ba0631" class="outline-4">
<h4 id="org4ba0631">TODO</h4>
</div>
<div id="outline-container-org30f4580" class="outline-4">
<h4 id="org30f4580"><span class="todo TODO">TODO</span> 交互式调用(Interactive Call)</h4>
<div class="outline-text-4" id="text-org30f4580">
<p>
调用一个命令,以便它读取参数.
</p>
</div>
</div>

<div id="outline-container-orgb928846" class="outline-4">
<h4 id="orgb928846"><span class="todo TODO">TODO</span> 输入事件(Input Events)</h4>
<div class="outline-text-4" id="text-orgb928846">
<p>
输入的内容在读取时是什么样的.
</p>
</div>

<ul class="org-ul">
<li><a id="orgad73c35"></a><span class="todo TODO">TODO</span> 事件字符串(Strings of Events )<br />
<div class="outline-text-5" id="text-orgad73c35">
<p>
将键盘字符事件放到字符串时的特殊主义事项.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org9ae97a7" class="outline-4">
<h4 id="org9ae97a7"><span class="todo TODO">TODO</span> 键盘宏(Keyboard Macros)</h4>
<div class="outline-text-4" id="text-org9ae97a7">
<p>
键盘宏是如何实现的.
</p>
</div>
</div>

<div id="outline-container-org292391b" class="outline-4">
<h4 id="org292391b">TODO</h4>
</div>

<div id="outline-container-org527d6a0" class="outline-4">
<h4 id="org527d6a0">TODO</h4>
</div>

<div id="outline-container-orge4d50b7" class="outline-4">
<h4 id="orge4d50b7">TODO</h4>
</div>

<div id="outline-container-org137edca" class="outline-4">
<h4 id="org137edca">TODO</h4>
</div>

<div id="outline-container-org184c7fd" class="outline-4">
<h4 id="org184c7fd">TODO</h4>
</div>

<div id="outline-container-orge169eec" class="outline-4">
<h4 id="orge169eec"><span class="todo TODO">TODO</span> 退出(Quiting)</h4>
<div class="outline-text-4" id="text-orge169eec">
<p>
<code>C-g</code> 是如何工作的. 如何捕获或推迟退出操作.
</p>
</div>
</div>

<div id="outline-container-org663c402" class="outline-4">
<h4 id="org663c402">TODO</h4>
</div>

<div id="outline-container-orgeb295fc" class="outline-4">
<h4 id="orgeb295fc"><span class="todo TODO">TODO</span> 递归编辑((Recursive Editing)</h4>
<div class="outline-text-4" id="text-orgeb295fc">
<p>
进入递归编辑,以及为什么你通常不应该使用它.
</p>
</div>
</div>
</div>
<div id="outline-container-orgad5bc8b" class="outline-3">
<h3 id="orgad5bc8b"><span class="todo TODO">TODO</span> 按键映射(Keymaps)</h3>
<div class="outline-text-3" id="text-orgad5bc8b">
<p>
定义从按键到命令的绑定.
</p>
</div>

<div id="outline-container-orgf28896f" class="outline-4">
<h4 id="orgf28896f">TODO</h4>
</div>

<div id="outline-container-orge5b6789" class="outline-4">
<h4 id="orge5b6789">TODO</h4>
</div>

<div id="outline-container-orgc909ec2" class="outline-4">
<h4 id="orgc909ec2">TODO</h4>
</div>

<div id="outline-container-org799bd20" class="outline-4">
<h4 id="org799bd20"><span class="todo TODO">TODO</span> 创建按键映射(Creating Keymaps)</h4>
<div class="outline-text-4" id="text-org799bd20">
<p>
用来创建和复制按键映射的函数.
</p>
</div>
</div>
</div>


<div id="outline-container-orge187988" class="outline-3">
<h3 id="orge187988">TODO</h3>
</div>
<div id="outline-container-orgf8513c7" class="outline-3">
<h3 id="orgf8513c7"><span class="todo TODO">TODO</span> 读取和打印(Read and Print)</h3>
<div class="outline-text-3" id="text-orgf8513c7">
<p>
将 Lisp 对象转换成文本,以及将文本转换成 Lisp 对象.
</p>
</div>
<div id="outline-container-orge639fe7" class="outline-4">
<h4 id="orge639fe7">TODO</h4>
</div>
<div id="outline-container-org57020dc" class="outline-4">
<h4 id="org57020dc">TODO</h4>
</div>
<div id="outline-container-orgdd8af85" class="outline-4">
<h4 id="orgdd8af85"><span class="todo TODO">TODO</span> 输入函数(Input Functions)</h4>
<div class="outline-text-4" id="text-orgdd8af85">
<p>
从文本中读取 Lisp 对象的函数.
</p>
</div>
</div>
<div id="outline-container-org8c6411d" class="outline-4">
<h4 id="org8c6411d"><span class="todo TODO">TODO</span> 输出流(Output Streams)</h4>
<div class="outline-text-4" id="text-org8c6411d">
<p>
可以用作输出流的各种数据类型.
</p>
</div>
</div>
<div id="outline-container-orge0896d7" class="outline-4">
<h4 id="orge0896d7"><span class="todo TODO">TODO</span> 输出函数(Output Functions)</h4>
<div class="outline-text-4" id="text-orge0896d7">
<p>
将 Lisp 对象打印为文本的函数.
</p>
</div>
</div>
<div id="outline-container-orgb1bf5b1" class="outline-4">
<h4 id="orgb1bf5b1"><span class="todo TODO">TODO</span> 输出变量(Output Variables)</h4>
<div class="outline-text-4" id="text-orgb1bf5b1">
<p>
控制打印函数行为的变量.
</p>
</div>
</div>
</div>


<div id="outline-container-orga1c7a88" class="outline-3">
<h3 id="orga1c7a88"><span class="todo TODO">TODO</span> 迷你缓冲区(Minibuffers)</h3>
<div class="outline-text-3" id="text-orga1c7a88">
<p>
使用迷你缓冲区来读取输入.
</p>
</div>
</div>

<div id="outline-container-org605fe44" class="outline-3">
<h3 id="org605fe44">TODO</h3>
</div>
<div id="outline-container-orgcab4107" class="outline-3">
<h3 id="orgcab4107">TODO</h3>
</div>
<div id="outline-container-org718863b" class="outline-3">
<h3 id="org718863b"><span class="todo TODO">TODO</span> 框架(Frames)</h3>
<div class="outline-text-3" id="text-org718863b">
<p>
生成多个系统级窗口.
</p>
</div>

<div id="outline-container-org340d88f" class="outline-4">
<h4 id="org340d88f">TODO</h4>
</div>

<div id="outline-container-org70d6964" class="outline-4">
<h4 id="org70d6964"><span class="todo TODO">TODO</span> 多终端(Multiple Terminals)</h4>
</div>
<div id="outline-container-org3a989e4" class="outline-4">
<h4 id="org3a989e4">TODO</h4>
</div>

<div id="outline-container-orgbad06fb" class="outline-4">
<h4 id="orgbad06fb">TODO</h4>
</div>

<div id="outline-container-org168a3cc" class="outline-4">
<h4 id="org168a3cc">TODO</h4>
</div>

<div id="outline-container-org34e6f5c" class="outline-4">
<h4 id="org34e6f5c">TODO</h4>
</div>

<div id="outline-container-org6c473c3" class="outline-4">
<h4 id="org6c473c3"><span class="todo TODO">TODO</span> 删除框架(Deleting Frames)</h4>
<div class="outline-text-4" id="text-org6c473c3">
<p>
框架持续到显式删除为止.
</p>
</div>
</div>

<div id="outline-container-orgdee515b" class="outline-4">
<h4 id="orgdee515b">TODO</h4>
</div>

<div id="outline-container-orgac4a650" class="outline-4">
<h4 id="orgac4a650">TODO</h4>
</div>

<div id="outline-container-orgfadec79" class="outline-4">
<h4 id="orgfadec79">TODO</h4>
</div>

<div id="outline-container-org995f568" class="outline-4">
<h4 id="org995f568">TODO</h4>
</div>

<div id="outline-container-org2cd0bd6" class="outline-4">
<h4 id="org2cd0bd6">TODO</h4>
</div>

<div id="outline-container-org784167d" class="outline-4">
<h4 id="org784167d"><span class="todo TODO">TODO</span> 框架配置(Frame Configurations)</h4>
<div class="outline-text-4" id="text-org784167d">
<p>
保存所有框架的状态.
</p>
</div>
</div>
</div>

<div id="outline-container-orgcde4f6b" class="outline-3">
<h3 id="orgcde4f6b">TODO</h3>
</div>

<div id="outline-container-org561b2c5" class="outline-3">
<h3 id="org561b2c5">TODO</h3>
</div>

<div id="outline-container-orga7bfbe8" class="outline-3">
<h3 id="orga7bfbe8"><span class="todo TODO">TODO</span> 标记(Markers)</h3>
<div class="outline-text-3" id="text-orga7bfbe8">
<p>
标记表示位置,并且在文本更改时自动更新.
</p>
</div>

<div id="outline-container-orgff497a5" class="outline-4">
<h4 id="orgff497a5">TODO</h4>
</div>

<div id="outline-container-org8194aed" class="outline-4">
<h4 id="org8194aed"><span class="todo TODO">TODO</span> 标记的断言(Predicates on Markers)</h4>
<div class="outline-text-4" id="text-org8194aed">
<p>
测试一个对象是否为一个标记.
</p>
</div>
</div>
</div>

<div id="outline-container-org35285e5" class="outline-3">
<h3 id="org35285e5">TODO</h3>
</div>

<div id="outline-container-orgd3dbadb" class="outline-3">
<h3 id="orgd3dbadb">TODO</h3>
</div>

<div id="outline-container-org21204c1" class="outline-3">
<h3 id="org21204c1"><span class="todo TODO">TODO</span> 搜索和匹配(Searching and Matching)</h3>
<div class="outline-text-3" id="text-org21204c1">
</div>
<div id="outline-container-orged3be7e" class="outline-4">
<h4 id="orged3be7e">TODO</h4>
</div>

<div id="outline-container-orge1685b9" class="outline-4">
<h4 id="orge1685b9">TODO</h4>
</div>

<div id="outline-container-org3c6463d" class="outline-4">
<h4 id="org3c6463d"><span class="todo TODO">TODO</span> 正则表达式(Regular Expressions)</h4>
<div class="outline-text-4" id="text-org3c6463d">
<p>
描述字符串的种类?
</p>
</div>

<ul class="org-ul">
<li><a id="org91d51de"></a>TODO<br /></li>

<li><a id="orgf5f01c6"></a>TODO<br /></li>

<li><a id="org889d705"></a><span class="todo TODO">TODO</span> Rx 表示法(Rx Notation)<br />
<div class="outline-text-5" id="text-org889d705">
<p>
一个可供选择的结构化的正则表达式表示法.
</p>
</div>
</li>

<li><a id="org53dbaef"></a>TODO<br /></li>

<li><a id="org8b3f808"></a>TODO<br /></li>
</ul>
</div>

<div id="outline-container-org8dfde4e" class="outline-4">
<h4 id="org8dfde4e"><span class="todo TODO">TODO</span> 正则搜索(Regexp Search)</h4>
<div class="outline-text-4" id="text-org8dfde4e">
<p>
搜索正则表达式的匹配项.
</p>
</div>
</div>

<div id="outline-container-org5c8f6df" class="outline-4">
<h4 id="org5c8f6df">TODO</h4>
</div>

<div id="outline-container-orge41d11a" class="outline-4">
<h4 id="orge41d11a"><span class="todo TODO">TODO</span> 匹配数据(Match Data)</h4>
<div class="outline-text-4" id="text-orge41d11a">
<p>
在一个字符串或正则搜索后找到文本匹配的部分.
</p>
</div>

<ul class="org-ul">
<li><a id="orga390081"></a><span class="todo TODO">TODO</span> 替换匹配(Replacing Match)<br />
<div class="outline-text-5" id="text-orga390081">
<p>
替换匹配的子字符串.
</p>
</div>
</li>

<li><a id="org52dda59"></a><span class="todo TODO">TODO</span> 简单匹配数据(Simple Match Data)<br />
<div class="outline-text-5" id="text-org52dda59">
<p>
访问匹配数据的单个条目,例如一个特定子表达式从哪里开始的.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org42e5cd6" class="outline-4">
<h4 id="org42e5cd6"><span class="todo TODO">TODO</span> 搜索和替换(Search and Replace)</h4>
<div class="outline-text-4" id="text-org42e5cd6">
<p>
循环搜索和替换的命令.
</p>
</div>
</div>
</div>

<div id="outline-container-org1beb779" class="outline-3">
<h3 id="org1beb779">TODO</h3>
</div>

<div id="outline-container-orgbf47603" class="outline-3">
<h3 id="orgbf47603">TODO</h3>
</div>

<div id="outline-container-org5d465d5" class="outline-3">
<h3 id="org5d465d5">TODO</h3>
</div>

<div id="outline-container-orgc988708" class="outline-3">
<h3 id="orgc988708">TODO</h3>
</div>

<div id="outline-container-orgb624181" class="outline-3">
<h3 id="orgb624181"><span class="todo TODO">TODO</span> 线程(Threads)</h3>
<div class="outline-text-3" id="text-orgb624181">
<p>
Emacs Lisp 中的并发.
</p>
</div>

<div id="outline-container-org3a73c7a" class="outline-4">
<h4 id="org3a73c7a"><span class="todo TODO">TODO</span> 基本线程函数(Basic Thread Functions)</h4>
<div class="outline-text-4" id="text-org3a73c7a">
<p>
基本的线程函数.
</p>
</div>
</div>

<div id="outline-container-org899103b" class="outline-4">
<h4 id="org899103b"><span class="todo TODO">TODO</span> 互斥锁(Mutexes)</h4>
<div class="outline-text-4" id="text-org899103b">
<p>
互斥锁允许数据进行独占访问.
</p>
</div>
</div>

<div id="outline-container-orgb3c45a9" class="outline-4">
<h4 id="orgb3c45a9"><span class="todo TODO">TODO</span> 条件变量(Condition Variables)</h4>
<div class="outline-text-4" id="text-orgb3c45a9">
<p>
线程间的事件.
</p>
</div>
</div>
</div>
<div id="outline-container-orgacdc11c" class="outline-3">
<h3 id="orgacdc11c"><span class="todo TODO">TODO</span> 显示(Display)</h3>
<div class="outline-text-3" id="text-orgacdc11c">
</div>
<div id="outline-container-org16edf4c" class="outline-4">
<h4 id="org16edf4c"><span class="todo TODO">TODO</span> 字符显示(Character Display)</h4>
<div class="outline-text-4" id="text-org16edf4c">
</div>
<ul class="org-ul">
<li><a id="orgaf27afa"></a><span class="todo TODO">TODO</span> 显示表(Display Tables)<br /></li>
</ul>
</div>

<div id="outline-container-org00f2169" class="outline-4">
<h4 id="org00f2169">TODO</h4>
</div>

<div id="outline-container-org38ac545" class="outline-4">
<h4 id="org38ac545">TODO</h4>
</div>

<div id="outline-container-orgc320f09" class="outline-4">
<h4 id="orgc320f09">TODO</h4>
</div>

<div id="outline-container-orga01d471" class="outline-4">
<h4 id="orga01d471">TODO</h4>
</div>

<div id="outline-container-org10acdca" class="outline-4">
<h4 id="org10acdca">TODO</h4>
</div>

<div id="outline-container-org301407a" class="outline-4">
<h4 id="org301407a">TODO</h4>
</div>

<div id="outline-container-org132a1de" class="outline-4">
<h4 id="org132a1de">TODO</h4>
</div>
<div id="outline-container-org562b087" class="outline-4">
<h4 id="org562b087"><span class="todo TODO">TODO</span> 覆盖层(Overlays)</h4>
<div class="outline-text-4" id="text-org562b087">
<p>
使用 overlays 来高亮显示缓冲区中的部分.
</p>
</div>
</div>

<div id="outline-container-org09acbcb" class="outline-4">
<h4 id="org09acbcb"><span class="todo TODO">TODO</span> 显示的文本的大小(Size of Displayed Text)</h4>
<div class="outline-text-4" id="text-org09acbcb">
<p>
用于显示的文本有多大.
</p>
</div>
</div>

<div id="outline-container-org90be08c" class="outline-4">
<h4 id="org90be08c"><span class="todo TODO">TODO</span> 回显区(The Echo Area)</h4>
<div class="outline-text-4" id="text-org90be08c">
<p>
在屏幕下方显示消息.
</p>
</div>
</div>

<div id="outline-container-orgaa6c179" class="outline-4">
<h4 id="orgaa6c179"><span class="todo TODO">TODO</span> 面(Faces)</h4>
<div class="outline-text-4" id="text-orgaa6c179">
<p>
面定义文本字符的图形样式: 字体,颜色等.
</p>
</div>

<ul class="org-ul">
<li><a id="org93f77ba"></a>TODO<br /></li>

<li><a id="org04cce16"></a>TODO<br /></li>

<li><a id="org09eba4e"></a>TODO<br /></li>

<li><a id="org710a1c6"></a>TODO<br /></li>

<li><a id="orgeae10c5"></a>TODO<br /></li>

<li><a id="org6ea4d12"></a>TODO<br /></li>

<li><a id="org0a49281"></a>TODO<br /></li>

<li><a id="orgbb5f6a9"></a>TODO<br /></li>

<li><a id="org94df46b"></a>TODO<br /></li>

<li><a id="org3fd3fd9"></a>TODO<br /></li>

<li><a id="org8b2925c"></a>TODO<br /></li>

<li><a id="orge1aca0a"></a><span class="todo TODO">TODO</span> 低层字体(Low-Level Font)<br />
<div class="outline-text-5" id="text-orge1aca0a">
<p>
显示字符的字体的 Lisp 表示.
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org752eca9" class="outline-3">
<h3 id="org752eca9">TODO</h3>
</div>

<div id="outline-container-orgaf6b33c" class="outline-3">
<h3 id="orgaf6b33c">TODO</h3>
</div>

<div id="outline-container-orgc4f19d0" class="outline-3">
<h3 id="orgc4f19d0">TODO</h3>
</div>

<div id="outline-container-orgfff7377" class="outline-3">
<h3 id="orgfff7377">TODO</h3>
</div>

<div id="outline-container-org536a4d8" class="outline-3">
<h3 id="org536a4d8">TODO</h3>
</div>

<div id="outline-container-org301788e" class="outline-3">
<h3 id="org301788e"><span class="todo TODO">TODO</span> 进程(Processes)</h3>
<div class="outline-text-3" id="text-org301788e">
<p>
运行子进程并与之通信.
</p>
</div>

<div id="outline-container-org82ca383" class="outline-4">
<h4 id="org82ca383">TODO</h4>
</div>

<div id="outline-container-orga93600a" class="outline-4">
<h4 id="orga93600a"><span class="todo TODO">TODO</span> Shell 参数(Shell Arguments)</h4>
<div class="outline-text-4" id="text-orga93600a">
<p>
引用一个参数,将其传递给shell.
</p>
</div>
</div>
</div>

<div id="outline-container-org75e49d9" class="outline-3">
<h3 id="org75e49d9"><span class="todo TODO">TODO</span> 文件(Files)</h3>
<div class="outline-text-3" id="text-org75e49d9">
<p>
访问文件.
</p>
</div>
</div>

<div id="outline-container-org12fbc0b" class="outline-3">
<h3 id="org12fbc0b"><span class="todo TODO">TODO</span> 缓冲区(Buffers)</h3>
<div class="outline-text-3" id="text-org12fbc0b">
<p>
创建和使用缓冲区对象.
</p>
</div>

<div id="outline-container-orgfac7b85" class="outline-4">
<h4 id="orgfac7b85"><span class="todo TODO">TODO</span> 缓冲区基础(Buffer Basics)</h4>
<div class="outline-text-4" id="text-orgfac7b85">
<p>
什么是缓冲区?
</p>
</div>
</div>
<div id="outline-container-org75e596b" class="outline-4">
<h4 id="org75e596b"><span class="todo TODO">TODO</span> 当前缓冲区(Current Buffer)</h4>
<div class="outline-text-4" id="text-org75e596b">
<p>
指定一个缓冲区作为当前缓冲区,以便原始函数访问其内容.
</p>
</div>
</div>

<div id="outline-container-org6bf99ea" class="outline-4">
<h4 id="org6bf99ea"><span class="todo TODO">TODO</span> 间接缓冲区(Indirect Buffers)</h4>
<div class="outline-text-4" id="text-org6bf99ea">
<p>
间接缓冲区与其他缓冲区共享文本.
</p>
</div>
</div>

<div id="outline-container-org235c270" class="outline-4">
<h4 id="org235c270"><span class="todo TODO">TODO</span> 缓冲区文件名(Buffer File Name)</h4>
<div class="outline-text-4" id="text-org235c270">
<p>
缓冲区文件名表示访问的是哪个文件.
</p>
</div>
</div>
</div>
<div id="outline-container-org24b263f" class="outline-3">
<h3 id="org24b263f"><span class="todo TODO">TODO</span> 窗口(Windows)</h3>
<div class="outline-text-3" id="text-org24b263f">
<p>
操作窗口和显示缓冲区.
</p>
</div>

<div id="outline-container-org3ece239" class="outline-4">
<h4 id="org3ece239"><span class="todo TODO">TODO</span> 基本窗口(Basic Windows)</h4>
<div class="outline-text-4" id="text-org3ece239">
<p>
关于使用窗口的基本信息.
</p>
</div>
</div>

<div id="outline-container-org963d2b2" class="outline-4">
<h4 id="org963d2b2">TODO</h4>
</div>

<div id="outline-container-orgbcab970" class="outline-4">
<h4 id="orgbcab970"><span class="todo TODO">TODO</span> 选择窗口(Selecting Windows)</h4>
</div>

<div id="outline-container-org86a8972" class="outline-4">
<h4 id="org86a8972">TODO</h4>
</div>

<div id="outline-container-orge31427e" class="outline-4">
<h4 id="orge31427e">TODO</h4>
</div>

<div id="outline-container-org6077611" class="outline-4">
<h4 id="org6077611">TODO</h4>
</div>

<div id="outline-container-org384e44a" class="outline-4">
<h4 id="org384e44a">TODO</h4>
</div>

<div id="outline-container-orgb0b9038" class="outline-4">
<h4 id="orgb0b9038"><span class="todo TODO">TODO</span> 删除窗口(Deleting Windows)</h4>
<div class="outline-text-4" id="text-orgb0b9038">
<p>
从框架中移除窗口.
</p>
</div>
</div>

<div id="outline-container-org740c6ee" class="outline-4">
<h4 id="org740c6ee">TODO</h4>
</div>

<div id="outline-container-orga6e5e66" class="outline-4">
<h4 id="orga6e5e66">TODO</h4>
</div>

<div id="outline-container-orgb55b8af" class="outline-4">
<h4 id="orgb55b8af">TODO</h4>
</div>

<div id="outline-container-org03b6d20" class="outline-4">
<h4 id="org03b6d20">TODO</h4>
</div>

<div id="outline-container-orgfc16270" class="outline-4">
<h4 id="orgfc16270">TODO</h4>
</div>

<div id="outline-container-orgeaf4b6c" class="outline-4">
<h4 id="orgeaf4b6c">TODO</h4>
</div>

<div id="outline-container-orgd4ab6aa" class="outline-4">
<h4 id="orgd4ab6aa">TODO</h4>
</div>

<div id="outline-container-orgafadc73" class="outline-4">
<h4 id="orgafadc73">TODO</h4>
</div>

<div id="outline-container-org90c87cb" class="outline-4">
<h4 id="org90c87cb">TODO</h4>
</div>

<div id="outline-container-org2f89eff" class="outline-4">
<h4 id="org2f89eff">TODO</h4>
</div>

<div id="outline-container-orgdec0158" class="outline-4">
<h4 id="orgdec0158">TODO</h4>
</div>

<div id="outline-container-org27c7c9a" class="outline-4">
<h4 id="org27c7c9a">TODO</h4>
</div>

<div id="outline-container-org67e123c" class="outline-4">
<h4 id="org67e123c">TODO</h4>
</div>

<div id="outline-container-orgbfb76da" class="outline-4">
<h4 id="orgbfb76da">TODO</h4>
</div>

<div id="outline-container-orga526990" class="outline-4">
<h4 id="orga526990">TODO</h4>
</div>

<div id="outline-container-org1905db4" class="outline-4">
<h4 id="org1905db4">TODO</h4>
</div>

<div id="outline-container-orgd3876a9" class="outline-4">
<h4 id="orgd3876a9">TODO</h4>
</div>

<div id="outline-container-org8509ca3" class="outline-4">
<h4 id="org8509ca3"><span class="todo TODO">TODO</span> 窗口配置(Window Configurations)</h4>
<div class="outline-text-4" id="text-org8509ca3">
<p>
保存和恢复屏幕的状态.
</p>
</div>
</div>

<div id="outline-container-orgad7b324" class="outline-4">
<h4 id="orgad7b324">TODO</h4>
</div>

<div id="outline-container-org20af33c" class="outline-4">
<h4 id="org20af33c">TODO</h4>
<div class="outline-text-4" id="text-org20af33c">
<p>
选定的窗口就是你正在编辑的窗口.
</p>
</div>
</div>
</div>

<div id="outline-container-orgbef9fd7" class="outline-3">
<h3 id="orgbef9fd7"><span class="todo TODO">TODO</span> 位置(Positions)</h3>
<div class="outline-text-3" id="text-orgbef9fd7">
<p>
缓冲区位置/光标和移动函数.
</p>
</div>

<div id="outline-container-orge6d8e83" class="outline-4">
<h4 id="orge6d8e83">TODO</h4>
</div>

<div id="outline-container-org43baec3" class="outline-4">
<h4 id="org43baec3">TODO</h4>
</div>

<div id="outline-container-orgb7f4793" class="outline-4">
<h4 id="orgb7f4793"><span class="todo TODO">TODO</span> Excursions</h4>
</div>

<div id="outline-container-org3ea3146" class="outline-4">
<h4 id="org3ea3146"><span class="todo TODO">TODO</span> Narrowing</h4>
</div>
</div>
<div id="outline-container-org3ec44e9" class="outline-3">
<h3 id="org3ec44e9"><span class="todo TODO">TODO</span> 文本(Text)</h3>
<div class="outline-text-3" id="text-org3ec44e9">
<p>
检查和更改缓冲区中的文本.
</p>
</div>
<div id="outline-container-orgd372b48" class="outline-4">
<h4 id="orgd372b48">TODO</h4>
</div>
<div id="outline-container-org72b73c0" class="outline-4">
<h4 id="org72b73c0"><span class="todo TODO">TODO</span> 缓冲区内容(Buffer Contents)</h4>
<div class="outline-text-4" id="text-org72b73c0">
<p>
以一般的方式检查文本.
</p>
</div>
</div>
<div id="outline-container-org1889664" class="outline-4">
<h4 id="org1889664"><span class="todo TODO">TODO</span> 比较文本(Comparing Text)</h4>
<div class="outline-text-4" id="text-org1889664">
<p>
比较缓冲区中的子字符串.
</p>
</div>
</div>

<div id="outline-container-org662352f" class="outline-4">
<h4 id="org662352f">TODO</h4>
</div>
<div id="outline-container-orgc022639" class="outline-4">
<h4 id="orgc022639">TODO</h4>
</div>
<div id="outline-container-org6793745" class="outline-4">
<h4 id="org6793745">TODO</h4>
</div>
<div id="outline-container-orgd828518" class="outline-4">
<h4 id="orgd828518">TODO</h4>
</div>
<div id="outline-container-org71fe477" class="outline-4">
<h4 id="org71fe477">TODO</h4>
</div>
<div id="outline-container-org9f8bdc7" class="outline-4">
<h4 id="org9f8bdc7">TODO</h4>
</div>
<div id="outline-container-org91b88c6" class="outline-4">
<h4 id="org91b88c6">TODO</h4>
</div>
<div id="outline-container-orgf263675" class="outline-4">
<h4 id="orgf263675">TODO</h4>
</div>
<div id="outline-container-org5da8f9f" class="outline-4">
<h4 id="org5da8f9f">TODO</h4>
</div>
<div id="outline-container-org064801c" class="outline-4">
<h4 id="org064801c">TODO</h4>
</div>
<div id="outline-container-orge6d636a" class="outline-4">
<h4 id="orge6d636a">TODO</h4>
</div>
<div id="outline-container-org493e050" class="outline-4">
<h4 id="org493e050">TODO</h4>
</div>
<div id="outline-container-org37714ed" class="outline-4">
<h4 id="org37714ed">TODO</h4>
</div>
<div id="outline-container-org430ea45" class="outline-4">
<h4 id="org430ea45">TODO</h4>
</div>
<div id="outline-container-orgc009e1c" class="outline-4">
<h4 id="orgc009e1c"><span class="todo TODO">TODO</span> 大小写转换(Case Changes)</h4>
<div class="outline-text-4" id="text-orgc009e1c">
<p>
缓冲区中某部分的大小写转换.
</p>
</div>
</div>
<div id="outline-container-org05aca52" class="outline-4">
<h4 id="org05aca52"><span class="todo TODO">TODO</span> 文本属性(Text Properties)</h4>
<div class="outline-text-4" id="text-org05aca52">
<p>
为文本字符分配 Lisp 属性列表.
</p>
</div>
</div>
<div id="outline-container-org2bce212" class="outline-4">
<h4 id="org2bce212">TODO</h4>
</div>
<div id="outline-container-org0bbbc89" class="outline-4">
<h4 id="org0bbbc89">TODO</h4>
</div>
<div id="outline-container-org80c4d27" class="outline-4">
<h4 id="org80c4d27">TODO</h4>
</div>
<div id="outline-container-org3d4ffbf" class="outline-4">
<h4 id="org3d4ffbf">TODO</h4>
</div>
<div id="outline-container-orgad16fda" class="outline-4">
<h4 id="orgad16fda">TODO</h4>
</div>
<div id="outline-container-org84668a5" class="outline-4">
<h4 id="org84668a5">TODO</h4>
</div>
<div id="outline-container-orgafdb7e0" class="outline-4">
<h4 id="orgafdb7e0">TODO</h4>
</div>
<div id="outline-container-orgdc50193" class="outline-4">
<h4 id="orgdc50193">TODO</h4>
</div>
<div id="outline-container-org5bc668f" class="outline-4">
<h4 id="org5bc668f">TODO</h4>
</div>
<div id="outline-container-org28aac15" class="outline-4">
<h4 id="org28aac15">TODO</h4>
</div>
<div id="outline-container-org90970db" class="outline-4">
<h4 id="org90970db">TODO</h4>
</div>
<div id="outline-container-org78e262a" class="outline-4">
<h4 id="org78e262a"><span class="todo TODO">TODO</span> 原子变化(Atomic Changes)</h4>
<div class="outline-text-4" id="text-org78e262a">
<p>
以原子方式安装缓冲区更改.
</p>
</div>
</div>
<div id="outline-container-orgf338f5a" class="outline-4">
<h4 id="orgf338f5a">TODO</h4>
</div>
</div>
<div id="outline-container-org9ab52af" class="outline-3">
<h3 id="org9ab52af"><span class="todo TODO">TODO</span> 非 ASCII 字符(Non-ASCII Characters)</h3>
<div class="outline-text-3" id="text-org9ab52af">
</div>
<div id="outline-container-org263a727" class="outline-4">
<h4 id="org263a727"><span class="todo NEXT">NEXT</span> 文本表示(Text Representations)</h4>
<div class="outline-text-4" id="text-org263a727">
<p>
Emacs 如何表示文本的.
</p>
</div>
</div>

<div id="outline-container-orgd121d78" class="outline-4">
<h4 id="orgd121d78">NEXT</h4>
</div>

<div id="outline-container-orgfbaf65b" class="outline-4">
<h4 id="orgfbaf65b"><span class="todo NEXT">NEXT</span> 转换表示形式(Converting Representations)</h4>
<div class="outline-text-4" id="text-orgfbaf65b">
<p>
单字节和多字节之间的相互转换.
</p>
</div>
</div>

<div id="outline-container-org4cb460f" class="outline-4">
<h4 id="org4cb460f">NEXT</h4>
</div>
<div id="outline-container-org65793c7" class="outline-4">
<h4 id="org65793c7"><span class="todo NEXT">NEXT</span> 字符编码(Character Codes)</h4>
<div class="outline-text-4" id="text-org65793c7">
<p>
单字节和多字节是怎样与单个字符的编码相关的.
</p>
</div>
</div>


<div id="outline-container-org52ed95a" class="outline-4">
<h4 id="org52ed95a"><span class="todo NEXT">NEXT</span> 字符属性(Character Properties)</h4>
<div class="outline-text-4" id="text-org52ed95a">
<p>
定义了字符行为和处理的字符属性
</p>
</div>
</div>

<div id="outline-container-org6d14b29" class="outline-4">
<h4 id="org6d14b29">NEXT</h4>
</div>

<div id="outline-container-orgd9ab8b3" class="outline-4">
<h4 id="orgd9ab8b3">NEXT</h4>
</div>

<div id="outline-container-orge7609cb" class="outline-4">
<h4 id="orge7609cb">NEXT</h4>
</div>

<div id="outline-container-orgfc5d22b" class="outline-4">
<h4 id="orgfc5d22b"><span class="todo NEXT">NEXT</span> 编码系统(Coding Systems)</h4>
<div class="outline-text-4" id="text-orgfc5d22b">
</div>
<ul class="org-ul">
<li><a id="org7eb2222"></a>NEXT<br /></li>

<li><a id="org99a7e9f"></a>NEXT<br /></li>

<li><a id="org0a89534"></a>NEXT<br /></li>

<li><a id="org240fde4"></a>NEXT<br /></li>

<li><a id="orgb7747d9"></a>NEXT<br /></li>

<li><a id="orge3471e0"></a>NEXT<br /></li>

<li><a id="org4ebd9de"></a><span class="todo NEXT">NEXT</span> 显式编码(Explicit Encoding)<br />
<div class="outline-text-5" id="text-org4ebd9de">
<p>
不进行 I/O 操作的情况下对文本进行编码解码.
</p>
</div>
</li>

<li><a id="orge821ea5"></a>NEXT<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org78c3e54" class="outline-3">
<h3 id="org78c3e54"><span class="todo TODO">TODO</span> 语法表(Syntax Tables)</h3>
<div class="outline-text-3" id="text-org78c3e54">
<p>
语法表控制单词和列表的解析.
</p>
</div>
<div id="outline-container-org24bb661" class="outline-4">
<h4 id="org24bb661"><span class="todo TODO">TODO</span> 语法描述符(Syntax Descriptors)</h4>
<div class="outline-text-4" id="text-org24bb661">
<p>
字符是如何分类的.
</p>
</div>
<ul class="org-ul">
<li><a id="org1658a25"></a><span class="todo TODO">TODO</span> 语法类表(Syntax Class Table)<br />
<div class="outline-text-5" id="text-org1658a25">
<p>
语法类的表格.
</p>
</div>
</li>


<li><a id="org3b7de8a"></a>TODO<br /></li>
</ul>
</div>

<div id="outline-container-orgd9a3c9f" class="outline-4">
<h4 id="orgd9a3c9f"><span class="todo TODO">TODO</span> 类别(Categories)</h4>
</div>
</div>

<div id="outline-container-org1161c82" class="outline-3">
<h3 id="org1161c82"><span class="todo TODO">TODO</span> 附录</h3>
<div class="outline-text-3" id="text-org1161c82">
</div>
<div id="outline-container-orgd5390f5" class="outline-4">
<h4 id="orgd5390f5">提示(Tips)</h4>
<div class="outline-text-4" id="text-orgd5390f5">
</div>
<ul class="org-ul">
<li><a id="org5cfe896"></a><span class="todo TODO">TODO</span> 编码惯例(Coding Conventions)<br />
<div class="outline-text-5" id="text-org5cfe896">
<p>
用于干净和健壮的程序的约定.
</p>
</div>
</li>






<li><a id="org5245b99"></a>注释提示(Comment Tips)<br />
<div class="outline-text-5" id="text-org5245b99">
</div>
</li>

<li><a id="org045e0c5"></a><span class="todo TODO">TODO</span> 标准错误(Standard Errors)<br />
<div class="outline-text-5" id="text-org045e0c5">
<p>
一些标准错误符号的列表.
</p>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">你可能也会遇到
<code>#^^</code> 的用法,这是用于子字符表的.</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">这是像 Common Lisp 和 C
语言中的常量特有的行为,与 JavaScript 和 Python 这些语言不同,如果程序试图更改不可
变对象,解释器会发出错误信号. 理想情况下, Emacs Lisp 解释器会向后者的方向发展.</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">有关排序规则和它们的本地依赖的更多信息,请参见 Unicode 排序算法
(<a href="https://unicode.org/reports/tr10/">https://unicode.org/reports/tr10/</a>). 一些标准的 C 语言库,例如 GNU C 库(glibc),
,都使用了相关的本地环境数据,通用本地数据库或是 CLDR 来实现了大部分的 Unicode
排序算法.</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4" role="doc-backlink">4</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">有时我们也把它引用为 "真列表", 但是在这个手册中我们
通常不使用这个术语.</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5" role="doc-backlink">5</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">没有严格等效的方法来将元素添加到列表的末端. 你可
以使用 <code>(append LISTNAME (list NEWELT))</code> ,它会通过复制 LISTNAME 的副本并将
NEWELT 添加到副本的末尾来创建一整个新列表. 或者你可以使用
 <code>(nconc LISTNAME (list NEWELT))</code> ,它会通过遍历所有的 CDR 然后替换掉最后的一个
<code>nil</code> 来修改 LISTNAME. 与这些都不同的是 <code>cons</code> 添加一个元素到列表的开头,但不复
制也不会修改原列表.</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6" role="doc-backlink">6</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">这里的键与术语 "按键序列"(key
sequence) 无关;它的意思是一个用来在表中查找条目的值. 在这种情况中,表格是 alist,
alist 联系作为条目.</p></div></div>

<div class="footdef"><sup><a id="fn.7" class="footnum" href="#fnr.7" role="doc-backlink">7</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">有时也被叫做
"S-expression"或"sexp"但是这个手册里通常都不会使用这一术语</p></div></div>

<div class="footdef"><sup><a id="fn.8" class="footnum" href="#fnr.8" role="doc-backlink">8</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">"环境" 的定义不是为了包
括所有可能影响程序结果的数据.</p></div></div>

<div class="footdef"><sup><a id="fn.9" class="footnum" href="#fnr.9" role="doc-backlink">9</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">更精确地讲,在默认的 "动态作用域" 规则下,值单元总是会储存变量当前的值,但在
"语法作用域" 规则下则不是这样的.细节请参见 <a href="#orgc0f0806">变量范围(Variable Scoping)</a> .</p></div></div>

<div class="footdef"><sup><a id="fn.10" class="footnum" href="#fnr.10" role="doc-backlink">10</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">也有一些例外,例如, 一个词法绑定也可
以被 Lisp 调试器访问.</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: kamisama</p>
</div>
</body>
</html>