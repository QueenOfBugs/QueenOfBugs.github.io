<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Org 手册通读+翻译</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="kamisama" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="./index.html"> UP </a>
 |
 <a accesskey="H" href="../index.html"> HOME </a>
</div><div id="content">
<h1 class="title">Org 手册通读+翻译</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org6aada7e"><span class="todo TODO">TODO</span> 简介(Introduction)</a>
<ul>
<li><a href="#org71aa59d">概要(Summary)</a></li>
<li><a href="#orgd375552">安装(Installation)</a></li>
<li><a href="#org0cf7316">激活(Activation)</a></li>
<li><a href="#org2f4e22b">反馈(Feedback)</a></li>
<li><a href="#orgf448110"><span class="done DONE">DONE</span> 惯例(Conventions)</a>
<ul>
<li><a href="#org50109a7"><span class="done DONE">DONE</span> <code>TODO</code> 关键字,标签,属性等等.</a></li>
<li><a href="#org38672d0"><span class="done DONE">DONE</span> 快捷键绑定和命令</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org16a5104"><span class="done DONE">DONE</span> 文件结构(document structure)</a>
<ul>
<li><a href="#orge399aea">标题(Headlines)</a>
<ul>
<li><a href="#orgf16226e"><span class="todo TODO">TODO</span> 跟读到 Clean View 这一部分后在这里做链接.</a></li>
<li><a href="#orgd3c9004"><span class="done DONE">DONE</span> 动态标题编号,链接.</a></li>
</ul>
</li>
<li><a href="#org1ba22fe">标题可视性切换(Visibility Cycling)</a>
<ul>
<li><a href="#orga47e322">全局和部分切换(Global and local cycling)</a></li>
<li><a href="#org5f70cef">初始的可视性(Initial visibility)</a></li>
<li><a href="#org81f9ce4">捕捉不经意的修改(Catching invisible edits)</a></li>
</ul>
</li>
<li><a href="#org0301944">跳转(Motion)</a></li>
<li><a href="#orgbc32feb">结构编辑(Structure Editing)</a></li>
<li><a href="#org7e42153">稀疏树(Sparse Trees)</a></li>
<li><a href="#org7083e39">简单列表(Plain Lists)</a></li>
<li><a href="#org9fdee05">抽屉 (Drawers)</a>
<ul>
<li><a href="#org2384833"><span class="todo TODO">TODO</span> <code>C-c C-z</code> 添加一个带时间戳的笔记到 <code>LOGBOOK</code> drawer. 写完这里,我执行了快捷键,在</a></li>
</ul>
</li>
<li><a href="#org4d7064f">块结构 (Blocks)</a></li>
</ul>
</li>
<li><a href="#org97a26fc"><span class="done DONE">DONE</span> 表格(Tables)</a>
<ul>
<li><a href="#org61f5998">内置表格编辑器(Built-in Table Editor)</a>
<ul>
<li><a href="#orgd56982b">创建和转化表格(Creation and conversion)</a></li>
<li><a href="#org30a153c">重对齐和字段移动(re-align and field motion)</a></li>
<li><a href="#orgac80628">编辑列和行(Column and row editing)</a></li>
<li><a href="#orgf373f3d">区域操作(Regions)</a></li>
<li><a href="#org77ed1fb">计算(Calculations)</a></li>
<li><a href="#orgd007e61">杂项(Miscellaneous)</a></li>
</ul>
</li>
<li><a href="#orga9708f1">列宽和对齐(Column Width and Alignment)</a></li>
<li><a href="#orgaeacd64">列组(Column Groups)</a></li>
<li><a href="#org44f1faa">Orgtbl Mode</a></li>
<li><a href="#orgf6845f0">电子表格(The Spreadsheet)</a>
<ul>
<li><a href="#orgd54f2ea">引用(Reference)</a></li>
<li><a href="#org611ac6a">Calc 的公式语法(Formula syntax for Calc)</a></li>
<li><a href="#orgf469264">Lisp 的公式语法(Formula syntax for Lisp)</a></li>
<li><a href="#org755a10a">持续时间和时间值(Durations and time values)</a></li>
<li><a href="#org96d68a2">字段和范围公式(Field and range formulas)</a></li>
<li><a href="#org3894a4e">列公式(Column formulas)</a></li>
<li><a href="#org68a4082">查找函数(Lookup functions)</a></li>
<li><a href="#orgbaac933">编辑和调试公式(Editing and debugging formulas)</a></li>
<li><a href="#orgf238ae1">更新表格(Updating the table)</a></li>
<li><a href="#org4ba437a">高级功能(Advanced features)</a></li>
</ul>
</li>
<li><a href="#org32bb6b0">Org 绘图(Org Plot)</a>
<ul>
<li><a href="#org10e1870">使用 Gnuplot 的图形绘图(Graphical plots using Gnuplot)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4ead1a4"><span class="done DONE">DONE</span> 超链接(Hyperlinks)</a>
<ul>
<li><a href="#org5eb6777">链接格式(Link Format)</a></li>
<li><a href="#orgc3efa52">内部链接(Internal Links)</a></li>
<li><a href="#orgc93661a">无线电目标(Radio Targets)</a></li>
<li><a href="#orgf0a99bf">外部链接(External Links)</a></li>
<li><a href="#org78b3dfa">处理链接(Handling Links)</a></li>
<li><a href="#org85d8cf7">Org 文件外部使用链接(Using Links Outside Org)</a></li>
<li><a href="#org5818ee7">链接缩写(Link Abbreviations)</a></li>
<li><a href="#orgc4a851d">搜索选项(Search Options)</a>
<ul>
<li><a href="#orgc85ff15">文件链接的搜索选项(Search Options in File Links)</a></li>
</ul>
</li>
<li><a href="#org8110d43">自定义搜索(Custom Searches)</a></li>
</ul>
</li>
<li><a href="#orgc0e6782"><span class="done DONE">DONE</span> <code>TODO</code> 条目(TODO Items)</a>
<ul>
<li><a href="#orgc358534"><code>TODO</code> 基础(TODO Basics)</a>
<ul>
<li><a href="#org907022d">基本的 TODO 功能(Basic TODO Functionality)</a></li>
</ul>
</li>
<li><a href="#org22b9067"><code>TODO</code> 扩展(TODO Extensions)</a>
<ul>
<li><a href="#org9374373">工作流状态(Workflow states)</a></li>
<li><a href="#orgbe90b6a"><code>TODO</code> 类型(TODO types)</a></li>
<li><a href="#org0668f14">多套关键字(Multiple sets in one file)</a></li>
<li><a href="#orgd8eb08a">快速访问 TODO 状态(Fast access to TODO states)</a></li>
<li><a href="#orgadd2f45">单文件关键字(Per-file keywords)</a></li>
<li><a href="#org397929f"><code>TODO</code> 关键字的外观(Faces for TODO keywords)</a></li>
<li><a href="#org74f7925"><code>TODO</code> 依赖项(TODO dependencies)</a></li>
</ul>
</li>
<li><a href="#org52ddf6e">进度记录(Progress Logging)</a>
<ul>
<li><a href="#org3214957">关闭条目(Closing items)</a></li>
<li><a href="#org410d180">跟踪待办状态改变(Tracking TODO state changes)</a></li>
<li><a href="#orge6b9563">跟踪你的习惯</a></li>
</ul>
</li>
<li><a href="#org89f294b">优先级(Priorities)</a></li>
<li><a href="#org1ee36e2">分解任务(Breaking Down Tasks)</a></li>
<li><a href="#orgfb4970a">复选框(Checkboxes)</a></li>
</ul>
</li>
<li><a href="#org0792758"><span class="done DONE">DONE</span> 标签(Tags)</a>
<ul>
<li><a href="#org46b40cb">标签继承(Tag Inheritance)</a></li>
<li><a href="#org75a8818">设置标签(Setting Tags)</a></li>
<li><a href="#org1cf6710">标签层级(Tag Hierarchy)</a></li>
<li><a href="#org4c0e9a9">标签搜索(Tag Searches)</a></li>
</ul>
</li>
<li><a href="#orgdb0527e"><span class="done DONE">DONE</span> 属性和列(Properties and Columns)</a>
<ul>
<li><a href="#orga6e491a">属性语法(Property Syntax)</a></li>
<li><a href="#orgd882f8c">特殊属性(Special Properties)</a></li>
<li><a href="#org20a9924">属性搜索(Property Searches)</a></li>
<li><a href="#org0a74dd0">属性继承(Property Inheritance)</a></li>
<li><a href="#orgc1b7a76">列视图(Column View)</a>
<ul>
<li><a href="#org0482b6f">定义列(Defining columns)</a></li>
<li><a href="#org2d4db1a">使用列视图(Using column view)</a></li>
<li><a href="#org4478de5">捕获列视图(Capturing column view)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org17b3112"><span class="done DONE">DONE</span> 日期和时间(Dates and Times)</a>
<ul>
<li><a href="#org1d92752">时间戳(Timestamps)</a></li>
<li><a href="#orgd2651d1">创建时间戳(Creating Timestamps)</a>
<ul>
<li><a href="#org23493ab">日期/时间提示(The date/time prompt)</a></li>
<li><a href="#orga990c7a">自定义时间格式(Custom time format)</a></li>
</ul>
</li>
<li><a href="#org1e3c531">截止时间和日程安排(Deadlines and Scheduling)</a>
<ul>
<li><a href="#org16a4e2e">插入截止日期/日程安排(Inserting deadline/schedule)</a></li>
<li><a href="#org50dcbf1">重复的任务(Repeated tasks)</a></li>
</ul>
</li>
<li><a href="#orgfd54c4c">计时工作时间(Clocking Work Time)</a>
<ul>
<li><a href="#org743be46">计时命令(Clocking commands)</a></li>
<li><a href="#org2635179"><span class="todo TODO">TODO</span> 计时表格(The clock table)</a></li>
<li><a href="#org07851a5">解决空闲时间(Resolving idle time)</a></li>
</ul>
</li>
<li><a href="#org18dc1cf">工作量估算(Effort Estimates)</a></li>
<li><a href="#org75e1f6d">计时器(Times)</a></li>
</ul>
</li>
<li><a href="#orge9fbc8f"><span class="done DONE">DONE</span> 重新归档和存档(Refiling and Archiving)</a>
<ul>
<li><a href="#org2d99101">重新归档和复制(Refile and Copy)</a></li>
<li><a href="#orgb3e7753"><span class="done DONE">DONE</span> 存档(Archiving)</a>
<ul>
<li><a href="#orgc5c7310">移动子树(Moving subtrees)</a></li>
<li><a href="#orgdbef97d">内部存档(Internal archiving)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgadde8a5"><span class="done DONE">DONE</span> 捕获和附件(Capture and Attachments)</a>
<ul>
<li><a href="#org736a35f">捕获(Capture)</a>
<ul>
<li><a href="#org9b764f7">设置捕获(Setting up capture)</a></li>
<li><a href="#orgdbc4925">使用捕获(Using capture)</a></li>
<li><a href="#orgb6e3898">捕获模版(Capture templates)</a></li>
</ul>
</li>
<li><a href="#orge357962">附件(Attachments)</a>
<ul>
<li><a href="#orga642faf">附件默认设置和调度程序(Attachment defaults and dispatcher)</a></li>
<li><a href="#orgac1ccaa">附件选项(Attachment options)</a></li>
<li><a href="#org7b0a556">附件链接(Attachment links)</a></li>
<li><a href="#org9b29fbd">使用 Git 进行自动版本控制(Automatic version-control with Git)</a></li>
<li><a href="#orgf748518">从 Dired 附加(Attach from Dired)</a></li>
</ul>
</li>
<li><a href="#orga17c781">RSS 订阅(RSS Feads)</a>
<ul>
<li><a href="#org43e805e">测试</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7296ea5"><span class="todo TODO">TODO</span> Agenda Views</a>
<ul>
<li><a href="#org8eeff9b">Agenda Files</a></li>
<li><a href="#org2e5a35b">Agenda Dispatcher</a></li>
<li><a href="#org19296e3">Built-in Agenda Views</a>
<ul>
<li><a href="#org3479471">Weekly/daily agenda</a></li>
<li><a href="#org82a7186">Global TODO list</a></li>
<li><a href="#org74ac745">匹配标签和属性(Matching tags and properties)</a></li>
<li><a href="#orga26751c">Search view</a></li>
<li><a href="#org584ae78">Stuck projects</a></li>
</ul>
</li>
<li><a href="#org23ba51a">Presentation and Sorting</a>
<ul>
<li><a href="#orge043afd">种类(Categories)</a></li>
<li><a href="#org7e3bd28">Time-of-day specifications</a></li>
<li><a href="#orgc645780">agenda 条目排序(Sorting og agenda items)</a></li>
<li><a href="#org22b8738">过滤/限制 agenda 条目(Filtering/limiting agenda items)</a></li>
</ul>
</li>
<li><a href="#orgde0d47e">Agenda Commands</a></li>
<li><a href="#org6712e4a">Custom Agenda Views</a>
<ul>
<li><a href="#orgb4466c4">保存搜索(Storing searches)</a></li>
<li><a href="#org10752d8">Block agenda</a></li>
<li><a href="#org6aac2ca">设置选项(Setting options)</a></li>
</ul>
</li>
<li><a href="#org16cef59">Exporting Agenda Views</a></li>
<li><a href="#org5423901">Agenda Column View</a></li>
</ul>
</li>
<li><a href="#org9fbde8c"><span class="done DONE">DONE</span> 富文本的标记(Markup for Rich Contents)</a>
<ul>
<li><a href="#org22ce809"><span class="done DONE">DONE</span> 段落(Paragraphs)</a></li>
<li><a href="#org5e823db"><span class="done DONE">DONE</span> 强调和Mono空格(Emphasis and Monospace)</a></li>
<li><a href="#orga4b2260"><span class="done DONE">DONE</span> 下标和上标(Subscripts and Superscripts)</a></li>
<li><a href="#orge333afc"><span class="done DONE">DONE</span> 特殊符号(Special Symbols)</a></li>
<li><a href="#org2ee3576"><span class="done DONE">DONE</span> 嵌入式 LaTex(Embeded LaTex)</a>
<ul>
<li><a href="#org584dcbd">LaTex 片段(LaTex fragments)</a></li>
<li><a href="#orgff60a9b">预览 LaTex 片段(Previewing LaTex fragments)</a></li>
<li><a href="#org0dfa678">CDLaTex 模式(CDLaTex mode)</a></li>
</ul>
</li>
<li><a href="#orge51ce3a"><span class="done DONE">DONE</span> 文字示例(Literal Examples)</a></li>
<li><a href="#org757807d"><span class="done DONE">DONE</span> 图片(Images)</a></li>
<li><a href="#org5ee64e3"><span class="done DONE">DONE</span> 说明(Captions)</a></li>
<li><a href="#orgb382a5c"><span class="done DONE">DONE</span> 水平线(Horizontal Rules)</a></li>
<li><a href="#org5b36282"><span class="done DONE">DONE</span> 创建脚注(Creating Footnotes)</a></li>
</ul>
</li>
<li><a href="#org9c28439"><span class="todo TODO">TODO</span> 导出(Exporting)</a>
<ul>
<li><a href="#org6e6f372"><span class="todo TODO">TODO</span> 导出调度器(The Export Dispatcher) 主界面(接口).</a></li>
<li><a href="#org53ffc01"><span class="todo TODO">TODO</span> 导出设置(Export Settings)</a>
<ul>
<li><a href="#orgd653688">test</a></li>
</ul>
</li>
<li><a href="#orgef922d9"><span class="todo TODO">TODO</span> 目录(Table of Contents)</a></li>
<li><a href="#org3caa2c8"><span class="todo TODO">TODO</span> 包含文件(Include File)</a></li>
<li><a href="#org77b49df">宏替换(Macro Replacement)</a></li>
<li><a href="#org63f66ca"><span class="todo TODO">TODO</span> 注释行(Comment Lines)</a></li>
<li><a href="#org98dd6be"><span class="todo TODO">TODO</span> ASCII/Latin-1/UTF-8 export</a></li>
<li><a href="#org567c68e"><span class="todo TODO">TODO</span> 幻灯片导出(Beamer Export)</a></li>
<li><a href="#org7b70547">HTML 导出(HTML Export)</a>
<ul>
<li><a href="#orga8b6477">HTML 导出命令(HTML export commands)</a></li>
<li><a href="#org6648330">HTML 特定的导出设置(HTML specific export settings)</a></li>
<li><a href="#orgb33fa7f">HTML 文档类型(HTML doctypes)</a></li>
<li><a href="#orgf9214ad">HTML 前导和后导(HTML preambel and postamble)</a></li>
<li><a href="#org6595c64">引用 HTML 标签(Quoting HTML tags)</a></li>
<li><a href="#orgb0457f4">HTML 导出的标题(Headlines in HTML export)</a></li>
<li><a href="#orge4a4f3a">HTML 导出的链接(Links in HTML export)</a></li>
<li><a href="#orga703c9c">HTML 导出的表格(Tables in HTML export)</a></li>
<li><a href="#orgdcf0d07">HTML 导出的图片(Images in HTML export)</a></li>
<li><a href="#org063f591">HTML 导出的数学格式(Math formatting in HTML export)</a></li>
<li><a href="#org43d5273">HTML 导出的文本区域(Text areas in HTML export)</a></li>
<li><a href="#org63186ef">CSS 支持(CSS support)</a></li>
<li><a href="#orgf3ed7db">JavaScript 支持(JavaScript support)</a></li>
</ul>
</li>
<li><a href="#orge915578"><span class="todo TODO">TODO</span> LaTex 导出(LaTex Export)</a></li>
<li><a href="#org962e9d4"><span class="todo TODO">TODO</span> Markdown 导出(Markdown Export)</a></li>
<li><a href="#org60428bf"><span class="todo TODO">TODO</span> OpenDocument Text 导出(OpenDocument Text Export)</a></li>
<li><a href="#org5489926"><span class="todo TODO">TODO</span> Org 导出(Org Export)</a></li>
<li><a href="#org53aa008"><span class="todo TODO">TODO</span> Texinfo 导出(Texinfo Export)</a></li>
<li><a href="#orgd5d356d"><span class="todo TODO">TODO</span> iCalendar 导出(iCalendar Export)</a></li>
<li><a href="#org1a99062"><span class="todo TODO">TODO</span> 其他内置 Back-ends(Other Built-in Back-ends)</a></li>
<li><a href="#org2f86caf">高级导出配置(Advanced Export Configuration)</a></li>
<li><a href="#org5b09c35"><span class="todo TODO">TODO</span> 在外部缓冲区导出(Export in Foreign Buffers)</a></li>
</ul>
</li>
<li><a href="#org9d02e1d"><span class="done DONE">DONE</span> 发布(Publishing)</a>
<ul>
<li><a href="#org723ab4c"><span class="done DONE">DONE</span> 配置(Configuration)</a>
<ul>
<li><a href="#org769bf85"><span class="done DONE">DONE</span> 项目关联列表(Project alist)</a></li>
<li><a href="#org9560217"><span class="done DONE">DONE</span> 来源和目的地(Sources and destinations)</a></li>
<li><a href="#org4f23154"><span class="done DONE">DONE</span> 选择文件(Selecting files)</a></li>
<li><a href="#orgce8f22d"><span class="done DONE">DONE</span> 发布行为(Publishing action)</a></li>
<li><a href="#orga56d6ff"><span class="done DONE">DONE</span> 发布选项(Publishing options)</a></li>
<li><a href="#org9acefd1"><span class="done DONE">DONE</span> 发布链接(Publishing links)</a></li>
<li><a href="#orga850101"><span class="done DONE">DONE</span> 站点地图(Site map)</a></li>
<li><a href="#org4d403f9"><span class="done DONE">DONE</span> 生成索引(Generating an index)</a></li>
</ul>
</li>
<li><a href="#orgfab865e"><span class="done DONE">DONE</span> 上传文件(Uploading Files)</a></li>
<li><a href="#org5b63523"><span class="done DONE">DONE</span> 示例配置(Sample Configuration)</a>
<ul>
<li><a href="#org8a38d68">简单的例子(Simple example)</a></li>
<li><a href="#org95e82f3">复杂的例子(Complex Example)</a></li>
</ul>
</li>
<li><a href="#orgbac7e7c"><span class="done DONE">DONE</span> 触发发布(Triggering Publication)</a></li>
</ul>
</li>
<li><a href="#orgde4233a"><span class="todo TODO">TODO</span> 引用处理(Citation handling)</a></li>
<li><a href="#org1767335"><span class="done DONE">DONE</span> 处理源代码(Working with Source Code)</a>
<ul>
<li><a href="#orga3f283f"><span class="done DONE">DONE</span> 功能预览(Features Overview)</a></li>
<li><a href="#orgf2f7b6e"><span class="done DONE">DONE</span> 代码块的结构(Structure of Code Blocks)</a></li>
<li><a href="#org05436bf"><span class="done DONE">DONE</span> 使用头参数(Using Header Arguments)</a></li>
<li><a href="#org0e36621"><span class="done DONE">DONE</span> 代码块的环境(Environment of a Code Block)</a></li>
<li><a href="#org81d9cb6"><span class="done DONE">DONE</span> 执行代码块(Evaluating Code Blocks)</a></li>
<li><a href="#org0b96222"><span class="done DONE">DONE</span> 运行的结果(Results of Evaluation)</a></li>
<li><a href="#orgcbf0681"><span class="done DONE">DONE</span> 导出代码块(Exporting Code Blocks)</a></li>
<li><a href="#org3658bc6"><span class="done DONE">DONE</span> 提取源代码(Extracting Source Code)</a></li>
<li><a href="#orgc0e7e39"><span class="done DONE">DONE</span> 语言(Languages)</a></li>
<li><a href="#org4c2c13b"><span class="done DONE">DONE</span> 编辑源代码(Editing Source Code)</a></li>
<li><a href="#orgd2719d8"><span class="done DONE">DONE</span> Noweb 引用语法(Noweb Reference Syntax)</a></li>
<li><a href="#org6769dc0"><span class="done DONE">DONE</span> Babel 库(Library of Babel)</a></li>
<li><a href="#org3ced5bc"><span class="done DONE">DONE</span> 快捷键绑定和有用的功能(Key bindings and Useful Functions)</a></li>
<li><a href="#orgc7afcff"><span class="done DONE">DONE</span> 批处理执行(Batch Execution)</a></li>
</ul>
</li>
<li><a href="#orgfdff793"><span class="todo TODO">TODO</span> 杂项(Miscellaneous)</a>
<ul>
<li><a href="#org7a8ca1a">Completion</a></li>
<li><a href="#orge6e17fa">Conflicts</a></li>
<li><a href="#orgeffbbc5">Protocols</a></li>
<li><a href="#org89bb441">转义字符(Escape Character)</a></li>
<li><a href="#org5bcee50">结构模板(Structure Templates)</a></li>
<li><a href="#org915f469">代码执行安全性(Code Evaluation Security)</a></li>
<li><a href="#org5c13de5">缓冲区内设置(In-buffer Settings)</a></li>
</ul>
</li>
<li><a href="#org15ee510"><span class="todo TODO">TODO</span> Hacking</a>
<ul>
<li><a href="#org70fc20b">Dynamic Blocks</a></li>
<li><a href="#orge6a66a0">Adding Hyperlink Types</a></li>
</ul>
</li>
<li><a href="#org7a2c496"><span class="todo TODO">TODO</span> History and Acknowledgments</a></li>
<li><a href="#org5913762"><span class="todo TODO">TODO</span> GNU Free Documentation License</a></li>
<li><a href="#orga6c95c7"><span class="todo TODO">TODO</span> Main Index</a></li>
<li><a href="#orge3eae6a"><span class="todo TODO">TODO</span> Key Index</a></li>
<li><a href="#orgcfc06ac"><span class="todo TODO">TODO</span> Command and Function Index</a></li>
<li><a href="#org74c6950"><span class="todo TODO">TODO</span> Variable Index</a></li>
<li><a href="#org3d187b4"><span class="todo TODO">TODO</span> 正则表达式(Regular Expressions)</a></li>
<li><a href="#orgf8101e2"><span class="todo TODO">TODO</span> Unfinished task</a></li>
<li><a href="#org0c42067"><span class="todo TODO">TODO</span> Questions &amp; Answers</a>
<ul>
<li><a href="#orgb750e15">orgmode '#STARTUP: hideblocks' doesn't work</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org6aada7e" class="outline-2">
<h2 id="org6aada7e"><span class="todo TODO">TODO</span> 简介(Introduction)</h2>
<div class="outline-text-2" id="text-org6aada7e">
</div>
<div id="outline-container-org71aa59d" class="outline-3">
<h3 id="org71aa59d">概要(Summary)</h3>
<div class="outline-text-3" id="text-org71aa59d">
<p>
Org 能做什么的概要.
</p>

<p>
Org 是一个模式,它用快速高效的纯文本标记语言来记录笔记,维护待办列表和项目计划.它
也是一个创作系统,对文学式编程和可复现的研究具有独特支持.
</p>

<p>
Org 是在大纲模式的基础上实现的,这使得它能保持大型文件的结构良好.可视性循环和结构
编辑有助于使用树结构.使用内置的表格编辑器很容易创建表格.纯文本URL链接连接到网
站,邮件,新闻消息,BBDB 条目和任何与项目关联的文件.
</p>

<p>
Org
</p>
</div>
</div>
<div id="outline-container-orgd375552" class="outline-3">
<h3 id="orgd375552">安装(Installation)</h3>
<div class="outline-text-3" id="text-orgd375552">
<p>
安装 Org.
</p>
</div>
</div>
<div id="outline-container-org0cf7316" class="outline-3">
<h3 id="org0cf7316">激活(Activation)</h3>
<div class="outline-text-3" id="text-org0cf7316">
<p>
如何在特定缓冲区里激活 Org.
</p>
</div>
</div>
<div id="outline-container-org2f4e22b" class="outline-3">
<h3 id="org2f4e22b">反馈(Feedback)</h3>
<div class="outline-text-3" id="text-org2f4e22b">
<p>
报告 Bug, 想法和补丁等等.
</p>
</div>
</div>
<div id="outline-container-orgf448110" class="outline-3">
<h3 id="orgf448110"><span class="done DONE">DONE</span> 惯例(Conventions)</h3>
<div class="outline-text-3" id="text-orgf448110">
<p>
本手册中使用的习惯用语.
</p>
</div>
<div id="outline-container-org50109a7" class="outline-4">
<h4 id="org50109a7"><span class="done DONE">DONE</span> <code>TODO</code> 关键字,标签,属性等等.</h4>
<div class="outline-text-4" id="text-org50109a7">
<p>
Org 使用各种语法元素: TODO 关键字, 标签(tags), 属性名称, 关键字, 块等等.在这个手
册里,我们使用下面的约定:
</p>
<dl class="org-dl">
<dt><code>TODO</code> , <code>WAITING</code></dt><dd>TODO 关键字所有字母使用大写,即使他们是用户自定义的.</dd>
<dt><code>boss</code> , <code>ARCHIVE</code></dt><dd>标签是大小写敏感的.用户自定义的标签通常是小写的;内置的有特殊
意义的标签按其在文档中显示的方式书写,通常是所有字母大写.</dd>
<dt><code>Release</code> , <code>PRIORITY</code></dt><dd>用户定义的属性是首字母大写的,内置的有特殊意义的属性是全
部大写的.</dd>
<dt><code>TITLE</code> , <code>BEGIN ... END</code></dt><dd>关键字和块结构是使用大写形式书写来增加其可读性,但是你
也可以在你的 Org 文件里使用小写形式.</dd>
</dl>
</div>
</div>
<div id="outline-container-org38672d0" class="outline-4">
<h4 id="org38672d0"><span class="done DONE">DONE</span> 快捷键绑定和命令</h4>
<div class="outline-text-4" id="text-org38672d0">
<p>
手册列出了访问功能的快捷键和相应的命令. Org mode 经常对不同的方法(命令)使用相同
的快捷键,这取决于上下文.被这样的快捷键绑定的命令有一个通用名称,比如
<code>org-metaright</code>. 在手册中,我们会尽可能给出通用命令在内部调用的函数.例如,在文档结构
的章节, <code>M-&lt;RIGHT&gt;</code> 将会展示为调用 <code>org-do-demote</code>, 然而在表格的章节,它会被列出以调
用 <code>org-table-move-column-right</code>.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org16a5104" class="outline-2">
<h2 id="org16a5104"><span class="done DONE">DONE</span> 文件结构(document structure)</h2>
<div class="outline-text-2" id="text-org16a5104">
<p>
Org 是一个大纲编辑器. 大纲让文件以层次结构组织文本,是一种很好的记录笔记和想法
的工具.层次结构的概述是以折叠的方式实现的,也就是隐藏文档的大部分内容,只展示大
致的文本结构和当前正在编辑(阅读)的部分. Org 将整个显示和隐藏的功能压缩到一个命
令: <code>org-cycle</code> 这极大地简化了大纲的使用,这个命令被绑定到 <code>&lt;TAB&gt;</code> 快捷键.
如果打开这个笔记的 org 形式源文件,将光标移动到标题上,按下 <code>&lt;TAB&gt;</code> ,就可以看到这
段文本都被隐藏,只显示这段内容的标题,
</p>
</div>

<div id="outline-container-orge399aea" class="outline-3">
<h3 id="orge399aea">标题(Headlines)</h3>
<div class="outline-text-3" id="text-orge399aea">
<blockquote>
<p>
这部分内容是关于如何排版 Org 标题树的.
</p>
</blockquote>
<p>
标题(Headlines) 定义了大纲树的结构.一个 Org 标题从行首(左边缘 left margin)开
始, 格式为一个或多个星号 <code>*</code> 再加上一个空格,后面跟标题名.
</p>
<pre class="example">
* Top level
** Second level
*** Third level
    some content
* Another top level headline
</pre>
<p>
<code>org-footnote-section</code> 这个变量的值是作为'关键字'的角色被保留的,其默认值一般都
是 "Footnotes", 这是用来做页脚的.不要用这个词作为标题名.
有些人觉得多个星号 <code>*</code> 会很烦,他们可能会希望能用多个空格做缩进,只用一个星号来表
示层级.这个需求可以通过Org Indent minro mode 实现.
</p>
</div>

<div id="outline-container-orgf16226e" class="outline-4">
<h4 id="orgf16226e"><span class="todo TODO">TODO</span> 跟读到 Clean View 这一部分后在这里做链接.</h4>
<div class="outline-text-4" id="text-orgf16226e">
<p>
标题是没有编号的,但是可以动态的对他们进行部分或全部编号.更具体可以查看
Dynamic Headline Numbering 这一部分.
</p>
</div>
</div>

<div id="outline-container-orgd3c9004" class="outline-4">
<h4 id="orgd3c9004"><span class="done DONE">DONE</span> 动态标题编号,链接.</h4>
<div class="outline-text-4" id="text-orgd3c9004">
<p>
一个标题子树内容中,最后一行的空白行会被当作该子树的一部分,在折叠时会被折叠.但如果
最后有超过两行的空行,在折叠后标题之间就会有一行空行被保留,用来构成折叠视图.
查看变量 <code>org-cycle-separator-lines</code> 来调整这个行为.
</p>

<p>
当光标位于标题上时,可以通过快捷键 <code>C-a</code> , <code>C-e</code> , <code>C-k</code> 来在层级间进行光标移动,具体
表现行为看这三个变量的配置 <code>org-special-ctrl-a/e</code> <code>org-special-ctrl-k</code>
<code>org-ctrl-k-protect-subtree</code> .
还要注意下, clocking (计时) 功能只在层级小于等于三十,也就是星号不多于30个的标
题下工作,超过30层级,这个功能就不能使用了.
</p>
</div>
</div>
</div>

<div id="outline-container-org1ba22fe" class="outline-3">
<h3 id="org1ba22fe">标题可视性切换(Visibility Cycling)</h3>
<div class="outline-text-3" id="text-org1ba22fe">
<blockquote>
<p>
这部分是关于隐藏和显示 Org 大纲的.标题可视性就是标题的折叠状态.
</p>
</blockquote>
</div>
<div id="outline-container-orga47e322" class="outline-4">
<h4 id="orga47e322">全局和部分切换(Global and local cycling)</h4>
<div class="outline-text-4" id="text-orga47e322">
<p>
大纲功能可以隐藏当前缓冲区的部分文本. Org 只用两个命令去改变缓冲区文本的可视
性,默认被绑定到 <code>&lt;TAB&gt;</code> 和 <code>S-&lt;TAB&gt;</code> 快捷键.
</p>

<ul class="org-ul">
<li><p>
<code>&lt;TAB&gt;</code> &#x2013; (<code>org-cycle</code>) 部分折叠:
</p>

<ul class="org-ul">
<li>TODO 在当前子树条目中循环切换可视状态.</li>
</ul>
<p>
折叠状态 -&gt; 显示子标题树 -&gt; 显示子树内容 -&gt; 折叠
</p>

<p>
光标必须要在标题上切换才起作用.配置 <code>org-cycle-emulate-tab</code> 变量可以配置快捷键
<code>&lt;TAB&gt;</code> 起作用的情况.
</p></li>

<li><p>
<code>&lt;S-TAB&gt;</code> 或者 <code>C-u &lt;TAB&gt;</code> &#x2013; (<code>org-global-cycle</code>) 全局折叠:
</p>

<p>
在整个缓冲区的内容中循环切换可视状态.
总览 -&gt; 层级内容 -&gt; 显示全部 -&gt; 总览.
</p>

<p>
当用数字前缀 N 调用全局切换时,视图内容会直接切换到第 N 层级.
</p>

<p>
当在表格(Tables)中使用全局切换快捷键时 <code>S-&lt;TAB&gt;</code> 会跳到上一格表格内容,而不是切
换标题的折叠状态.
</p>

<p>
如果光标在缓冲区最开始的地方,但是不在一个标题上,并且变量
<code>org-cycle-global-at-bob</code> 的值被设为非空(non-<code>nil</code>),那么此时使用 <code>&lt;TAB&gt;</code> 也能进行
全局的标题可视性切换.
</p></li>

<li><code>C-u C-u &lt;TAB&gt;</code> &#x2013; (<code>org-set-startup-visibility</code>) 初始折叠状态:</li>
</ul>


<p>
切换到缓冲区的初始可视状态.详情: Initial visibility
</p>

<ul class="org-ul">
<li><p>
<code>C-u C-u C-u &lt;TAB&gt;</code> &#x2013; (<code>outline-show-all</code>) 展开全部:
</p>

<p>
展开全部内容,所有内容都不折叠,包括 drawers.
</p></li>

<li><p>
<code>C-c C-r</code> &#x2013; (<code>org-reveal</code>) 显示上下文:
</p>

<p>
显示光标附近的内容:当前条目,下面和上面的标题.这在使用了稀疏树(sparse tree)
命令或者日程(agenda) 命令时有用.加一个前缀参数使用,会展示每一层级的所有兄
弟标题.加上两个前缀参数,会展示上一层级标题的整个子树.
</p></li>

<li><p>
<code>C-c C-k</code> &#x2013; (<code>outline-show-branches</code>) 显示子树:
</p>

<p>
显示所有的子树的所有标题,不包括内容.
</p></li>

<li><p>
<code>C-c C-x b</code> &#x2013; (<code>org-tree-to-indirect-buffer</code>) 分屏显示:
</p>

<p>
打开一个新的缓冲区,展示当前的子树.
</p>

<p>
打开的这个新的缓冲区(indirect buffer)内容和当前缓冲区内容一致,但是会显示当
前条目的内容. 编辑这个新缓冲区会改变原缓冲区内容,但是不会影响原缓冲区的折
叠状态.
</p></li>

<li><p>
<code>C-c C-x v</code> &#x2013; (<code>org-copy-visible</code>) 复制可视内容:
</p>

<p>
将选中区域的文本内容复制到剪切板,默认情况下就算折叠了,对折叠后的大纲视图进
行复制操作,会将隐藏的内容一起复制,但用这个快捷键,可以只复制选中区域显示出
来的内容.
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org5f70cef" class="outline-4">
<h4 id="org5f70cef">初始的可视性(Initial visibility)</h4>
<div class="outline-text-4" id="text-org5f70cef">
<p>
当 Emacs 第一次打开一个 Org 文件时, 全局状态被设置为显示所有
('showeverything'), 也就是说,文件的所有内容都会被显示. 这个行为可以通过配置
<code>org-startup-folded</code> 变量改变,或者也可以在每个文件缓冲区的任意位置添加下面的某
一行代码进行配置.
</p>
<pre class="example">
#+STARTUP: overview
#+STARTUP: content
#+STARTUP: showall
#+STARTUP: showeverything
</pre>

<p>
此外,任意一个拥有 'VISIBILITY' 属性的条目也会相应地调整其可见性. 这个属性可选
的值有 <code>folded</code>, <code>children</code>, <code>content</code> 和 <code>all</code>
</p>

<ul class="org-ul">
<li><p>
<code>C-u C-u &lt;TAB&gt;</code> &#x2013; <code>(org-set-startup-visibility)</code>:
</p>

<p>
切换到该缓冲区最初始的折叠状态(初始可见性),初始可见性就是 startup 选项和
每个条目的 <code>VISIBILITY</code> 属性所设置任何折叠状态.
</p></li>
</ul>

<p>
当 <code>org-agenda-inhibit-startup</code> 参数非空时(non-<code>nil</code>), 如果第一次打开一个 agenda
文件, Org 不会遵守默认的可见性状态的设置(Speeding Up Your Agendas)
</p>
</div>

<ul class="org-ul">
<li><a id="org84a97c6"></a><span class="todo TODO">TODO</span> Speeding Up Your Agendas 需要链接.<br /></li>
</ul>
</div>

<div id="outline-container-org81f9ce4" class="outline-4">
<h4 id="org81f9ce4">捕捉不经意的修改(Catching invisible edits)</h4>
<div class="outline-text-4" id="text-org81f9ce4">
<p>
有时候, 当无意识地编辑了缓冲区中不可视的内容时,会遇到不知道到底什么被编辑了
和怎么撤销错误的问题.
将 <code>org-catch-invisible-edits</code> 设置为非空(non-<code>nil</code>) 可以禁止编辑折叠的内容.阅读
这个变量的文档来查看 Org 是如何处理和捕获不可视的内容的编辑的.
</p>
</div>
</div>
</div>

<div id="outline-container-org0301944" class="outline-3">
<h3 id="org0301944">跳转(Motion)</h3>
<div class="outline-text-3" id="text-org0301944">
<blockquote>
<p>
这部分是关于跳转到其他标题的.
</p>
</blockquote>
<p>
下面这些命令能在缓冲区中跳转到其他的标题.
</p>

<ul class="org-ul">
<li><p>
<code>C-c C-n</code> &#x2013; <code>(org-next-visibile-heading)</code>:
</p>

<p>
跳转到下一个标题.
</p></li>

<li><p>
<code>C-c C-p</code> &#x2013; <code>(org-previous-visible-heading)</code>:
</p>

<p>
跳转到上一标题.
</p></li>

<li><p>
<code>C-c C-f</code> &#x2013; <code>(org-forward-heading-same-level)</code>:
</p>

<p>
跳转到同一层级的下一个标题.
</p></li>

<li><p>
<code>C-c C-b</code> &#x2013; <code>(org-backward-heading-same-level)</code>:
</p>

<p>
跳转到同一层级的上一个标题.
</p></li>

<li><p>
<code>C-c C-u</code> &#x2013; <code>(outline-up-heading)</code>:
</p>

<p>
跳转到上一层级的标题.
</p></li>

<li><p>
<code>C-c C-j</code> &#x2013; <code>(org-goto)</code>:
</p>

<p>
在不改变当前视图的折叠状态前提下跳转到其他地方.将文本结构在一个临时的缓冲区
里展示,在这个缓冲区里可以使用下面这些快捷键来找到要跳转的位置:
</p>
<ul class="org-ul">
<li><code>&lt;TAB&gt;</code>: 切换折叠状态.</li>
<li><code>&lt;DOWN&gt;</code> 或 <code>&lt;UP&gt;</code> : 下一个或上一个标题.</li>
<li><code>&lt;RET&gt;</code> ： 选择当前位置.</li>
<li><code>/</code> : 做稀疏树(Sparse-tree)查找,就是筛选内容.</li>
</ul>

<p>
如果关闭了 <code>org-goto-auto-isearch</code> 选项(将变量设置为 <code>nil</code>), 那么下面的快捷键也
可以在临时的缓冲区中使用:
</p>
<ul class="org-ul">
<li><code>n</code> 或 <code>p</code> : 下一个或上一个标题.</li>
<li><code>f</code> 或 <code>b</code> : 下一个或上一个同级标题.</li>
<li><code>u</code>      : 上个层级标题.</li>
<li><code>0</code> &#x2026; <code>9</code>: 数字参数.</li>
<li><code>q</code>      : 退出.</li>
</ul>

<p>
<code>org-goto</code> 的界面设置可以查看 <code>org-goto-interface</code> 变量的文档.
</p></li>
</ul>
</div>
</div>


<div id="outline-container-orgbc32feb" class="outline-3">
<h3 id="orgbc32feb">结构编辑(Structure Editing)</h3>
<div class="outline-text-3" id="text-orgbc32feb">
<blockquote>
<p>
这部分内容是如何改变标题的次序和层级.
</p>
</blockquote>
<ul class="org-ul">
<li><p>
<code>M-&lt;RET&gt;</code> &#x2013; <code>(org-meta-return)</code>:
</p>

<p>
插入新(同级)标题,新条目或新的一行.
</p>

<p>
如果光标在行首时使用这个命令,而且处于一个标题或普通列表项目范围内,那么就会
在当前行的上一行创建一个标题或列表项.如果一行文本不处于任何一个结构的范围,
就是一个没有缩进的普通行,当光标处于普通行的行首,使用这个命令,Org 会把这一行
转变为一个标题,标题层级和最近(向上查找)的标题层级相同.
</p>

<p>
当在一行的中间使用这个命令时,这一行会被分割,光标之前的内容不变,之后的内容会
被转换成一个新的列表项或者标题. 如果不想内容被分割,可以定制
<code>org-M-RET-may-split-line</code> 这个变量.
</p>

<p>
当加上一个 <code>C-u</code> 前缀使用这个命令时,会无条件地在当前的子树的之后插入一个新的
同级标题.当将上两个 <code>C-u</code> 前缀使用这个命令(<code>C-u C-u</code>) 时,会在当前子树的同级标题
的最后一个标题之后插入一个新的标题.
</p></li>

<li><p>
<code>C-&lt;RET&gt;</code> &#x2013; <code>(org-insert-heading-respect-content)</code>:
</p>

<p>
在当前子树的最后插入一个同级标题
</p></li>

<li><p>
<code>M-S-&lt;RET&gt;</code> &#x2013; <code>(org-insert-todo-heading)</code>:
</p>

<p>
插入一个新的,和当前标题同级的 TODO 项目. 更多详情参考
<code>org-treat-insert-todo-heading-as-state-change</code> 变量的文档.
</p></li>

<li><p>
<code>C-S-&lt;RET&gt;</code> &#x2013; <code>(org-insert-todo-heading-respect-content)</code>:
</p>

<p>
插入一个新的 TODO 标题项目, 项目层级和当前标题同级. 和 <code>C-&lt;RET&gt;</code> 类似,新的标
题会在当前标题之后插入
</p></li>

<li><p>
<code>&lt;TAB&gt;</code> &#x2013; <code>(org-cycle)</code>:
</p>

<p>
如果一个新的项目还没有任何内容,第一次按下 <code>&lt;TAB&gt;</code> 会降低当前项目的层级,第二次
会将层级提升,继续按可以一直提升到最高层级.提升到最高层级后再按 <code>&lt;TAB&gt;</code> 会回到
创建该项目时的初始层级.
</p></li>

<li><p>
<code>M-&lt;LEFT&gt;</code> &#x2013; <code>(org-do-promote)</code> 和 <code>M-&lt;RIGHT&gt;</code> &#x2013; <code>(org-do-demode)</code>:
</p>

<p>
直接提升或降低标题的层级
</p></li>

<li><p>
<code>M-S-&lt;LEFT&gt;</code> &#x2013; <code>(org-promote-subtree)</code>:
</p>

<p>
将当前标题以及其下的子标题的标题等级全都提升一级.
</p></li>

<li><p>
<code>M-S-&lt;RIGHT&gt;</code> &#x2013; <code>(org-demore-subtree)</code>:
</p>

<p>
将当前标题以及其下的子标题的标题等级全都降低一级.
</p></li>

<li><p>
<code>M-&lt;UP&gt;</code> &#x2013; <code>(org-move-subtree-up)</code>:
</p>

<p>
将当前子树的位置上移,就是和同级的上一个标题交换位置.
</p></li>

<li><p>
<code>M-&lt;DOWN&gt;</code> &#x2013; <code>(org-move-subtree-down)</code>:
</p>

<p>
将当前子树的位置下移,就是和同级的下一个标题交换位置.
</p></li>

<li><p>
<code>C-c @</code> &#x2013; <code>(org-mark-subtree)</code>:
</p>

<p>
标记当前所在子树.重复使用会标记同级的下一个子树.就是选中整个子树.
</p></li>

<li><p>
<code>C-c C-x C-w</code> &#x2013; <code>(org-cut-subtree)</code>:
</p>

<p>
剪切当前子树,就是将当前子树的内容从缓冲区中移除到剪切板.加上数字前缀 N 使用
可以移除包括当前子树在内的连续的 N 个子树.
</p></li>

<li><p>
<code>C-c C-x M-w</code> &#x2013; <code>(org-copy-subtree)</code>:
</p>

<p>
复制当前子树的内容到剪切板, 加上数字前缀参数 N 使用,会复制包括当前子树在内
的连续的 N 个子树.
</p></li>

<li><p>
<code>C-c C-x C-y</code> &#x2013; <code>(org-paste-subtree)</code>:
</p>

<p>
从剪切板中粘贴子树内容到光标位置. 这个操作会改变被粘贴的内容的层级结构,以便
其能够和粘贴位置的层级相对应. 粘贴的层级可以通过数字前缀参数来改变,也可以在
标题标记星号后面粘贴来决定层级,比如在 <code>****</code> 后面粘贴,粘贴内容层级会自动调整.
</p></li>

<li><p>
<code>C-y</code> &#x2013; <code>(org-yank)</code>:
</p>

<p>
这个命令的表现取决于两个变量: <code>org-yank-adjusted-subtrees</code> 和
<code>org-yank-folded-subtrees</code>,Org 的内置粘贴命令会像上一个命令一样智能的处理标题
的层级和折叠. 默认设置里,被粘贴出的内容不会改变层级,但是会被折叠起来,除非折
叠会影响到之前能看见的文本内容.与任何的前缀参数一起使用就会执行普通的粘贴命
令.
</p></li>

<li><p>
<code>C-c C-x c</code> &#x2013; <code>(org-clone-subtree-with-time-shift)</code>:
</p>

<p>
复制光标所在的子树项目,并打开一个对话输入需要粘贴的内容份数.而且这个命令还
可以指定项目中的时间戳如何变化. 比如在又一系列演讲需要准备时,这个命令就很有
用,创建第一个要准备的项目,然后复制多个,并调整时间. 更多细节可以查看
<code>org-clone-subtree-with-time-shift</code> 命令的文档.
</p></li>

<li><p>
<code>C-c C-w</code> &#x2013; <code>(org-refile)</code>:
</p>

<p>
将条目或区域重新安排到新的位置
</p></li>

<li><p>
<code>C-c ^</code> &#x2013; <code>(org-sort)</code>:
</p>

<p>
排序同级项目. 当有选中区域时,所有区域中的项目会被排序.没有选中区域,则当期那
标题的所有子标题都会被排序.这个命令会打开一个对话框,选择排序方法.
</p></li>

<li><p>
<code>C-x n s</code> &#x2013; <code>(org-narrow-to-subtree)</code>:
</p>

<p>
将当前缓冲区缩小到光标所在子树项目.像是专注模式一样.
</p></li>

<li><p>
<code>C-x n b</code> &#x2013; <code>(org-narrow-to-block)</code>:
</p>

<p>
将缓冲区缩小到光标所在块结构.
</p></li>

<li><p>
<code>C-x n w</code> &#x2013; <code>(widen)</code>:
</p>

<p>
取消缩小缓冲区的操作,回到原来的视图.
</p></li>

<li><p>
<code>C-c *</code> &#x2013; <code>(org-toggle-heading)</code>:
</p>

<p>
将普通行转化成标题,或者将标题转变成普通行.如有又选中区域,会将所有选中的行都
转变为标题.选中区域如果第一行是标题,那只会将选中区域全变成普通行,第一行是普
通行,那就将选中区域变成标题.
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org7e42153" class="outline-3">
<h3 id="org7e42153">稀疏树(Sparse Trees)</h3>
<div class="outline-text-3" id="text-org7e42153">
<blockquote>
<p>
上下文匹配内嵌内容.(稀疏表示是降低表示的复杂度,或者说是减少参数稀疏)这里我理解
的话就是通过正则等手段筛选符合条件的内容,隐藏不想看到的内容,只展示筛选的结果.
</p>
</blockquote>
<p>
Org mode 一个重要的特性就是可以构造稀疏树(Sparse Trees), 用来选择大纲树中的信
息,这让整个文档尽可能的折叠,只显示被选中的信息和信息的标题.只要试试就能很快直
到这个功能是干嘛用的了.
</p>

<p>
Org 有几个用来创建这样的树的命令,这些命令可以通过一个调度器来调用:
</p>

<ul class="org-ul">
<li><p>
<code>C-c /</code> &#x2013; <code>(org-sparse-tree)</code>:
</p>

<p>
这个快捷键打开一个对话,用来选择创建稀疏树的命令.
</p></li>

<li><p>
<code>C-c / r</code> 或 <code>C-c / /</code> &#x2013; <code>(org-occur)</code>:
</p>

<p>
提示输入正则表达式,并显示所有匹配的稀疏树.如果匹配的是标题,那就显示这个标题,如
果匹配的是内容,那内容和标题都会显示.每个匹配项都会被高亮显示,当缓冲区被编辑
命令修改时,或者按 <code>C-c C-c</code> 高亮会消失. 当和 <code>C-u</code> 前缀参数一起使用时,之前的高
亮会被保留,所以这个命令多次使用的结果可以叠加.
</p>

<p>
<code>C-c C-c</code> 高亮消失的行为取决于变量 <code>org-remove-highlights-with-change</code>.
</p></li>
<li><p>
<code>M-g n</code> 或 <code>M-g M-n</code> &#x2013; <code>(next-error)</code>:
</p>

<p>
跳到下一个稀疏树的匹配结果.
</p></li>

<li><p>
<code>M-g p</code> 或 <code>M-g M-p</code> &#x2013; <code>(previous-error)</code>:
</p>

<p>
跳到上一个稀疏树的匹配结果.
</p></li>
</ul>

<p>
对于经常使用的生成稀疏树的搜索字符串,可以用 <code>org-agenda-custom-commands</code> 变量来
定义快捷键得到指定的稀疏树. 这个变量中的命令可以通过日程调度器使用.例如:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">setq</span> org-agenda-custom-commands
      '((<span style="font-style: italic;">"f"</span> occur-tree <span style="font-style: italic;">"FIXME"</span>)))
</pre>
</div>
<p>
上面的代码将按键 <code>f</code> 定义为创建 <code>FIXME</code> 稀疏树的快捷方式.
</p>

<p>
其他的基于 TODO 关键字,标签,或者是属性等的稀疏树命令会在之后讨论.
</p>

<p>
要打印稀疏树,可以使用 <code>ps-print-buffer-with-faces</code> 命令,这个命令不会打印文档被
折叠或隐藏的部分.或者也可以使用 <code>C-c C-e C-v</code> 只导出可见的部分,然后再打印导出的
文件.
</p>

<p>
稀疏树显示匹配结果附近的上下文多少可以用 <code>org-show-context-detail</code> 变量配置.
</p>
</div>
</div>
<div id="outline-container-org7083e39" class="outline-3">
<h3 id="org7083e39">简单列表(Plain Lists)</h3>
<div class="outline-text-3" id="text-org7083e39">
<blockquote>
<p>
在一个标题条目中,额外的结构.
</p>
</blockquote>

<p>
在一个大纲树项目中,手动格式化的列表可以提供额外的结构. 这种额外结构提供了一种
创建复选框(Checkboxes)的方式.Org 支持编辑这类列表,并且每个导出器都能解析和格
式化他们.
</p>

<p>
Org 支持有序和无序列表,还支持 '描述'类型列表.
</p>
<ul class="org-ul">
<li>无序列表由 <code>+</code> , <code>-</code> ,或者 <code>*</code> 作为标示.</li>
</ul>

<ul class="org-ul">
<li>有序列表由数字开始跟着一个点号 <code>.</code> 或者右括号 <code>)</code>,例如 <code>1.</code> 或 <code>1)</code>.如果想要列表
以字母开始,可以配置变量 <code>org-list-allow-alphabetical</code>, 就可以使用诸如
<code>a.</code>, <code>A.</code> , <code>a)</code> 和 <code>A)</code> 这样的编号开头的列表.如果想用不同的数开始,例如: <code>20</code>,只
要在列表项的开头加上 <code>[@20]</code> 这样列表项就会自动变成以20开头的,而不管上一个
列表项的标号是多少.</li>
<li>描述型列表是无序列表,包含了分割符 <code>::</code> 用来区分列表内容和描述内容:

<dl class="org-dl">
<dt>描述列表</dt><dd>这个是描述列表,具体效果就是这样滴.</dd>
</dl></li>

<li><p>
各种列表的测试结果:
</p>
<ul class="org-ul">
<li>这是 <code>*</code> 列表项,在 Org 里表现为一个小圆点</li>
</ul>
<p>
注意列表项的标示不要混用,混用的话Org会同将其他标示转变为第一个标示符号.
</p>
<ol class="org-ol">
<li>这是有序列表的第一项.</li>
<li>上面说的不要混用指的是不要在同一层级 <code>+-*</code> 混用,同一层级只用一种标示就好
了.
<ul class="org-ul">
<li>这是一个 <code>+</code> 做标示的列表项,在Org里表现为一个箭头.</li>
</ul></li>
<li>再来一个 <code>-</code> 的无序列表:
<ul class="org-ul">
<li>这是一个 <code>-</code> 的无序列表项,Org里好象表现为大一点的减号,真的就大一点点.</li>
</ul></li>
</ol>
<p>
最后再来个描述型列表:
</p>
<dl class="org-dl">
<dt>描述型</dt><dd>这就是描述型的列表.</dd>
<dt>第二个</dt><dd>这是第二个描述型列表, 分割符 <code>::</code> 是需要与列表项的文本空格隔开
的,不要傻傻用 <code>- desc::blablabla</code> 这种.</dd>
<dt>导出效果</dt><dd>导出为html 的时候,这些无序列表的表现形式只会随层级变化,从实
心圆点到空心圆点到方块黑点等等,和在Org 里显示的无关.</dd>
<dt>用处</dt><dd>这个描述型列表刚好适用于手册里那么多命令和对应的描述,不用担心缩
进出错导致排版有问题,而且导出后排版还挺好的.</dd>
</dl></li>
</ul>


<p>
Org 支持这些列表的转化,填充和包裹操作的命令,也支持正确导出他们.因为缩进是
用来管理这些列表的,所以许多其他结构,例如 <code>#+BEGIN_</code> 代码块能够通过缩进来标
示他们从属于某一个特定的列表项.
</p>

<p>
如果发现在下级列表中使用不同的标示符对于可读性由帮助的话,可以定制变量
<code>org-list-demote-modify-bullet</code>. 这个变量自动将下级列表的标示符转化成设定好
的不同标示符. 如果想要列表项和其下级列表项的缩进更明显,可以定制
<code>org-list-indent-offset</code> 变量,将这个变量设置为比较大的数字比如4,这样在下级
列表项会在上级列表项的基础上缩进四个空格.
</p>

<p>
下面的命令在光标处于列表项的第一行,也就是有标示符或数字的那一行时起作用.其
中有一些命令会使用一些自动化规则,用来保证列表的结构完整.如果这些自动的行
为妨碍到你,可以配置 <code>org-list-automatic-rules</code> 变量来禁用这些行为.
</p>

<dl class="org-dl">
<dt><code>&lt;TAB&gt;</code> &#x2013; <code>(org-cycle)</code></dt><dd>列表项也可以像标题一样折叠.通常这只在光标处于列
表项上时起作用.更多细节参 考变量 <code>org-cycle-include-plain-lists</code> 文档. 当
这个变量被设置为 <code>integrate</code> 简单列表会被当作低等级的标题来处理.列表项的
等级由标示符或数字的缩进来决定.列 表项总是标题的下级,但列表项的等级结构
是分开保持的. 在一个没有文本的新列表 象上使用 <code>&lt;TAB&gt;</code> ,第一次按会将其降级
为原来的子项,再按会将回到原来等级,继续 按会一直提升层级一直到列表项的所
属的最高层级,最后回到原来的层级.</dd>
<dt><code>M-&lt;RET&gt;</code> &#x2013; <code>(org-insert-heading)</code></dt><dd>插入一个新的同级列表项. 和前缀参数一
起使用,会强制插入一个新的标题项.如果这个命令在项目中间使用,这个项目会被
分成两部分,第二部分会成为新的列表项.如果命令在项目内容的最前执行,新的项
目会在原项目之前创建.</dd>
<dt><code>M-S-&lt;RET&gt;</code></dt><dd>插入一个有复选框的列表项.</dd>
<dt><code>S-&lt;UP&gt; S-&lt;DOWN&gt;</code></dt><dd>跳转到当前列表的上一或下一项,但只有
<code>org-support-shift-select</code> 是 <code>nil</code> 才行.如果不为空,用 <code>C-&lt;UP&gt;</code> 和 <code>C-&lt;DOWN&gt;</code>
也能得到相似效果.</dd>
<dt><code>M-&lt;UP&gt; M-&lt;DOWN&gt;</code></dt><dd>调整当前列表项在同级列表中的顺序.</dd>
<dt><code>M-S-&lt;LEFT&gt; M-S-&lt;RIGHT&gt;</code></dt><dd>调整列表项的层级.</dd>
<dt><code>C-c C-c</code></dt><dd>如果列表项是复选框,那么这个命令切换复选框的状态.在其他情况下,检
查整个列表标示符和缩进的一致性.</dd>
<dt><code>C-c -</code></dt><dd>循环切换列表的不同标示符(<code>-,+,*,1.,1)</code>). 当和数字前缀参数 N 一起
使用时,选择切换列表中第 N 个列表项. 如果使用时有区域被选中,那选中区域的
所有行会被转变成列表项.当和前缀参数一起使用,会将所有选中区域转变成一个
列表项.如果选中区域的第一行已经是列表项了,那就会删除第一行的标示符.最后,即
使没有选中,光标所在的普通行也会被转变为一个列表项.(普通行是不属于任何结
构的一行文本)</dd>
<dt><code>C-c *</code></dt><dd>将列表项转变成标题项.</dd>
<dt><code>C-c C-*</code></dt><dd>将整个列表转变成当前标题的子树. 复选框被转变成 <code>TODO</code> 和
<code>DOWN</code> 对应复选框未勾选和已勾选.</dd>
<dt><code>S-&lt;LEFT&gt; S-&lt;RIGHT&gt;</code></dt><dd>这个命令也是切换列表标示类型的. 和 <code>C-c -</code> 效果相
同.</dd>
<dt><code>C-c ^</code></dt><dd>对列表排序.提示输入排序方法,按数字,字母,时间或自定义方法.</dd>
</dl>
</div>
</div>


<div id="outline-container-org9fdee05" class="outline-3">
<h3 id="org9fdee05">抽屉 (Drawers)</h3>
<div class="outline-text-3" id="text-org9fdee05">
<ul class="org-ul">
<li>Note taken on <span class="timestamp-wrapper"><span class="timestamp">[2022-01-13 Thu 15:14] </span></span> <br />
快速记录一个带时间戳的笔记.</li>
</ul>
<blockquote>
<p>
把文本'藏'起来,当你想写一些与当前条目有关的信息,但通常不想看到这些信息时就可
以使用该功能.
</p>
</blockquote>
<p>
Drawers 能包括除了标题和另一个 drawer 之外的任何东西.例如:
</p>
<pre class="example">
** This is a headline
still outside the drawer
:DRAWERNAME:
This is inside the drawer.
:END:
After the drawer.
</pre>
<p>
通过命令 <code>org-insert-drawer</code> 或其绑定的快捷键 <code>C-c C-x d</code> 可以在当前光标位置插入
一个 drawer. 有选中区域时,这个命令会把整个区域都放到 drawer 内.加上前缀参数使
用,会变成调用 <code>org-insert-property-drawer</code> ,这个命令会在当前标题之下创建一个
<code>PROPERTIES</code> drawer 就是一个用来设置属性的 drawer.Org 用这种特殊的抽屉来存储属
性设置.抽屉关键词的补全可以使用 <code>M-&lt;TAB&gt;</code> 来提示,有的桌面环境将 <code>M-&lt;TAB&gt;</code> 设置为
切换窗口了,所以也可以用 <code>C-M-i</code> 或者 <code>&lt;ESC&gt; &lt;TAB&gt;</code> 来提示补全.
</p>

<p>
标题的折叠和展开不影响抽屉,抽屉总是会折叠成一行,除非当光标移动到抽屉那一行,再
使用 <code>&lt;TAB&gt;</code> 展开抽屉内容.
</p>

<p>
drawer 也可以用来记录状态变化的笔记和记录时间信息(<code>LOGBOOK</code> drawer).
</p>

<p>
如果想快速的记录一个笔记,有一个和记录状态信息类似的操作:
</p>
</div>

<div id="outline-container-org2384833" class="outline-4">
<h4 id="org2384833"><span class="todo TODO">TODO</span> <code>C-c C-z</code> 添加一个带时间戳的笔记到 <code>LOGBOOK</code> drawer. 写完这里,我执行了快捷键,在</h4>
<div class="outline-text-4" id="text-org2384833">
<p>
抽屉这一小结添加了一条带时间戳的笔记,虽然文档里写的是导出到 <code>LOGBOOK</code> 抽屉,但
是实际操作后发现笔记没有记录到 <code>LOGBOOK</code> 类型的抽屉里, <code>Clocking Work Time</code>
的记录才是,这里只是添加一个列表项,带有时间戳和笔记内容而已,当然,也可能是我
认知的抽屉和文档的意思有差错,等看到更多相关内容之后再来看这里吧.导出后可以看看是啥效果,没看到就是默认
不支持这类文本的导出了.
</p>
</div>
</div>
</div>



<div id="outline-container-org4d7064f" class="outline-3">
<h3 id="org4d7064f">块结构 (Blocks)</h3>
<div class="outline-text-3" id="text-org4d7064f">
<blockquote>
<p>
这部分讲可折叠的块结构.块结构可以用来容纳源代码,记录时间信息和其他许多功能.
</p>
</blockquote>
<p>
Org 用 <code>#+BEGIN ... #+END</code> 做源代码(<code>Literal Examples</code>),引用文本或时间记录
(<a href="#orgfd54c4c">计时工作时间(Clocking Work Time)</a>)等多种用途.当光标在 <code>#+BEGIN</code> 行时可以用
<code>&lt;TAB&gt;</code> 进行折叠.可以设置变量 <code>org-hide-block-startup</code> 来让块结构在一开始处于折
叠或展开状态.也可以在每个文件都设置 <code>#+STARTUP: hideblocks</code> 或 <code>#+STARTUP:
    nohideblocks</code> 来为每个文件设置块结构的初始折叠状态.文件里的设置是会覆盖变量设
置的.
</p>
</div>
</div>
</div>
<div id="outline-container-org97a26fc" class="outline-2">
<h2 id="org97a26fc"><span class="done DONE">DONE</span> 表格(Tables)</h2>
<div class="outline-text-2" id="text-org97a26fc">
<p>
Org 自带快速和直观的表格编辑器.电子表格程序类似的计算器功能通过使用 Emacs 的 Calc
</p>
<ul class="org-ul">
<li class="off"><code>[&#xa0;]</code> 包也是支持的(<code>GNU Emacs Calculator Manual</code>). 坑+1, 有空再看,感觉会很有用.</li>
</ul>
</div>

<div id="outline-container-org61f5998" class="outline-3">
<h3 id="org61f5998">内置表格编辑器(Built-in Table Editor)</h3>
<div class="outline-text-3" id="text-org61f5998">
<blockquote>
<p>
简单表格.
</p>
</blockquote>
<p>
Org 能很容易的格式化纯 ASCII 格式的表格.任何一行以 <code>|</code> 作为第一个非空字符的行都
被视作一个表格的一部分. <code>|</code> 也是列分隔符. 此外,一行以 <code>|-</code> 开始的行是一个水平分割
线. 它将显示分割表格的行.在第一个水平分割线之前的所有行都是标题行. 一个表格可
能长这样:
</p>
<pre class="example">
| Name  | Phone | Age |
|-------+-------+-----|
| Peter |  1234 |  17 |
| Anna  |  4321 |  25 |
</pre>

<p>
在表格内部,每一次按 <code>&lt;TAB&gt;</code>, <code>&lt;RET&gt;</code> 或者 <code>C-c C-c</code> ,这个表格都会自动地被重新对
齐. <code>&lt;TAB&gt;</code> 也会移动到下一个字段, <code>&lt;RET&gt;</code> 会移动到下一行,如果光标在表格的最后一行
或者在分割线之前的行,那就会同时创建一个新的表格行.整个表格的缩进由表格的第一
行决定.水平分割线在每次对齐时都会自动填充为整个表格的宽度.所以,为了创建上面例
子的表格,只需要输入:
</p>
<pre class="example">
| Name  | Phone | Age |
|-
</pre>
<p>
然后按 <code>&lt;TAB&gt;</code> 键调整表格,开始填表.更快的做法是键入 <code>|Name|Phone|Age</code> 然后按 <code>C-c
   &lt;RET&gt;</code>.
</p>

<p>
当输入文本到表格中时, Org 将 <code>DEL</code> , <code>Backspace</code> 和所有的字符键都区别对待,从而使
插入和删除操作不会影响到其他字段.此外,在键入 <code>&lt;TAB&gt;</code> , <code>S-&lt;TAB&gt;</code> 或 <code>&lt;RET&gt;</code> 后,光标
会立即移动到下一个的字段,这个字段将自动变为空白.如果这个行为对你来说太不可预
测,可以配置变量 <code>org-table-auto-blank-field</code> 来禁用这一行为,实际操作发现,当移动
到下一字段,并且其中有内容,内容并不会被立即清除,只有键入新的内容之后才会被消除.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">setq</span> org-table-auto-blank-field t)
</pre>
</div>
</div>

<div id="outline-container-orgd56982b" class="outline-4">
<h4 id="orgd56982b">创建和转化表格(Creation and conversion)</h4>
<div class="outline-text-4" id="text-orgd56982b">
<dl class="org-dl">
<dt><code>C-c |</code> &#x2013; <code>(org-table-create-or-convert-from-region)</code></dt><dd>将选中区域转化为表格.
如果每行都包含至少一个 <code>&lt;TAB&gt;</code> 字符,这个方法会假定表格是由制表符分隔的,如
果 每行都包含一个逗号(comma), 则假定是 CSV(comma-separated values) 格式的
数据 转化成表格.如果都不是,那么将会用空白符来做分隔符转化成表格.也可以使用
前缀 参数来强制指定分隔符: <code>C-u</code> 指定 CSV, <code>C-u C-u</code> 指定 <code>&lt;TAB&gt;</code>, <code>C-u
      C-u C-u</code> 请求输入正则表达式来匹配分隔符, 而使用数字参数 N 表明使用至少 N
个连续的空白作为 分隔符,如果没有找到符合条件的空格,则使用 <code>&lt;TAB&gt;</code> 作为分隔
符. 如果没有选中区域,这个命令会创建一个空的表格,但是像键入
<code>|Name|Phone|Age&lt;RET&gt;|-&lt;TAB&gt;</code> 或 <code>|Name|Phone|Age</code> 这种方法创建表格会更容
易.</dd>
</dl>
</div>
</div>


<div id="outline-container-org30a153c" class="outline-4">
<h4 id="org30a153c">重对齐和字段移动(re-align and field motion)</h4>
<div class="outline-text-4" id="text-org30a153c">
<dl class="org-dl">
<dt><code>C-c C-c</code> &#x2013; <code>(org-table-align)</code></dt><dd>重新排列表格,不移动光标.</dd>
<dt><code>&lt;TAB&gt;</code> &#x2013; <code>(org-table-next-field)</code></dt><dd>重排表格,并移动光标到下一字段,如果有必要
会创建新的一行.</dd>
<dt><code>C-c &lt;SPC&gt;</code>  &#x2013; <code>(org-table-blank-field)</code></dt><dd>将光标所在字段的内容变为空白.</dd>
<dt><code>S-&lt;TAB&gt;</code> &#x2013; <code>(org-table-previous-field)</code></dt><dd>重排表格,并移动光标到上一字段.</dd>
<dt><code>&lt;RET&gt;</code> &#x2013; <code>(org-table-next-row)</code></dt><dd>重排表格,并向下移动到下一行,如果有必要会
创建新的一行,在一行的最后或开头使用, <code>&lt;RET&gt;</code> 也会插入新的一行,所以也可以用来
分割表格.</dd>
<dt><code>M-a</code> &#x2013; <code>(org-table-beginning-of-field)</code></dt><dd>移动光标到当前表格字段的开头,或移
动光标到上一个字段.</dd>
<dt><code>M-e</code> &#x2013; <code>(org-table-end-of-field)</code></dt><dd>移动光标到当前表格字段的最后,或移动到下
一个字段.</dd>
</dl>
</div>
</div>



<div id="outline-container-orgac80628" class="outline-4">
<h4 id="orgac80628">编辑列和行(Column and row editing)</h4>
<div class="outline-text-4" id="text-orgac80628">
<dl class="org-dl">
<dt><code>M-&lt;LEFT&gt;</code> &#x2013; <code>(org-table-move-column-left)</code></dt><dd>将当前列左移.</dd>

<dt><code>M-&lt;RIGHT&gt;</code> &#x2013; <code>(org-table-move-column-right)</code></dt><dd>将当前列右移.</dd>

<dt><code>M-S-&lt;LEFT&gt;</code> &#x2013; <code>(org-table-delete-column)</code></dt><dd>删除当前列.</dd>

<dt><code>M-S-&lt;RIGHT&gt;</code> &#x2013; <code>(org-table-insert-column)</code></dt><dd>在光标当前位置插入新的一列,将
光标当前所在列右边的所有列都右移.就是在光标所在列的左边插入新的一列.</dd>

<dt><code>M-&lt;UP&gt;</code> &#x2013; <code>(org-table-move-row-up)</code></dt><dd>将光标所在行上移.</dd>

<dt><code>M-&lt;DOWN&gt;</code> &#x2013; <code>(org-table-move-row-down)</code></dt><dd>将光标所在行下移.</dd>

<dt><code>M-&lt;DOWN&gt;</code> &#x2013; <code>(org-table-move-row-down)</code></dt><dd>将光标所在行下移.</dd>

<dt><code>M-&lt;DOWN&gt;</code> &#x2013; <code>(org-table-move-row-down)</code></dt><dd>将光标所在行下移.</dd>

<dt><code>M-S-&lt;UP&gt;</code> &#x2013; <code>(org-table-kill-row)</code></dt><dd>删除当前行或水平分割线.</dd>

<dt><code>S-&lt;UP&gt;</code> &#x2013; <code>(org-table-move-cell-up)</code></dt><dd>将光标所在单元格与其相邻的上面一个单
元格交换位置.</dd>

<dt><code>S-&lt;DOWN&gt;</code> &#x2013; <code>(org-table-move-cell-down)</code></dt><dd>将光标所在单元格与其相邻的下面一
个单元格交换位置.</dd>

<dt><code>S-&lt;LEFT&gt;</code> &#x2013; <code>(org-table-move-cell-left)</code></dt><dd>将光标所在单元格与其相邻的左边的
一个单元格交换位置.</dd>

<dt><code>S-&lt;RIGHT&gt;</code> &#x2013; <code>(org-table-move-cell-right)</code></dt><dd>将光标所在单元格与其相邻的右边
一个单元格交换位置.</dd>

<dt><code>M-S-&lt;DOWN&gt;</code> &#x2013; <code>(org-table-insert-row)</code></dt><dd>在光标所在行的上面插入新的一行,如
果和前缀参数一起使用,就会在当前行的下一行插入新的一行.</dd>

<dt><code>C-c -</code> &#x2013; <code>(org-table-insert-hline)</code></dt><dd>在当前行的下一行插入水平分割线,加上前
缀参数一起使用,就会在当前行的上一行插入.</dd>

<dt><code>C-c &lt;RET&gt;</code> &#x2013; <code>(org-table-hline-and-move)</code></dt><dd>再当前行的下一行插入水平分割线,
并且移动光标到水平分割线的下一行.</dd>

<dt><code>C-c ^</code> &#x2013; <code>(org-table-sort-lines)</code></dt><dd>根据光标所在列对表格的行进行排序.光标所
在的列标示要用来排序的列,排序的范围为两个最近的分割线之间或者整个表格的行.如
果光标在第一列之前,会提示输入用来排序的列.如果有选中区域,选中标记指定第一
行和用来排序的列,而光标应该在最后一行需要进行排序操作的行.这个命令会提示输
入排序类型,按字母, 数字或时间进行排序.可以用正向或反向排序.也可以用自己提
供的排序关键字提取和比较的方法. 和前缀参数一起使用时,按字母排序是区分大小
写的.</dd>
</dl>
</div>
</div>


<div id="outline-container-orgf373f3d" class="outline-4">
<h4 id="orgf373f3d">区域操作(Regions)</h4>
<div class="outline-text-4" id="text-orgf373f3d">
<dl class="org-dl">
<dt><code>C-c C-x M-w</code> &#x2013; <code>(org-table-copy-region)</code></dt><dd>将表格的"矩形区域"选区复制到特殊的剪贴
板.如果没有选中区域,只复制当前单元格内的字段.这个操作无视水平分割线.</dd>

<dt><code>C-c C-x C-w</code> &#x2013; <code>(org-table-cut-region)</code></dt><dd>将表格的矩形区域复制到特殊的剪贴
板,并将区域中的字段清空.所以叫"剪切"操作.</dd>

<dt><code>C-c C-x C-y</code> &#x2013; <code>(org-table-paste-rectangle)</code></dt><dd>将矩形区域粘贴到表格中.矩形
区域的左上角在光标所在位置的字段内,所有包含在矩形区域的字段会被覆盖.如果矩
形区域和表格剩下的区域不合适,那表格会根据需要自动扩大.这个过程无视水平分割
线.</dd>

<dt><code>M-&lt;RET&gt;</code> &#x2013; <code>(org-table-wrap-region)</code></dt><dd>将表格从当前字段所在行分割.如果有选
中区域,而且光标和标记在同一列,那表格以选中区域的行数为最小宽度做分割.和数
字前缀参数一起使用可以指定最小分割宽度.如果没有选区,又使用了前缀参数,那当
前字段会被清除,其字段内容会被加到上边的字段里去.</dd>
</dl>
</div>
</div>

<div id="outline-container-org77ed1fb" class="outline-4">
<h4 id="org77ed1fb">计算(Calculations)</h4>
<div class="outline-text-4" id="text-org77ed1fb">
<dl class="org-dl">
<dt><code>C-c +</code> &#x2013; <code>(org-table-sum)</code></dt><dd>将当前列或有选区定义的矩形区域的数字求和.求和
结果会在显示区域(echo area) 显示并且可以通过 <code>C-y</code> 粘贴.</dd>

<dt><code>S-&lt;RET&gt;</code> &#x2013; <code>(org-table-copy-down)</code></dt><dd>当前字段为空时,复制其上第一个非空字段
的值.当前字段非空时,将当前字段内容复制到下一行的同列字段,并将光标一并移动.基
于变量 <code>org-table-copy-increment</code> 的值,整数和时间戳字段,有数字前缀或后缀的字
段,会在复制过程中进行自增操作.此外,数字前缀参数 <code>0</code> 会暂时禁用自增操作.这个
快捷键同样会被移动选择(shift-selection) 和相关模式使用,具体见 <code>Conflicts</code>.</dd>
</dl>
</div>
</div>

<div id="outline-container-orgd007e61" class="outline-4">
<h4 id="orgd007e61">杂项(Miscellaneous)</h4>
<div class="outline-text-4" id="text-orgd007e61">
<dl class="org-dl">
<dt><code>C-c `</code> &#x2013; <code>(org-table-edit-field)</code></dt><dd>打开一个独立窗口来编辑当前字段.这在字段
不是完全可见时很有用(见下节的 Column Width and Alignment). 当与前缀参数
<code>C-u</code> 一起使用,只会使字段完全可见. 当和 <code>C-u C-u</code> 一起使用,会使编辑器窗口一直
保持一个编辑当前字段的窗口.这个窗口在光标离开表格区域或者再次使用命令
<code>C-u C-u C-c `</code> 时自动消失.</dd>

<dt><code>M-x org-table-import</code></dt><dd>将文件导入成表格. 表格应该用制表符 <code>&lt;TAB&gt;</code> 或空白符
隔开.用法:可以从电子表格软件的表格或数据库中导入数据成表格,因为这些程序可
以导出制表符分隔的文本文件.这个命令也可以通过插入文件到缓冲区然后将区域转
换成表格时使用. 任何的前缀参数都会被传递给转换器,转换器用来决定分隔符.</dd>

<dt><code>C-c |</code> &#x2013; <code>(org-table-create-or-convert-from-region)</code></dt><dd>表格也可以用另一个方
式导入:复制表格式的文本到 Org 缓冲区,选择表格式文本区域,然后用 <code>C-c |</code> 命令
(详情见 <a href="#orgd56982b">创建和转化表格(Creation and conversion)</a>).</dd>

<dt><code>M-x org-table-export</code></dt><dd>导出表格,默认导出为制表符分隔的文件.用来进行数据交
换,例如和电子表格程序或数据库程序进行数据交换.导出文件的格式可以通过配置
<code>org-table-export-default-format</code> 变量改变.也可以在子树中使用
<code>TABLE_EXPORT_FILE</code> 和 <code>TABLE_EXPORT_FORMAT</code> 属性来指定文件名和文件格式.Org 支
持导出表格到十分常见的格式.导出格式和 Orgtbl radio 表格使用的格式一致.更多
细节查看 <code>Translator functions</code> .TODO</dd>

<dt><code>M-x org-table-header-line-mode</code></dt><dd>当缓冲区中的表格的第一行不可见时,显示表
格的第一行数据,(效果待测). 可以将变量 <code>org-table-header-line-p</code> 设置为 <code>t</code>, 表
示默认开启这个副模式.</dd>

<dt><code>M-x org-table-transpose-table-at-point</code></dt><dd>颠倒表格(类似矩阵转置),并消除水
平分割线.</dd>

<dt class="off"><code>[&#xa0;]</code> 垂直线</dt><dd>往表格字段里插入垂直分割线,用 <code>\vert</code> 或在文本中间使用 <code>abc\vert{}def</code>.</dd>
</dl>
</div>
</div>
</div>


<div id="outline-container-orga9708f1" class="outline-3">
<h3 id="orga9708f1">列宽和对齐(Column Width and Alignment)</h3>
<div class="outline-text-3" id="text-orga9708f1">
<blockquote>
<p>
否定自动设置.
</p>
</blockquote>

<p>
表格的列宽是由表格编辑器自动决定的.列的对齐方式是由字段中数字类型和非数字类型
字段的决定的.
</p>

<p>
编辑字段内容可能会改变表格的对齐方式.移动连续的行或列(例如使用 <code>&lt;TAB&gt;</code> 或
<code>&lt;RET&gt;</code>) 会自动重新对齐表格.如果像禁用这一行为,可以将变量
<code>org-table-automatic-realign</code> 设置为 <code>nil</code>. 无论如何,总是可以通过 <code>C-c C-c</code> 快捷键
或命令 <code>(org-table-align)</code> 来手动对齐表格.
</p>

<p>
通过设置变量 <code>org-start-align-all-tables</code> 可以在打开文件时重新对齐文件中的表格.同
时也可以在每个文件中使用这两个选项来实现这一功能:
</p>
<pre class="example">
#+STARTUP: align
#+STARTUP: noalign
</pre>

<p>
有时候一个字段或几个字段需要包含比其他字段更多的文本,导致了很不方便的宽列.这
时候你可能想要隐藏一些行或将他们以固定宽度展示,忽视字段的内容,就像下面的例子:
</p>
<pre class="example">
|---+---------------------+--------|           |---+-------…+…|
|   | &lt;6&gt;                 |        |           |   | &lt;6&gt;   …|…|
| 1 | one                 | some   |   ----\   | 1 | one   …|…|
| 2 | two                 | boring |   ----/   | 2 | two   …|…|
| 3 | This is a long text | column |           | 3 | This i…|…|
|---+---------------------+--------|           |---+-------…+…|
</pre>

<p>
要设置列宽,可以在列的任何一个字段中键入字符串 <code>&lt;N&gt;</code> ,N 指定了宽度的字符个数.可
以用下面的命令控制列宽的显示:
</p>

<dl class="org-dl">
<dt><code>C-c &lt;TAB&gt;</code> &#x2013; <code>(org-table-toggle-column-width)</code></dt><dd>收缩或展开当前列. 如果指定
了列宽 W, 列会收缩到展示前 W 个可见字符,没指定,列会收缩到单个字符宽度.如果
在第一列之前或最后一列之后调用该命令,则会提示输入命令作用的列的范围(如:2-3)</dd>

<dt><code>C-u C-c &lt;TAB&gt;</code> &#x2013; <code>(org-table-shrink)</code></dt><dd>收缩所有设置了列宽的列,展开其他列.</dd>

<dt><code>C-u C-u C-c &lt;TAB&gt;</code> &#x2013; <code>(org-table-expand)</code></dt><dd>展开所有列.</dd>
</dl>

<p>
要像查看收缩字段的完整文本,可以将鼠标放在字段位置上,一个提示窗口会显示字段的
完整内容.或者,也可以使用 <code>C-h .</code> &#x2013; <code>(display-local-help)</code> 命令或快捷键来展现他们.为
了方便起见,任何在列的收缩部分的更改会自动将列展开.
</p>

<p>
设置选项 <code>org-startup-shrink-all-tables</code> 会在第一次打开文件时收缩所有设置了列宽
的列.同时也可以在每个文件设置选项: <code>#+STARTUP:shrink</code> 得到相同效果.
</p>

<p>
如果想要更改数字丰富列右对齐和文本丰富列左对齐的自动对齐设置.可以用类似的方式
使用 <code>&lt;r&gt;</code>, <code>&lt;c&gt;</code> 或 <code>&lt;l&gt;</code> 来指定对齐方式.同时也可以将对齐和列宽设置结合: <code>&lt;r10&gt;</code>.
</p>

<p>
只包含这些格式 <code>cookies</code> 的行会在导出到文本时被自动删除.
</p>

<p>
字段包含cookie 之外的文本的表格导出结果:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">&lt;6&gt;这一行包含格式cookie 之外的文本</td>
<td class="org-left">&lt;1&gt;</td>
</tr>

<tr>
<td class="org-right">9</td>
<td class="org-left">one</td>
<td class="org-left">some</td>
</tr>

<tr>
<td class="org-right">10</td>
<td class="org-left">two</td>
<td class="org-left">boring</td>
</tr>

<tr>
<td class="org-right">11</td>
<td class="org-left">Eg:This is a long text</td>
<td class="org-left">ccolumn</td>
</tr>
</tbody>
</table>

<p>
字段不包含cookie 之外的文本的表格导出结果:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-right">9</td>
<td class="org-left">one</td>
<td class="org-left">some</td>
</tr>

<tr>
<td class="org-right">10</td>
<td class="org-left">two</td>
<td class="org-left">boring</td>
</tr>

<tr>
<td class="org-right">11</td>
<td class="org-left">Eg:This is a long text</td>
<td class="org-left">ccolumn</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgaeacd64" class="outline-3">
<h3 id="orgaeacd64">列组(Column Groups)</h3>
<div class="outline-text-3" id="text-orgaeacd64">
<blockquote>
<p>
分组以触发(生成)竖线
</p>
</blockquote>
<p>
当Org 导出表格时,默认不使用竖直线,因为一般来讲,这在视觉上更令人满意.然而,竖直
线偶尔也很有用,可以用来将表格的列分组,就像水平分割线把行分组一样.为了指定列组,可
以使用特殊的一行,该行第一个字段只包含 <code>/</code>.更多的字段可以包含 <code>&lt;</code> 来表明此列是一个
组的开始, <code>&gt;</code> 表明此列是一个组的结束,或者是 <code>&lt;&gt;</code> (两个括号中间没有空格) 来表示这
一列就是单独的一个组.在导出时,列组之间的边界会用垂直线标记.下面是一个例子:
</p>
<pre class="example">

| N | N^2 | N^3 | N^4 | sqrt(n) | sqrt[4](N) |
|---+-----+-----+-----+---------+------------|
| / |  &lt;  |     |  &gt;  |       &lt; |          &gt; |
| 1 |  1  |  1  |  1  |       1 |          1 |
| 2 |  4  |  8  | 16  |  1.4142 |     1.1892 |
| 3 |  9  | 27  | 81  |  1.7321 |     1.3161 |
|---+-----+-----+-----+---------+------------|
#+TBLFM: $2=$1^2::$3=$1^3::$4=$1^4::$5=sqrt($1)::$6=sqrt(sqrt(($1)))
</pre>
<p>
导出的结果:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />
</colgroup>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">N</th>
<th scope="col" class="org-right">N^2</th>
<th scope="col" class="org-right">N^3</th>
<th scope="col" class="org-right">N^4</th>
<th scope="col" class="org-right">sqrt(n)</th>
<th scope="col" class="org-right">sqrt[4](N)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">4</td>
<td class="org-right">8</td>
<td class="org-right">16</td>
<td class="org-right">1.4142</td>
<td class="org-right">1.1892</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">9</td>
<td class="org-right">27</td>
<td class="org-right">81</td>
<td class="org-right">1.7321</td>
<td class="org-right">1.3161</td>
</tr>
</tbody>
</table>
<blockquote>
<p>
如果发现每个列之间都有竖直线隔开,很可能就是因为导出时并不是使用了默认的导出
设置,额外添加了样式设置.但默认的导出到html <code>C-c C-e h o</code> 是使用默认设置的.
</p>
</blockquote>
<p>
事实上,只使用列组的开始标记 <code>&lt;</code> 也足以标记列组了:
</p>

<pre class="example">
| N | N^2 | N^3 | N^4 | sqrt(n) | sqrt[4](N) |
|---+-----+-----+-----+---------+------------|
| / | &lt;   |     |     | &lt;       |            |
</pre>
<p>
只使用 <code>&lt;</code> 标记:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />
</colgroup>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">N</th>
<th scope="col" class="org-right">N^2</th>
<th scope="col" class="org-right">N^3</th>
<th scope="col" class="org-right">N^4</th>
<th scope="col" class="org-right">sqrt(n)</th>
<th scope="col" class="org-right">sqrt[4](N)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">4</td>
<td class="org-right">8</td>
<td class="org-right">16</td>
<td class="org-right">1.4142136</td>
<td class="org-right">1.1892071</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">9</td>
<td class="org-right">27</td>
<td class="org-right">81</td>
<td class="org-right">1.7320508</td>
<td class="org-right">1.3160740</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org44f1faa" class="outline-3">
<h3 id="org44f1faa">Orgtbl Mode</h3>
<div class="outline-text-3" id="text-org44f1faa">
<blockquote>
<p>
将表格编辑器设置为副模式
</p>
</blockquote>
<p>
如果喜欢Org 表格编辑器的直观的工作方式,你可能也想在其他的文本模式或者邮件模式
中使用它.副模式 <code>orgtbl-mode</code> 能做到这一点.你始终可以用 <code>M-x orgtbl-mode</code> 开关这
一模式.想要它默认打开,例如在 <code>Message</code> 模式中默认打开,可以使用:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-hook 'message-mode-hook 'turn-on-orgtbl)
</pre>
</div>
<p>
此外,通过一些特别的设置,可以使用Orgtbl 模式维护任意语法格式的表格.例如,可以使
用Orgtbl 模式的基础易用性和强大功能来构建LaTex 表格,包括电子表格功能.详情参考
<code>Tables in Arbitrary Syntax</code> 一节 TODO.
</p>
</div>
</div>

<div id="outline-container-orgf6845f0" class="outline-3">
<h3 id="orgf6845f0">电子表格(The Spreadsheet)</h3>
<div class="outline-text-3" id="text-orgf6845f0">
<blockquote>
<p>
Org 表格编辑器有电子表格程序的功能
</p>
</blockquote>
<p>
表格编辑器利用Emacs的Calc包来实现类似电子表格程序的功能.编辑器可以计算Emacs
Lisp 公式,以从其他字段派生字段.尽管功能齐全,但是Org功能的实现和其他电子表格程
序不同.例如,Org 有 <code>列公式</code> 的概念,该公式可以应用于列中的所有非标题字段,而不需
要将公式复制到每个相关字段.还有一个公式调试器和公式编辑器,该编辑器有高亮表中
与公式中引用相关的字段的特性,可以通过方向键移动这些引用.
</p>
</div>
<div id="outline-container-orgd54f2ea" class="outline-4">
<h4 id="orgd54f2ea">引用(Reference)</h4>
<div class="outline-text-4" id="text-orgd54f2ea">
<blockquote>
<p>
如何引用另一个字段或范围.
</p>
</blockquote>
<p>
要从表中其他字段计算字段,公式必须引用其他字段或字段范围.在Org中,字段可以通过
名字,绝对座标,和相对座标引用.要找出字段的座标是什么,当光标位于该字段时,按
<code>C-c ?</code> 或者是按 <code>C-c }</code> 切换显示网格.
</p>
</div>

<ul class="org-ul">
<li><a id="org5c09920"></a>字段引用(Field references)<br />
<div class="outline-text-5" id="text-org5c09920">
<p>
公式可以用两种方式引用其他字段中的值.和其他电子表格程序一样,你可以使用字母
和数字的组合像 <code>B3</code> 这样来引用字段,意思是第三行的第二个字段.然而,Org 更倾向使
用另一种更为通用的表示形式,像下面这样:
</p>
<pre class="example">
@ROW$COLUMN
</pre>
<blockquote>
<p>
Org 能理解 <code>B4</code> 的引用类型,但是它并不用这种语法来编辑表格.你可以通过配置变量
<code>org-table-use-standard-references</code> 来支持这种语法编辑表格.
</p>
</blockquote>

<p>
列的指定可以使用绝对定位例如 <code>$1</code>, <code>$2</code>, &#x2026;, <code>$N</code> 或是相对当前列的定位,也就是要
计算的字段所在的列,例如 <code>$+1</code> 或 <code>$-2</code>. <code>$&lt;</code> 和 <code>$&gt;</code> 分别是第一列和最后一列的固定引
用,你也可以使用 <code>$&gt;&gt;&gt;</code> 来指示右侧的第三列.
</p>

<p>
行的指定只从数据行开始计算,并且忽视水平分割线(或 <code>hlines</code>). 和列一样,也可以使
用绝对行数 <code>@1</code>, <code>@2</code> , &#x2026;, <code>@N</code> 和相对当前行的相对定位 <code>@+3</code>, <code>@-1</code>. <code>@&lt;</code> 和 <code>@&gt;</code> 分别
是第一行和最后一行的固定引用.你也可以指定相对于一个水平分割线的行: <code>@I</code> 引用
第一个水平分割线, <code>@II</code> 引用第二个水平分割线,等等. <code>@-I</code> 指的是当前行之上的第一
个水平分割线, <code>@+I</code> 指的是当前行之下的水平分割线.你也可以用 <code>@III+2</code> 来指定第三
个水平分割线之后的第二个数据行.
</p>

<p>
<code>@0</code> 和 <code>$0</code> 分别指的是当前的行和列.也就是要计算的字段的行/列.还有,如果你省略了
引用中行/列的部分,则默认使用当前的行/列.
</p>

<p>
Org 的无符号数字引用是固定引用,即如果在公式中对两个不同的字段使用相同的引用,则
每次引用相同的字段. Org 的有符号数字引用是不固定引用,因为相同的引用操作会根
据公式中正被计算的字段变化.这有一些例子:
</p>
<ul class="org-ul">
<li><code>@2$3</code> : 第2行第3列(<code>C2</code>).</li>
<li><code>$5</code> : 当前行第5列(<code>E&amp;</code>).</li>
<li><code>@2</code> : 当前列第2行.</li>
<li><code>@-1$-3</code> : 向上1行,向左3列的字段.</li>
<li><code>@-I$2</code> : 第2列,向上第一个分割线之下的第一行的字段.</li>
<li><code>@&gt;$5</code> : 最后一行,第5列的字段.</li>
</ul>
</div>
</li>


<li><a id="orgebff098"></a>范围引用(Range references)<br />
<div class="outline-text-5" id="text-orgebff098">
<p>
你可以通过指定两个用点 <code>..</code> 连接的字段引用来引用一个字段的矩形区域. 结束的字
段包含在引用范围之内. 如果两个字段都在当前行,你可以简单的使用 <code>$2..$7</code> ,但如
果至少有一个字段在不同行,你至少需要在第一个字段使用通用的 <code>@ROW$COLUMN</code> 格式,
也就是说引用必须以 <code>@</code> 开始以便能被正确理解.例子:
</p>

<ul class="org-ul">
<li><code>$1..$3</code> : 当前行的第1到第3列字段.</li>
<li><code>$P..$Q</code> : 使用列名的引用(查看高级特性 <code>Advanced features</code> 一节)</li>
<li><code>$&lt;&lt;&lt;..$&gt;&gt;</code> :从第3列开始,一直到最后一列.</li>
<li><code>@2$1..@4$3</code> :位于两个字段之间的九个字段(<code>A2..C4</code>)</li>
<li><code>@-1$-2..@-1</code> :从左边2列开始,到当前行之上的三个字段,</li>
<li><code>@I..II</code> : 第一和第二个水平分割线之间的字段, <code>@I..@II</code> 的简写.</li>
</ul>

<p>
范围引用返回值的向量,这个向量可以输入到 Calc 的向量函数.范围中的空字段通常
会被删除,所以向量中只包含非空字段.至于其他的模式开关 <code>E</code> , <code>N</code> 和示例的选项,参
见 <a href="#org611ac6a">Calc 的公式语法(Formula syntax for Calc)</a>.也就是下一节.
</p>
</div>
</li>


<li><a id="org4f7d088"></a>公式中的字段座标(Field coordinates in formulas)<br />
<div class="outline-text-5" id="text-org4f7d088">
<p>
Calc 公式和 Lisp 公式在计算中的第一个行为是用当前计算结果要填充的字段的行或
列号替换公式中的 <code>@#</code> 和 <code>$#</code>.传统的 Lisp 公式结果是 <code>org-table-current-dline</code> 和
<code>org-table-current-column</code> 的,查看这两个方法的文档来获取详细信息.例子:
</p>

<dl class="org-dl">
<dt><code>if(@# % 2, $#, string(""))</code></dt><dd>在基数行插入列号,将偶数行字段设置为空.</dd>

<dt><code>$2 = '(identity remote(FOO, @@#$1))</code></dt><dd>将表格FOO 中每一行的第一列的文
本或值复制到当前表格的第二列中.</dd>

<dt><code>@3 = 2 * remote(FOO, @1$$#)</code></dt><dd>将表格FOO 中的第一行中的每一列的值的两
倍插入到当前表格的第三行.</dd>
</dl>

<p>
对于第二和第三个例子,表格 FOO 必须至少有和当前表格一样多的行或列.注意:这对大
量的行来说是无效的.因为表格FOO被解析为每个要被复制的字段,所以计算时间规模是
<code>O(N^2)</code>.<a href="https://www.gnu.org/software/emacs/manual/html_mono/org.html#References">info:org#References</a> 这里的翻译可能有问题,所以留下原手册链接.
</p>
</div>
</li>


<li><a id="org8370457"></a>名称引用(Named references)<br />
<div class="outline-text-5" id="text-org8370457">
<p>
<code>$name</code> 被解释为列,参数或常量的名字. 常量通过变量 <code>org-table-formula-constants</code>
全局范围内定义,通过这样一行在本地或文件范围内定义:
</p>
<pre class="example">
#+CONSTANTS: c=299792458. pi=3.14 eps=2.4e-6
</pre>
<p>
此外,属性也可以在表格里用作常量: 属性 <code>Xyz</code> 可以用 <code>$PROP_Xyz</code> 作为名称引用,属
性值会在当前大纲项目和其层级之上的项目中搜索. 如果你使用了 <code>constants.el</code> 包,
这个包也会用来处理常量,包括像普朗克常量 <code>$h</code> 这样的自然常量,像千米 <code>$km</code> 这样的
单位.这些都在下面的 高级特性里描述(<a href="#org4ba437a">高级功能(Advanced features)</a>) . 所有的名称都必须以字
母开始,剩下的由字母和数字组成.
</p>

<p>
文件 <code>constants.el</code> 能够用两种单位系统支持常量的值: <code>SI</code> 和 <code>cgs</code>. 使用哪一个单位
系统取决于变量 <code>constants-unit-system</code> 的值.你也可以用 <code>STARTUP</code> 选项 <code>constSI</code>
和 <code>constcgs</code> 来设置当前缓冲区中的这个值.
</p>
</div>
</li>

<li><a id="orgfdd62b1"></a>外部引用(Remote references)<br />
<div class="outline-text-5" id="text-orgfdd62b1">
<p>
你可以从当前文件甚至是从其他文件的不同的表格中引用常量,字段和范围.语法是:
</p>
<pre class="example">
remote(NAME,REF)
</pre>
<p>
<code>NAME</code> 可以是当前文件里,在表格之前的行中 <code>#+NAME:</code> 这样的行里设置的表格名,也可
以是一个条目的 <code>ID</code> ,即使是在不同的文件中,引用会指向该条目中的第一个表格.
<code>REF</code> 是一个像上面描述的绝对定位的字段或范围引用: <code>@3$3</code> 或 <code>$somename</code> 在引用的
表中有效的的表示.
</p>

<p>
当 <code>NAME</code> 有 <code>@ROW$COLUMN</code> 的格式时,这部分会被替换成当前表格的这个字段的名字或
ID. 例如 <code>remote($1, @@&gt;$2)</code> ⇒ <code>remote(year_2013, @@&gt;$1)</code>. <code>B3</code> 这种格式不被支持,
因为这种格式不能与一个表的名字或ID 区分开.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org611ac6a" class="outline-4">
<h4 id="org611ac6a">Calc 的公式语法(Formula syntax for Calc)</h4>
<div class="outline-text-4" id="text-org611ac6a">
<blockquote>
<p>
用 <code>Calc</code> 来进行计算.
</p>
</blockquote>
<p>
一个公式可以是任何Emacs Calc 包理解的代数表达式. 注意 Calc 的 <code>/</code> 操作符有着非
标准的约定: <code>/</code> 的优先级低于 <code>*</code>, 所以 <code>a/b*c</code> 会被解释成 <code>(a/(b*c))</code>. 在 <code>calc-eval</code>
(Calling Calc from Your Lisp Programs(calc)TODO)执行的计算之前,变量会根据上面描
述的规则进行替换.
</p>

<p>
范围向量会直接输入到 Calc 的向量函数,比如 <code>vmean</code> 和 <code>vsum</code>.
</p>

<p>
一个公式可以在一个分号之后包含可选的模式字符串.这个字符串由在执行期间影响
Calc 和其他模式的标签组成.默认情况下,Org 使用标准的 Calc 模式(精度12,角单位
度,分数和符号模式关闭).然而,为了保持表格紧凑,显示的格式被改变成了 <code>(float
    8)</code>.默认的设置可以通过变量 <code>org-calc-default-modes</code> 配置.
模式字符串:
</p>

<dl class="org-dl">
<dt><code>p20</code></dt><dd>将 Calc 内部的计算精度设置为20位.</dd>

<dt><code>n3, s3, e2 , f4</code></dt><dd>Calc 传递回 Org 的结果的格式:普通,科学,工程或固定格
式.只要Calc 计算的精度够大,Calc 的格式在精度上是无限的.</dd>

<dt><code>D, R</code></dt><dd>Calc 的角度或弧度模式.</dd>

<dt><code>F, S</code></dt><dd>Calc 的小数和符号模式.</dd>

<dt><code>T, t, U</code></dt><dd>Calc 或 Lisp 的持续时间计算, 查看 <a href="#org755a10a">持续时间和时间值(Durations and time values)</a>.</dd>

<dt><code>E</code></dt><dd>如何处理空字段.没有 <code>E</code> ,范围引用中的空字段会被删除,以便 Calc 向量或
Lisp 列表只包含非空字段.带上 <code>E</code> ,空字段会被保留.对于范围引用中的空字段或
者空的字段引用,值 <code>nan</code> (不是数字) 被用在 Calc 公式里, 空字符串被用在 Lisp
公式里.如果添加了 <code>N</code> 模式字符串,会在两种公式里使用数字 0.因为对于字段值,模式 <code>N</code> 比 <code>E</code>
有比模式 <code>E</code> 更高的优先级.</dd>

<dt><code>N</code></dt><dd>将所有的字段视为数字处理,对非数字视为 <code>0</code>.查看下一节来看看这在Lisp公
式里对计算有多重要.在 Calc 公式里,这个模式只是偶尔使用,因为即使没有 <code>N</code>,数
字字符串已经被解释为数字了</dd>

<dt><code>L</code></dt><dd>Literal, 只针对Lisp 公式,查看下一节 <a href="#orgf469264">Lisp 的公式语法(Formula syntax for Lisp)</a>.</dd>
</dl>

<p>
除非你要用很大的整数或高精度的计算而且要展示浮点数,你可能选择性的需要使用
<code>printf</code> 格式化指示符来重新格式化 Calcd 的传递回 Org 的计算结果,而不是让
Calc 进行格式化的工作. <code>printf</code> 重新格式化被限制在精度方面,因为传递给它的值
被转换成了整数或双精度浮点数.整数的大小通过截断有符号数到32位来限制,双精度
浮点数的精度被限制为64位,这大概保留了16位有效的十进制数.
</p>

<p>
一些例子:
</p>
<ul class="org-ul">
<li><code>$1+$2</code> : 将第一和第二个字段相加.</li>
<li><code>$1+$2;%.2f</code> : 和上面结果相同,但将结果格式化到两位十进制数.</li>
<li><code>exp($2)+exp($1)</code> : 数学函数也能使用.</li>
<li><code>$0;%.1f</code> : 重新格式化当前单元格到一位数.</li>
<li><code>($3-32)*5/9</code> : 温度华氏度到摄氏度的转换.</li>
<li><code>$c/$1/$cm</code> : Hz → cm 转换,使用了 <code>constants.el</code> 包.</li>
<li><code>tan($1);Dp3s1</code> : 计算角度,精度3,科学表示精度1.</li>
<li><code>sin($1);Dp3%.1e</code> : 和上面类似,但是用 <code>printf</code> 说明符指定显示格式.</li>
<li><code>vmean($2..$7)</code> : 用向量函数计算列范围的中值.</li>
<li><code>vmean($2..$7);EN</code> : 和上面类似,但是将空字段视为0.</li>
<li><code>taylor($3,x=7,2)</code> : 第三列的当x=7, 级数为2的泰勒级数.</li>
</ul>


<p>
Calc 页包含一套完整的逻辑操作.例如:
</p>

<dl class="org-dl">
<dt><code>if($1 &lt; 20, teen, string(""))</code></dt><dd>如果年龄 <code>$1</code> 小于 20,设置为 <code>teen</code>, 否则
Org 表格结果字段被设置为空字符串.</dd>
<dt><code>if("$1" == "nan" || "$2" == "nan", string(""), $1 + $2); E f-1</code></dt><dd>将前两列
相加. 如果至少有一个字段是空字段,Org 表格的结果字段会被设置为空. <code>E</code> 是为
了不将空字段转换为0而需要的. <code>f-1</code> 是Calc 的可选格式字符串,类似与 <code>%.1f</code> 但
是保留空结果为空.</dd>
<dt><code>if(typeof(vmean($1..$7)) == 12, string(""), vmean($1..$7); E</code></dt><dd>除非有任
何空字段,不然返回范围的中值. 范围中的每个空字段被 <code>nan</code> 替换,会使 <code>vmean</code> 的
结果为 <code>nan</code> .然后 <code>typeof() == 12</code> 是为了从 <code>vmean</code> 结果检测 <code>nan</code> 值.如果检测
到空值,表格的结果字段被设置为空.当样本集预计不存在缺失值时用这个例子.</dd>
</dl>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(calc-eval <span style="font-style: italic;">"typeof(nan)"</span>)
</pre>
</div>
<dl class="org-dl">
<dt><code>if("$1..$7" == "[]", string(""), vmean($1..$7))</code></dt><dd>跳过空字段的范围的中值.在
范围内的每个空字段都会被跳过.当范围内所有字段都是空值时,中值是未定义的,Org
表格的结果字段也会被设置为空值.当样本集可以有一个可变的大小时使用.</dd>
<dt><code>vmean($1..$7); EN</code></dt><dd>完成之前的例子:范围的中值,将空字段按值0计数.当需要用
0填充不完全的样本集时使用这种.</dd>
</dl>

<p>
你可以用 Emacs Lisp 的 <code>defmath</code> 定义 Calc 函数,并将他们应用在Calc 的公式语法
中.
</p>
</div>
</div>

<div id="outline-container-orgf469264" class="outline-4">
<h4 id="orgf469264">Lisp 的公式语法(Formula syntax for Lisp)</h4>
<div class="outline-text-4" id="text-orgf469264">
<blockquote>
<p>
用 Emacs Lisp 写公式.
</p>
</blockquote>
<p>
用 Emacs Lisp 写公式也是可以的.如果 Calc 的功能不够的话,这在字符串操作和控制
结构时很有用.
</p>

<p>
如果一个公式由单引号加开括号开始(<code>'(</code>),这个公式被当作 Lisp 公式计算.计算结果会
返回字符串或数字.和 Calc 公式一样,你可以指定模式并在分号后使用 <code>printf</code> 格式化.
</p>

<p>
使用Emacs Lisp 公式,你需要了解字段插入到公式的方式.默认情况下,一个引用是作为
一个包含字段的Lisp 字符串被插入(用双引号包裹).如果使用了 <code>N</code> 模式开关,所有没有
数字的数字字段会被作为Lisp 数字0插入到公式(没有引号).如果使用了 <code>L</code> 标签,所有
字段会被不加引号地逐字插入.例如,如果你想要一个引用被Lisp 公式解释为字符串,将
引用操作符包裹在双引号中(<code>"$3"</code>).范围是作为空格分隔的字段被插入的,所以你可以将
他们嵌入到列表或向量语法中.
</p>

<p>
这里有一些当我们使用 <code>N</code> 模式的Lisp 计算的例子:
</p>
<dl class="org-dl">
<dt><code>'(concat (substring $1 1 2) (substring $1 0 1) (substring $1 2))</code></dt><dd>交换第
一行文本的前两个字符.</dd>

<dt><code>'(+ $1 $2);N</code></dt><dd>将第一和第二列相加,相当于 Calc 的 <code>$1+$2</code>.</dd>

<dt><code>'(apply '+ '($1..$4));N</code></dt><dd>计算第一到第四列的求和,就像Calc 的 <code>vsum($1..$4)</code></dd>
</dl>
</div>
</div>

<div id="outline-container-org755a10a" class="outline-4">
<h4 id="org755a10a">持续时间和时间值(Durations and time values)</h4>
<div class="outline-text-4" id="text-org755a10a">
<blockquote>
<p>
如何计算持续时间和时间值.
</p>
</blockquote>
<p>
如果你想在Calc 公式或 Elisp 公式里计算时间值,使用 <code>T</code> , <code>t</code> 或 <code>U</code> 标示:
</p>
<pre class="example">
|  Task 1 |   Task 2 |    Total |
|---------+----------+----------|
|    2:12 |     1:47 |          |
|    2:12 |     1:47 |          |
| 3:02:20 | -2:07:00 |          |
#+TBLFM: @2$3=$1+$2;T::@3$3=$1+$2;U::@4$3=$1+$2;t

</pre>

<p>
计算结果:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Task 1</th>
<th scope="col" class="org-right">Task 2</th>
<th scope="col" class="org-right">Total</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">2:12</td>
<td class="org-right">1:471</td>
<td class="org-right">03:59:00</td>
</tr>

<tr>
<td class="org-right">2:12</td>
<td class="org-right">1:47</td>
<td class="org-right">03:59</td>
</tr>

<tr>
<td class="org-right">3:02:20</td>
<td class="org-right">-2:07:00</td>
<td class="org-right">0.92</td>
</tr>
</tbody>
</table>

<p>
输入持续时间值必须使用 <code>HH:MM[:SS]</code> 的格式,其中秒是可选的. 使用 <code>T</code> 标示,计算持
续时间值的结果用 <code>HH:MM:SS</code> 展示,上面例子的第一个公式.使用 <code>U</code> 标示,秒被略去,所
以结果只有 <code>HH:MM</code> ,上面例子的第二个公式.小时字段的零填充取决于变量
<code>org-table-duration-hour-zero-padding</code> 的值.
</p>

<p>
使用 <code>t</code> 标示,计算出的持续时间值会根据 <code>org-table-duration-custom-format</code> 变量的
值来展示, 默认的值是 <code>hours</code> ,即将结果展示为小时的小数形式,就是上面的第三个公
式的形式.
</p>

<p>
负数的持续时间值也可以被操作,整数在加和减的操作中被视作秒来计算.
</p>
</div>
</div>

<div id="outline-container-org96d68a2" class="outline-4">
<h4 id="org96d68a2">字段和范围公式(Field and range formulas)</h4>
<div class="outline-text-4" id="text-org96d68a2">
<blockquote>
<p>
特定字段(字段范围)的公式.
</p>
</blockquote>
<p>
要将公式赋值给特定字段, 直接在字段里输入公式,放在 <code>:=</code> 之后.例如
<code>:=vsum(@II..III)</code>. 当光标在字段里时,按 <code>&lt;TAB&gt;</code> 或 <code>&lt;RET&gt;</code> 或 <code>C-c C-c</code>, 这个字段的
公式会被存储,计算,当前字段会被替换成计算结果.
</p>

<p>
公式会被存储到表格正下方的特殊关键字 <code>TBLFM</code> 里.如果你在表格第三个数据行的第四个字
段里输入公式,存储的公式会是像这样的: <code>@3$4=$1+$2</code>.当使用恰当的命令插入/删除/交
换 行或列的时候保存的公式里的绝对引用也会跟着改变,以便仍然指向相同的字段.要
想避免这一行为的发生,特别是在范围引用里,用表格边界固定范围(用 <code>@&lt;,@&gt;,$&lt;,$&gt;</code>)或
用水平分割线(<code>@I</code>)标记.如果使用普通的编辑命令修改表格的结构,公式里引用的自动调
整是不会发生的,你必须要自己调整公式.
</p>

<p>
你也可以使用下面的命令,而不是在字段中键入公式:
</p>

<dl class="org-dl">
<dt><code>C-u C-c =</code> &#x2013; <code>(org-table-eval-formula)</code></dt><dd>在当前字段插入新的公式.这个命令提
示输入默认取自 <code>TBLFM</code> 关键词的公式,并将其应用到当前字段,存储到 <code>TBLFM</code> 里. 公
式的左边也可以是赋值公式到若干其他字段的特殊表达式. 要添加这样的公式, 使用
公式编辑器或直接编辑 <code>TBLFM</code> 宽肩字,因为没有输入这样的公式的快捷键.</dd>

<dt><code>$2=</code></dt><dd>列公式,对整个列有效. 因为这种用法的需求很常见,所以Org 将这一类公式
特殊处理,详情见下面 Column formulas 一节.</dd>

<dt><code>@3=</code></dt><dd>行公式,应用到指定行的所有字段. <code>@&gt;=</code> 意味着最后一行.</dd>

<dt><code>@1$2..@4$3=</code></dt><dd>范围公式,应用到给定矩形范围的所有字段. 这也可以用来给一行中
的某些单不是所有字段赋值.</dd>

<dt><code>$NAME=</code></dt><dd>命名字段,详情查看高级功能(Advanced features).</dd>
</dl>
</div>
</div>

<div id="outline-container-org3894a4e" class="outline-4">
<h4 id="org3894a4e">列公式(Column formulas)</h4>
<div class="outline-text-4" id="text-org3894a4e">
<blockquote>
<p>
对整列有效的公式.
</p>
</blockquote>
<p>
当将公式给简单的列引用(<code>$3=</code>)赋值时,相同的公式会被应用到那一列的所有字段,但有
以下非常方便的例外情况:(i) 如果表格的上面和下面的行包括了水平分割线,在第一个
水平分割线之前的所有行都被视为表头,表头不会被列公式改变.因此当你使用了列公式
并系那个要用水平分割线将行分组时,表头时必须有的.例如,将底部的合计行与上面的
汇总行分开. (ii) 那些已经由字段/范围公式赋值的字段,列公式也不会进行赋值.这些
条件使得列公式非常容易使用.
</p>

<p>
要用公式给一列赋值,直接在列中任意字段输入跟在一个等号后面的公式,例如
<code>=$1+$2</code>.当光标仍在字段中时,你按 <code>&lt;TAB&gt;</code> 或 <code>&lt;RET&gt;</code> 或 <code>C-c C-c</code> ,对当前列的公式会被
保存,当前字段会被公式的计算结果替换.如果字段里只有 <code>=</code> ,那么之前保存的这一列的
公式会被使用.对每一列来讲说,Org 只会记得最近使用的公式.在 <code>TBLFM</code> 关键字里,列
公式就像 <code>$4=$1+$2</code> 这样.列公式的左边不能是列的名字,必须是数字形式的列引用或 <code>$&gt;</code>
</p>

<p>
你也可以使用下面的命令,而不是在字段中输入公式:
</p>
<dl class="org-dl">
<dt><code>C-c =</code> &#x2013; <code>(org-table-eval-formula)</code></dt><dd>为当前列插入新的公式,并将当前字段都替
换成公式的结果. 命令会提示输入一个公式,默认公式是从 <code>TBLFM</code> 里取出的上一次应
用并保存的公式,然后会将公式应用到当前字段并保存.当结合数字前缀参数使用,例
如 <code>C-5 C-c =</code>,命令会将公式应用到当前列的前5个连续字段.</dd>
</dl>
</div>
</div>

<div id="outline-container-org68a4082" class="outline-4">
<h4 id="org68a4082">查找函数(Lookup functions)</h4>
<div class="outline-text-4" id="text-org68a4082">
<blockquote>
<p>
用于搜索表格的查找函数.
</p>
</blockquote>

<p>
Org 有三个预定义的 Emacs Lisp 函数,用来在表格中进行查找.
</p>

<dl class="org-dl">
<dt><code>(org-lookup-first VAL S-LIST R-LIST &amp;optional PREDICATE)</code></dt><dd>在 S-LIST 里查
找符合 (PREDICATE VAL S) 的第一个元素 S ; 返回列表 R-LIST 里对应位置
的值. 默认的 PREDICATE(断言)是 <code>equal</code>. 要注意的是, VAL 和 S 是按照他们出现
的顺序传递到 PREDICATE 里的.如果 R-LIST 是 <code>nil</code> 那么就会返回 S-LIST 里匹配
的元素 S.</dd>

<dt><code>(org-lookup-last VAL S-LIST R-LIST &amp;optional PREDICATE)</code></dt><dd>和上面类似,但是
是查找符合条件的最后一个元素 S.</dd>

<dt><code>(org-lookup-all VAL S-LIST R-LIST &amp;optional PREDICATE)</code></dt><dd><p>
和查找第一个元素
类似,但是是查找所有符合条件的元素,并且返回所有相应的值.这个函数在公式里不
能单独使用,因为它返回的是一个值列表.然而,这个函数和其他 Emacs Lisp 函数结
合起来可以构建强大的查找功能.
</p>

<p>
如果这些函数里使用的范围包含空字段,公式的 <code>E</code> 模式通常需要被指定,不然的话空
字段不会在S-LIST 或 R-LIST 里包括的,这就可能导致函数结果返回错误的从
R-LIST 到 S-LIST的相关映射.
</p>

<p>
这三个函数可以用于实现关联数组,计数匹配单元格,排序结果,组合数据等.有关实际
的例子,请查看Worg 的教程:
(<a href="https://orgmode.org/worg/org-tutorials/org-lookups.html">https://orgmode.org/worg/org-tutorials/org-lookups.html</a>)
</p></dd>
</dl>
</div>
</div>

<div id="outline-container-orgbaac933" class="outline-4">
<h4 id="orgbaac933">编辑和调试公式(Editing and debugging formulas)</h4>
<div class="outline-text-4" id="text-orgbaac933">
<blockquote>
<p>
修正公式.
</p>
</blockquote>
<p>
你可以在minibuffer里编辑单个公式,也可以直接在字段里编辑公式. Org 还可以为一
个表格的所有有效公式准备一个特殊的缓冲区.在提供公式进行编辑时,如果可能, Org
会将引用转换成标准格式(如 <code>B3</code> 或 <code>D&amp;</code>). 如果你更喜欢只使用内部的格式(如 <code>@3$2</code>
或 <code>$4</code>),配置变量 <code>org-table-use-standard-references</code>
</p>

<dl class="org-dl">
<dt><code>C-c =</code> 或 <code>C-u C-c =</code> &#x2013; <code>(org-table-eval-formula)</code></dt><dd>在minibuffer里编辑与当前
列/字段关联的公式. 查看 <code>Column formulas</code> 和 <code>Field and range formula</code> 部分.</dd>

<dt><code>C-u C-u C-c =</code> &#x2013; <code>(org-table-eval-formula)</code></dt><dd>将有效公式(字段公式或列公式)
重新插入到当前字段,以便你可以直接在字段中编辑它.和在minibuffer 里编辑相比,
它的优点是可以使用 <code>C-c ?</code> 命令.</dd>

<dt><code>C-c ?</code> &#x2013; <code>(org-table-field-info)</code></dt><dd>当在表格字段里编辑一个公式时,高亮显示
公式中光标位置的引用所引用的字段.</dd>

<dt><code>C-c }</code> &#x2013; <code>(org-table-toggle-coordinate-overlays)</code></dt><dd>切换以覆盖方式显示的表
格的行号和列号.每次表格重新对齐时,显示会被更新;你也可以使用 <code>C-c C-c</code> 强制更
新.</dd>

<dt><code>C-c {</code> &#x2013; <code>(org-table-toggle-formula-debugger)</code></dt><dd>切换表格编辑器的开关.更多
信息查看下面的内容.</dd>

<dt><code>C-c '</code> &#x2013; <code>(org-table-edit-formulas)</code></dt><dd>在特殊的缓冲区编辑当前表格的所有公式,缓
冲区里每行一个公式.如果当前字段有一个有效公式,公式编辑器会用光标标记该公式.在
这个特殊缓冲区里,Org 会自动高亮光标位置的任意字段或范围的引用.你可以用下面
命令编辑,删除和添加公式:
<dl class="org-dl">
<dt><code>C-c C-c</code> 或 <code>C-x C-s</code> &#x2013; <code>(org-table-field-finish)</code></dt><dd>退出公式编辑器并保存公
式修改.加上 <code>C-u</code> 前缀使用,会同时将新公式应用到整个表格.</dd>

<dt><code>C-c C-q</code> &#x2013; <code>(org-table-fedit-abort)</code></dt><dd>退出公式编辑器,并丢弃更改.</dd>

<dt><code>C-c C-r</code> &#x2013; <code>(org-table-fedit-toggle-ref-type)</code></dt><dd>在公式编辑器里切换引用的
标准(<code>B3</code>) 和内部(<code>@3$2</code>) 格式.</dd>

<dt><code>&lt;TAB&gt;</code> &#x2013; <code>(org-table-fedit-lisp-indent)</code></dt><dd>美化光标处的显示或缩进.当一行
里有一个Lisp 公式时,根据Emacs Lisp 规则格式化表格.再次使用 <code>&lt;TAB&gt;</code> 会将公
式还原.在打开的公式中, <code>&lt;TAB&gt;</code> 会像在 Emacs Lisp 模式里一样重新缩进.</dd>

<dt><code>M-&lt;TAB&gt;</code> &#x2013; <code>(lisp-complete-symbol)</code></dt><dd>补全Lisp symbols, 就像在 Emacs Lisp
模式里一样.</dd>

<dt><code>S-&lt;UP&gt;,S-&lt;DOWN&gt;,S-&lt;LEFT&gt;,S-&lt;RIGHT&gt;</code></dt><dd>调整光标处的引用.一如,如果引用是
<code>B3</code> 然后你按了 <code>S-&lt;RIGHT&gt;</code> ,引用会变成 <code>C3</code>. 这种调整对相对定位的引用和水平分
割线的引用也有效.</dd>

<dt><code>M-S-&lt;UP&gt;</code> &#x2013; <code>(org-table-fedit-line-up)</code></dt><dd>将列公式的测试行在Org文件缓冲区
里上移.</dd>

<dt><code>M-S-&lt;DOWN&gt;</code> &#x2013; <code>(org-table-fedit-line-down)</code></dt><dd>将Org文件缓冲区里的列公式的
测试行下移.</dd>

<dt><code>M-&lt;UP&gt;</code> &#x2013; <code>(org-table-fedit-scroll-up)</code></dt><dd>将显示表格的窗口上移.</dd>

<dt><code>M-&lt;DOWN&gt;</code> &#x2013; <code>(org-table-fedit-scroll-down)</code></dt><dd>将显示表格的窗口下移</dd>

<dt><code>C-c }</code></dt><dd>关掉表格的座标网格.</dd>
</dl></dd>
</dl>


<p>
清空一个表格的字段内容不会删除相关字段的公式,因为公式是存储在不同的一行
<code>TBLFM</code> 关键字行里的. 在下一次重新计算时,这个字段会被重新填充.要删除一个字段的
公式,你必须在提示输入公式时给定一个空的值,或者在 <code>TBLFM</code> 关键词里编辑.
你可以直接在 <code>TBLFM</code> 关键词里编辑然后在那一行使用 <code>C-c C-c</code> 或在表格里使用普通的
重计算命令来应用这些更改过的公式.
</p>
</div>




<ul class="org-ul">
<li><a id="orge54b1b8"></a>使用多个 <code>TBLFM</code> 行(Using multiple TBLFM lines)<br />
<div class="outline-text-5" id="text-orge54b1b8">
<p>
你可能想要暂时应用某个公式. 这在你想要切换应用到表格里的公式时很有用.将多个
<code>TBLFM</code> 关键词直接放在表格之后,然后在公式上按 <code>C-c C-c</code>. 下面是使用的例子:
</p>
<pre class="example">

| x | y |
|---+---|
| 1 |   |
| 2 |   |
#+TBLFM: $2=$1*1
#+TBLFM: $2=$1*2
</pre>
<p>
当光标在 <code>#+TBLFM: $2=$1*2</code> 一行时,按 <code>C-c C-c</code>:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">x</th>
<th scope="col" class="org-right">y</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">4</td>
</tr>
</tbody>
</table>

<p>
如果你使用 <code>C-u C-c *</code> 重新计算表格,还是上面的例子,你会得到只应用第一个 <code>TBLFM</code>
关键词的结果:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">x</th>
<th scope="col" class="org-right">y</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table>
</div>
</li>

<li><a id="orga54ec76"></a>调试公式(Debugging formulas)<br />
<div class="outline-text-5" id="text-orga54ec76">
<p>
当公式的计算发生了错误时,字段的内容会变成字符串 "#ERROR". 如果你想查看在变
量替换和计算的过程中发生了什么,以便找出bug, 在Tbl 菜单里打开公式调试,然后重
新计算,例如,在字段里按 <code>C-u C-u C-c = &lt;RET&gt;</code>. 详细的信息就会显示出来.
(menu-bar-mode 1)
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgf238ae1" class="outline-4">
<h4 id="orgf238ae1">更新表格(Updating the table)</h4>
<div class="outline-text-4" id="text-orgf238ae1">
<blockquote>
<p>
重新计算所有相关字段.
</p>
</blockquote>

<p>
表格的重新计算通常不是自动进行的,这一过程需要某个命令来触发. 要使重新计算至
少半自动,查看高级功能部分.
</p>

<p>
要重新计算表格的一行或整个表格,使用下面的命令:
</p>

<dl class="org-dl">
<dt><code>C-c *</code> &#x2013; <code>(org-table-recalculate)</code></dt><dd>通过先从左到右应用存储的列公式,然后再应用
字段或范围公式到当前的行来重新计算当前行.</dd>

<dt><code>C-u C-c *</code> 或 <code>C-u C-c C-c</code></dt><dd>一行一行地重新计算整个表格,任何在第一个水平分
割线之前的行都不受影响,因为这些行被视作表头的一部分.</dd>

<dt><code>C-u C-u C-c *</code> 或 <code>C-u C-u C-c C-c</code> &#x2013; <code>(org-table-iterate)</code></dt><dd>通过重新计算表
格,直到有新的变化生成来迭代表格.如果有些要计算的字段需要使用在计算序列中靠
后计算的其他字段的值时,则可能需要这样做.</dd>

<dt><code>M-x org-table-recalculate-buffer-tables</code></dt><dd>重新计算当前缓冲区中所有表格.</dd>

<dt><code>M-x org-table-recalculate-buffer-tables</code></dt><dd>迭代当前缓冲区中的所有表格,以聚
合表到表的依赖关系.</dd>
</dl>
</div>
</div>

<div id="outline-container-org4ba437a" class="outline-4">
<h4 id="org4ba437a">高级功能(Advanced features)</h4>
<div class="outline-text-4" id="text-org4ba437a">
<blockquote>
<p>
字段和列名,自动重计算等等.
</p>
</blockquote>

<p>
如果你想要字段自动进行重计算,或者如果你想要能够给字段和列赋值名字,那么你需要
为特殊标记字符保留表格的第一列.
</p>

<dl class="org-dl">
<dt><code>C-#</code> &#x2013; <code>(org-table-rotate-recalc-marks)</code></dt><dd><p>
将第一列中的计算标志旋转到状态
<code>#,*,!,$</code>.当有选中区域时,改变区域内的所有标志
</p>

<p>
这有一个收集学生考试结果的表格示例,并且利用了这些功能.
</p>

<pre class="example">

|---+---------+--------+--------+--------+-------+------|
|   | Student | Prob 1 | Prob 2 | Prob 3 | Total | Note |
|---+---------+--------+--------+--------+-------+------|
| ! |         |     P1 |     P2 |     P3 |   Tot |      |
| # | Maximum |     10 |     15 |     25 |    50 | 10.0 |
| ^ |         |     m1 |     m2 |     m3 |    mt |      |
|---+---------+--------+--------+--------+-------+------|
| # | Peter   |     10 |      8 |     23 |    41 |  8.2 |
| # | Sam     |      2 |      4 |      3 |       |  1.8 |
|---+---------+--------+--------+--------+-------+------|
|   | Average |        |        |        |  25.0 |      |
| ^ |         |        |        |        |    at |      |
| $ | max=50  |        |        |        |       |      |
|---+---------+--------+--------+--------+-------+------|
#+TBLFM: $6=vsum($P1..$P3)::$7=10*$Tot/$max;%.1f::$at=vmean(@-II..@-I);%.1f
</pre>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Student</th>
<th scope="col" class="org-right">Prob 1</th>
<th scope="col" class="org-right">Prob 2</th>
<th scope="col" class="org-right">Prob 3</th>
<th scope="col" class="org-right">Total</th>
<th scope="col" class="org-right">Note</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Maximum</td>
<td class="org-right">10</td>
<td class="org-right">15</td>
<td class="org-right">25</td>
<td class="org-right">50</td>
<td class="org-right">10.0</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Peter</td>
<td class="org-right">10</td>
<td class="org-right">8</td>
<td class="org-right">23</td>
<td class="org-right">41</td>
<td class="org-right">8.2</td>
</tr>

<tr>
<td class="org-left">Sam</td>
<td class="org-right">2</td>
<td class="org-right">4</td>
<td class="org-right">3</td>
<td class="org-right">9</td>
<td class="org-right">1.8</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Average</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">25.0</td>
<td class="org-right">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
重要事项:请注意,对这些特殊表格来讲,使用 <code>C-u C-c *</code> 重新计算表格,只影响被 <code>#</code>
或 <code>#</code> 标记的行,和那些有公式赋值的字段.列公式不会在有空字段的行生效.
</p></dd>
</dl>


<p>
标志字符及其含义:
</p>
<dl class="org-dl">
<dt><code>!</code></dt><dd>这一行定义列名,以便你能使用 <code>$Tot</code> 而不是 <code>$6</code> 来引用第六列.</dd>
<dt><code>^</code></dt><dd>这一行定义上一行字段的名字.用这种定义,表格的任何公式可以使用 <code>$m1</code> 来引
用值 <code>10</code>.此外,你也可以将公式赋值给命名字段,它会被存储成这样: <code>$name = ...</code> .</dd>
<dt><code>_</code></dt><dd>和 <code>^</code> 类似,不过是定义下一行的字段名.</dd>
<dt><code>$</code></dt><dd>这一行的字段能定义公式里的参数.例如,如果 <code>$</code> 行的某一字段包含 <code>max=50</code>,
然后这个表格的公式可以使用 <code>$max</code> 引用50这个值.参数和常量一样使用,只不过参数
是基于每个表定义的.</dd>
<dt><code>#</code></dt><dd>在这一行里按 <code>&lt;TAB&gt;</code> 或 <code>&lt;RET&gt;</code> 或 <code>S-&lt;TAB&gt;</code> 时,这一行的字段会自动进行重新
计算.此外,这一行在使用 <code>C-u C-c *</code> 进行全局重计算时也会被选中.未标记的行不会
被该命令选中.</dd>
<dt><code>*</code></dt><dd>使用 <code>C-u C-c *</code> 进行全局计算时选中改行,但是不会进行自动的重新计算.当自
动重新计算使编辑速度过慢时,请使用这一标志.</dd>
<dt><code>/</code></dt><dd>不导出此行.在包含收缩标记 <code>&lt;N&gt;</code> 或列分组标记的行里很有用.</dd>
</dl>


<p>
最后,为了激起你对奇妙的 Calc 包能做什么的兴趣,这里有一个表格,用来计算两个函
数在 x 位置的 n 阶泰勒级数.
</p>
<pre class="example">
|---+-------------+---+-----+--------------------------------------|
|   | Func        | n | x   | Result                               |
|---+-------------+---+-----+--------------------------------------|
| # | exp(x)      | 1 | x   | 1 + x                                |
| # | exp(x)      | 2 | x   | 1 + x + x^2 / 2                      |
| # | exp(x)      | 3 | x   | 1 + x + x^2 / 2 + x^3 / 6            |
| # | x^2+sqrt(x) | 2 | x=0 | x*(0.5 / 0) + x^2 (2 - 0.25 / 0) / 2 |
| # | x^2+sqrt(x) | 2 | x=1 | 2 + 2.5 x - 2.5 + 0.875 (x - 1)^2    |
| * | tan(x)      | 3 | x   | 0.0175 x + 1.77e-6 x^3               |
|---+-------------+---+-----+--------------------------------------|
#+TBLFM: $5=taylor($2,$4,$3);n3
</pre>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Func</th>
<th scope="col" class="org-right">n</th>
<th scope="col" class="org-left">x</th>
<th scope="col" class="org-left">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">exp(x)</td>
<td class="org-right">1</td>
<td class="org-left">x</td>
<td class="org-left">1 + x</td>
</tr>

<tr>
<td class="org-left">exp(x)</td>
<td class="org-right">2</td>
<td class="org-left">x</td>
<td class="org-left">1 + x + x^2 / 2</td>
</tr>

<tr>
<td class="org-left">exp(x)</td>
<td class="org-right">3</td>
<td class="org-left">x</td>
<td class="org-left">1 + x + x^2 / 2 + x^3 / 6</td>
</tr>

<tr>
<td class="org-left">x^2+sqrt(x)</td>
<td class="org-right">2</td>
<td class="org-left">x=0</td>
<td class="org-left">x*(0.5 / 0) + x^2 (2 - 0.25 / 0) / 2</td>
</tr>

<tr>
<td class="org-left">x^2+sqrt(x)</td>
<td class="org-right">2</td>
<td class="org-left">x=1</td>
<td class="org-left">2 + 2.5 x - 2.5 + 0.875 (x - 1)^2</td>
</tr>

<tr>
<td class="org-left">tan(x)</td>
<td class="org-right">3</td>
<td class="org-left">x</td>
<td class="org-left">0.0175 x + 1.77e-6 x^3</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-org32bb6b0" class="outline-3">
<h3 id="org32bb6b0">Org 绘图(Org Plot)</h3>
<div class="outline-text-3" id="text-org32bb6b0">
<blockquote>
<p>
根据 Org 表格数据绘图
</p>
</blockquote>
<p>
Org Plot 可以生成存储在Org 表格里的信息的图像,可以是图片形式,也可以是 ASCII
形式
</p>
</div>
<div id="outline-container-org10e1870" class="outline-4">
<h4 id="org10e1870">使用 Gnuplot 的图形绘图(Graphical plots using Gnuplot)</h4>
<div class="outline-text-4" id="text-org10e1870">
<p>
Org Plot 可以使用Gnuplot(<a href="http://www.gnuplot.info/">http://www.gnuplot.info/</a>) 和
Gnuplot(<a href="http://cars9.uchicago.edu/~ravel/software/gnuplot-mode.html">http://cars9.uchicago.edu/~ravel/software/gnuplot-mode.html</a>) 生成Org
表格存储的信息的 2D 和 3D 图形.要看到这一操作,请确保你在你的系统里同时安装了
Gnuplot 和 Gnuplot mode. 然后在下面的表格里调用 <code>C-c " g</code> 或 <code>M-x
    org-plot/gnuplot</code> :
</p>

<pre class="example">
#+PLOT: title:"Citas" ind:1 deps:(3) type:2d with:histograms set:"yrange [0:]"
| Sede      | Max cites | H-index |
|-----------+-----------+---------|
| Chile     |    257.72 |   21.39 |
| Leeds     |    165.77 |   19.68 |
| Sao Paolo |     71.00 |   11.50 |
| Stockholm |    134.19 |   14.33 |
| Morelia   |    257.56 |   17.67 |

</pre>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Sede</th>
<th scope="col" class="org-right">Max cites</th>
<th scope="col" class="org-right">H-index</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Chile</td>
<td class="org-right">257.72</td>
<td class="org-right">21.39</td>
</tr>

<tr>
<td class="org-left">Leeds</td>
<td class="org-right">165.77</td>
<td class="org-right">19.68</td>
</tr>

<tr>
<td class="org-left">Sao Paolo</td>
<td class="org-right">71.00</td>
<td class="org-right">11.50</td>
</tr>

<tr>
<td class="org-left">Stockholm</td>
<td class="org-right">134.19</td>
<td class="org-right">14.33</td>
</tr>

<tr>
<td class="org-left">Morelia</td>
<td class="org-right">257.56</td>
<td class="org-right">17.67</td>
</tr>
</tbody>
</table>

<p>
注意,Org Plot 足够智能,可以将表格的头信息(不是表头)应用为图形标签.可以通过表
前的 <code>PLOT</code> 关键词进一步控制绘图的标签,内容,类型和外观.完整的Org Plot 选项列表
在下面.更多的信息和例子请查看 Org Plot 教程
(<a href="https://orgmode.org/worg/org-tutorials/org-plot.html">https://orgmode.org/worg/org-tutorials/org-plot.html</a>).
</p>
</div>




<ul class="org-ul">
<li><a id="org21354d1"></a>绘图选项(Plot options)<br />
<div class="outline-text-5" id="text-org21354d1">
<dl class="org-dl">
<dt><code>set</code></dt><dd>指定绘图时要设置的Gnuplot选项.</dd>
<dt><code>title</code></dt><dd>指定绘图的标题.</dd>
<dt><code>ind</code></dt><dd>指定表格的哪一行作为 <code>x</code> 轴使用.</dd>
<dt><code>deps</code></dt><dd>如同 Lisp 风格的列表一样指定要绘制的列,用括号包围,并用空格分隔,例
如 <code>dep:(3 4)</code> 来绘制第三和第四列.默认绘制除了 <code>ind</code> 列之外的所有列</dd>
<dt><code>type</code></dt><dd>指定绘图是 <code>2d</code> , <code>3d</code> 还是 <code>grid</code> .</dd>
<dt><code>with</code></dt><dd>为要绘制的每一列指定要插入的 <code>with</code> 选项.例如 <code>lines</code>, <code>points</code>, <code>boxes</code>,
<code>impulses</code>. 默认值是 <code>lines</code>.</dd>
<dt><code>file</code></dt><dd>如果想要绘制到文件,指定其为 <code>"path/to/desired/output-file"</code>.</dd>
<dt><code>labels</code></dt><dd>用于 <code>deps</code> 的标签列表.默认是列的头信息(如果有的话).</dd>
<dt><code>line</code></dt><dd>指定要插入到 Gnuplot 脚本的一整行.</dd>
<dt><code>map</code></dt><dd>当绘制 <code>3d</code> 或 <code>gtid</code> 类型时,设置该选项为 <code>t</code>, 来绘制平面贴图而不是 <code>3d</code>
坡度图.</dd>
<dt><code>timefmt</code></dt><dd>指定Org mode 的时间戳在传递给Gnuplot 时的格式.默认是
<code>%Y-%m-%d-%H:%M:%S</code>.</dd>
<dt><code>script</code></dt><dd>如果你想要完全控制绘图过程,你可以指定一个绘图时使用的脚本文件&#x2013;
将文件名放置在双引号之间.在绘图之前,指定脚本文件中的每一个 <code>$datafile</code> 实例
都会被生成的数据文件的路径替换.注意:即使你设置了这个选项,也可能需要指定绘
图类型,因为这可能影响数据文件的内容.</dd>
</dl>
</div>
</li>

<li><a id="org0239518"></a>ASCII 条形图(ASCII bar plots)<br />
<div class="outline-text-5" id="text-org0239518">
<p>
当光标在一列上时,使用 <code>C-c " a</code> 或 <code>M-x orgtbl-ascii-plot</code> 来创造一个包含ASCII
艺术的条形绘图(条形码?)的新列.这个绘图是通过常规的列公式实现的.当根源列改变
时,条状绘图可以通过刷新表格来更新.例如使用 <code>C-u C-c *</code>.
</p>

<pre class="example">
| Sede          | Max cites |              |
|---------------+-----------+--------------|
| Chile         |    257.72 | WWWWWWWWWWWW |
| Leeds         |    165.77 | WWWWWWWh     |
| Sao Paolo     |     71.00 | WWW;         |
| Stockholm     |    134.19 | WWWWWW:      |
| Morelia       |    257.56 | WWWWWWWWWWWW |
| Rochefourchat |      0.00 |              |
#+TBLFM: $3='(orgtbl-ascii-draw $2 0.0 257.72 12)

</pre>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Sede</th>
<th scope="col" class="org-right">Max cites</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Chile</td>
<td class="org-right">257.72</td>
<td class="org-left">WWWWWWWWWWWW</td>
</tr>

<tr>
<td class="org-left">Leeds</td>
<td class="org-right">165.77</td>
<td class="org-left">WWWWWWWh</td>
</tr>

<tr>
<td class="org-left">Sao Paolo</td>
<td class="org-right">71.00</td>
<td class="org-left">WWW;</td>
</tr>

<tr>
<td class="org-left">Stockholm</td>
<td class="org-right">134.19</td>
<td class="org-left">WWWWWW:</td>
</tr>

<tr>
<td class="org-left">Morelia</td>
<td class="org-right">257.56</td>
<td class="org-left">WWWWWWWWWWWW</td>
</tr>

<tr>
<td class="org-left">Rochefourchat</td>
<td class="org-right">0.00</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
上面例子里的公式是 Elisp 调用.
</p>
<dl class="org-dl">
<dt><code>(orgtbl-ascii-draw VALUE MIN MAX &amp;optional WIDTH CHARACTERS)</code></dt><dd>该函数会
在表格里绘制一个 ASCII 条状图. VALUE 是要绘制的值,它确定了要绘制的条状图
的宽度.MIN 是将显示为空的值(零宽度栏).MAX 是将绘制填充所有宽度的值,不在这
个范围(min2max)的值会被展示为 <code>too small</code> 或 ~too large.WIDTH 是从 MIN 到 MAX 的字符
跨度,就是条形图的最大字符数量,默认值是12. CHARACTERS 是一个用来构成条形图
的字符串,带有从纯白到纯黑的灰色阴影,它 默认为10个字符的常规ASCII字符字符
串.</dd>
</dl>
</div>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org4ead1a4" class="outline-2">
<h2 id="org4ead1a4"><span class="done DONE">DONE</span> 超链接(Hyperlinks)</h2>
<div class="outline-text-2" id="text-org4ead1a4">
<p>
像 HTML 一样,Org 提供了对文件内部的链接,其他文件的外部链接,新闻文章,邮件等的支
持.
</p>
</div>

<div id="outline-container-org5eb6777" class="outline-3">
<h3 id="org5eb6777">链接格式(Link Format)</h3>
<div class="outline-text-3" id="text-org5eb6777">
<blockquote>
<p>
Org 里的链接是怎样的格式.
</p>
</blockquote>
<p>
Org 能识别普通URI, 可能会被尖括号包围.而且可以将其作为可点击链接激活.
普通URI只能在定义良好的一组模式,见(<code>External Links</code> TODO). 与 URI 语法不同,他们
不能包含括号,也不能包含空格.尖括号里使用 URI 没有这些限制.
</p>

<p>
但是,常规的链接格式如下:
</p>
<pre class="example">
[[LINK][DESCRIPTION]]
</pre>
<p>
或者这样:
</p>
<pre class="example">
[[LINK]]
</pre>
<p>
LINK 部分的有些 <code>\</code> , <code>[</code> 和 <code>]</code> 字符需要被转义,也就是要在之前加一个 <code>\</code> 字符.更特殊
的是,下面的字符,也只有下面的字符,是必须被转义的:
</p>
<ol class="org-ol">
<li>所有 <code>[</code> 和 <code>]</code> 字符.</li>
<li>在 <code>[</code> 或 <code>]</code> 之前的每个 <code>\</code> 字符.</li>
<li>在链接最后的每个 <code>\</code> 字符.</li>
</ol>


<p>
插入链接的函数(Handling Links)会正确地转义不明确的字符.当你直接在方括号里插入
或粘贴URI时,只需要考虑上面的规则.当不是很确定时,你可以使用函数
<code>org-link-escape</code>, 它会将链接字符串转换成其转义后的形式.
</p>

<p>
一旦缓冲区里的一个链接完成了(所有括号都存在),Org 会更改其显示,以便显示
<code>DESCRIPTION</code> 而不是 <code>[[LINK][DESCRIPTION]]</code>, 显示 <code>LINK</code> 而不是 <code>[[LINK]]</code>. 链接会使
用 <code>org-link</code> 特征(face) 来高亮,默认情况下,是一个下划线的特征.
</p>

<p>
你可以直接编辑链接的可视部分,如果没有描述部分,那就编辑的是链接,反之,则编辑的
是描述部分.想要编辑链接的不可见部分,光标在链接上时使用 <code>C-c C-l</code> (Handling
Links).
</p>

<p>
如果当光标在链接可见部分的开头或最后之后按 <code>&lt;BS&gt;</code> ,你会删除那个位置的不可见的括
号(更准确地说,确切的行为取决于光标是如何到达该位置的,参见 <code>Invisible Text</code>
(elisp)TODO).这会使链接变得不完整,然后链接内部会重新作为普通文本显现出来.插入缺
失的括号会将链接重新隐藏.要显示所有链接的内部结构,使用菜单: Org → Hyperlink →
Literal links.
</p>
</div>
</div>

<div id="outline-container-orgc3efa52" class="outline-3">
<h3 id="orgc3efa52">内部链接(Internal Links)</h3>
<div class="outline-text-3" id="text-orgc3efa52">
<blockquote>
<p>
链接到当前文件的其他地方.
</p>
</blockquote>
<p>
一个不像URL(不是以任何一个已知的scheme或文件名开头)的链接,引用当前文件.当光标
位于链接上时,你可以使用 <code>C-c C-o</code> 或鼠标点击来打开链接(Handling Links).
</p>

<p>
Org 对文档内部的导航提供了一些改进.最值得注意的是,一个像 <code>[[#my-custom-id]]</code> 这
样的构造专门针对 <code>CUSTOM_ID</code> 属性设置为 <code>my-custom-id</code> 的条目.此外,一个像这样:
<code>[[*Some section]]</code> 的内部链接指向一个名字是 <code>Some section</code> 的标题.要插入指向标题
的链接,缓冲区补全可以使用.只需键入一个星号再加上几个可选的字母到缓冲区,然后按
<code>M-&lt;TAB&gt;</code>. 当前缓冲区的所有标题项都可由补全提供.
</p>

<p>
当一个链接不属于上述的任一情况时,Org 会查找专用目标:使用双尖括号的相同字符串,
例如 <code>&lt;&lt;My Target&gt;&gt;</code>.
<a href="#orgf0a99bf">外部链接(External Links)</a>
</p>

<p>
如果没有专用目标存在,链接会试图匹配缓冲区里元素的确切名称.命名,不出意料地,是
用 <code>NAME</code> 关键字完成的,它必须放在它引用的元素之前的行中,如下面的示例：
</p>
<pre class="example">
#+NAME: My Target
| a  | table      |
|----+------------|
| of | four cells |
</pre>

<p>
最后,如果上面的情况没有一个成功的,Org 会查找含有有链接文本而且加上 TODO 关键字和
标签的标题,或者根据 <code>org-link-search-must-match-exact-headline</code> 的值开始纯文本
查找.
</p>

<p>
注意,你必须保证自定义ID, 特殊目标和名字在整个文档里是独一无二的.Org 提供了一
个 linter 来帮助你完成这一过程,如果你需要的话.查看Org语法(Org Syntax)TODO.
</p>

<p>
在导出时,内部链接用于标记对象和给他们赋值一个编号.标记后的对象随后由指向他们
的链接引用.特别的,没有描述的链接显示为指定给标记对象的编号(当指向一个 <code>NAME</code> 关
键字时, <code>CAPTION</code> 关键字是必须有的,因为要得到正确的编号).在下面的Org 缓冲区片段
中:
</p>
<pre class="example">
1. one item
2. &lt;&lt;target&gt;&gt;another item
Here we refer to item [[target]].
</pre>
<p>
最后一句在导出时会展示为 <code>Here we refer to item 2</code>:
</p>
<ol class="org-ol">
<li>one item</li>
<li><a id="org6070292"></a>another item</li>
</ol>
<p>
Here we refer to item <a href="#org6070292">2</a>.
</p>

<p>
在非Org文件里,查找会找寻链接文本里的内容.在上面的例子里,查找的内容是 <code>target</code>.
</p>

<p>
点击链接会在Org 自己的标记环上加上一个标记.你能通过 <code>C-c &amp;</code> 来返回到上一位置.直
接连续多次使用这个命令,可以返回到先前记录的位置.
</p>
</div>
</div>

<div id="outline-container-orgc93661a" class="outline-3">
<h3 id="orgc93661a">无线电目标(Radio Targets)</h3>
<div class="outline-text-3" id="text-orgc93661a">
<p>
Org 可以自动将普通文本里出现的某些目标名称转换为链接.因此,在不显式创建链接的
情况下,文本将链接到目标,并标记其位置.Radio 目标由三个尖括号包围.例如, 目标
<code>&lt;&lt;&lt;My Target&gt;&gt;&gt;</code> 会导致正常文本中出现的每一个 <code>my target</code> 都作为链接激活.只有当
文件首次加载到 Emacs 里时,才会自动扫描Org 文件里的 radio 目标.要在编辑时更新
目标的列表,在光标位于目标上时,按 <code>C-c C-c</code> 即可. my target , My Target.
</p>
</div>
</div>

<div id="outline-container-orgf0a99bf" class="outline-3">
<h3 id="orgf0a99bf">外部链接(External Links)</h3>
<div class="outline-text-3" id="text-orgf0a99bf">
<blockquote>
<p>
链接到世界的类似 URL 的链接.
</p>
</blockquote>
<p>
Org 支持链接到文件,网站,新闻论坛和邮件消息,BBDB 数据库条目,还支持链接到IRC对
话和其日志. 外部链接是 URL 样子的定位器. 他们由一个简短的标示字符串加一个冒号
开始.冒号后不允许有空格.
</p>

<p>
下面是内建链接类型的完整集合:
</p>

<dl class="org-dl">
<dt><code>file</code></dt><dd>文件链接.文件名可以是远程文件,绝对路径或相对路径文件.
而且,你可以指定行号或搜索文本.在Org 文件里,你可以链接到标题名,自定义ID, 或
者是代码引用.
作为一个特殊的情况,如果文件名是完整的.例如,文件名以 <code>./</code> 或 <code>/</code> 开头."file"前缀
可以被省略.</dd>
<dt><code>attachment</code></dt><dd>和文件链接一样,但适用于附加到当前节点的文件和文件夹(见 <a href="#orge357962">附件(Attachments)</a>). 附件链接和文件链接的作用完全相同,但是适用于相对于附件目录的
文件.</dd>
<dt><code>bbdb</code></dt><dd>链接到一个 BBDB 记录,带有可能的正则补全.</dd>
<dt><code>docview</code></dt><dd>连接到使用 DOCView 模式打开的文本.你可以指定页码.</dd>
<dt><code>doi</code></dt><dd>通过其句柄,链接到电子资源.</dd>
<dt><code>elisp</code></dt><dd>激活后执行一个Elisp 命令.</dd>
<dt><code>gnus, rmail, mhe</code></dt><dd>连接到给定的Emacs MUA(邮件用户代理) 的消息或文件夹.</dd>
<dt><code>help</code></dt><dd>在 <code>*Help</code> 缓冲区里展示一个符号的文档.</dd>
<dt><code>http, https</code></dt><dd>网站链接.</dd>
<dt><code>id</code></dt><dd>在Org 文件里,通过ID 属性,连接到指定标题.</dd>
<dt><code>info</code></dt><dd>连接到一个 Info 手册或特定结点.</dd>
<dt><code>irc</code></dt><dd>连接到 IRC 频道.</dd>
<dt><code>mailto</code></dt><dd>连接到消息组成(编辑邮件).</dd>
<dt><code>news</code></dt><dd>新闻组链接.</dd>
<dt><code>shell</code></dt><dd><p>
激活后执行shell命令.
下面的表格说明了上面的链接类型,以及其选项:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">LinkType</th>
<th scope="col" class="org-left">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">http</td>
<td class="org-left"><code>‘http://staff.science.uva.nl/c.dominik/’</code></td>
</tr>

<tr>
<td class="org-left">https</td>
<td class="org-left"><code>‘https://orgmode.org/’</code></td>
</tr>

<tr>
<td class="org-left">doi</td>
<td class="org-left"><code>‘doi:10.1000/182’</code></td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">file</td>
<td class="org-left"><code>‘file:/home/dominik/images/jupiter.jpg’</code></td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>‘/home/dominik/images/jupiter.jpg’ (same as above)</code></td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>‘file:papers/last.pdf’</code></td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>‘./papers/last.pdf’ (same as above)</code></td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>‘file:/ssh:me@some.where:papers/last.pdf’ (remote)</code></td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>‘/ssh:me@some.where:papers/last.pdf’ (same as above)</code></td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>‘file:sometextfile::NNN’ (jump to line number)</code></td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>‘file:projects.org’</code></td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>‘file:projects.org::some words’ (text search)</code> <sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup></td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>‘file:projects.org::*task title’ (headline search)</code></td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>‘file:projects.org::#custom-id’ (headline search)</code></td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">attachment</td>
<td class="org-left"><code>‘attachment:projects.org’</code></td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>‘attachment:projects.org::some words’ (text search)</code></td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">docview</td>
<td class="org-left"><code>‘docview:papers/last.pdf::NNN’</code></td>
</tr>

<tr>
<td class="org-left">id</td>
<td class="org-left"><code>‘id:B7423F4D-2E8A-471B-8810-C40F074717E9’</code></td>
</tr>

<tr>
<td class="org-left">news</td>
<td class="org-left"><code>‘news:comp.emacs’</code></td>
</tr>

<tr>
<td class="org-left">mailto</td>
<td class="org-left"><code>‘mailto:adent@galaxy.net’</code></td>
</tr>

<tr>
<td class="org-left">mhe</td>
<td class="org-left"><code>‘mhe:folder’ (folder link)</code></td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">rmail</td>
<td class="org-left"><code>‘rmail:folder’ (folder link)</code></td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>‘rmail:folder#id’ (message link)</code></td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">gnus</td>
<td class="org-left"><code>‘gnus:group’ (group link)</code></td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>‘gnus:group#id’ (article link)</code></td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">bbdb</td>
<td class="org-left"><code>‘bbdb:R.*Stallman’ (record with regexp)</code></td>
</tr>

<tr>
<td class="org-left">irc</td>
<td class="org-left"><code>‘irc:/irc.com/#emacs/bob’</code></td>
</tr>

<tr>
<td class="org-left">help</td>
<td class="org-left"><code>‘help:org-store-link’</code></td>
</tr>

<tr>
<td class="org-left">info</td>
<td class="org-left"><code>‘info:org#External links’</code></td>
</tr>

<tr>
<td class="org-left">shell</td>
<td class="org-left"><code>‘shell:ls *.org’</code></td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">elisp</td>
<td class="org-left"><code>‘elisp:(find-file "Elisp.org")’ (Elisp form to evaluate)</code></td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>‘elisp:org-agenda’ (interactive Elisp command)</code></td>
</tr>
</tbody>
</table></dd>
</dl>


<p>
#+end_example
除了这些内置链接类型之外,还可以通过 <code>contrib/</code> (见<a href="#orgd375552">安装(Installation)</a>)目录使
用其他类型链接). 例如.当你从 <code>contrib/</code> 目录里加载相应库时,你可以链接到 VM
或 Wanderlust 消息:
</p>
<pre class="example">
‘vm:folder’                              VM folder link
‘vm:folder#id’                           VM message link
‘vm://myself@some.where.org/folder#id’   VM on remote machine
‘vm-imap:account:folder’                 VM IMAP folder link
‘vm-imap:account:folder#id’              VM IMAP message link
‘wl:folder’                              Wanderlust folder link
‘wl:folder#id’                           Wanderlust message link
</pre>
<p>
有关自定义Org 以添加新链接类型的信息,见 [[*Adding Hyperlink Types].TOTO.
</p>

<p>
链接应该用双括号括起来,并且可能包含要展示的描述性文本,而不是URL(见 <a href="#org5eb6777">链接格式(Link Format)</a>).例如：
</p>
<pre class="example">
[[http://www.gnu.org/software/emacs/][GNU Emacs]]
</pre>
<p>
效果:
<a href="http://www.gnu.org/software/emacs/">GNU Emacs</a>
如果描述是一个指向图片的文件名或URL,HTML 导出(见 <a href="#org7b70547">HTML 导出(HTML Export)</a>)
会将图片以可点击的按钮形式内联导出.如果链接指向一个图片,而且没有任何的描述,
改图片会直接内联到导出的HTML 文件里.
</p>

<p>
Org 还识别普通文本里的外部链接,并将他们激活为链接.如果空格必须是链接的一部
分(例如 <code>bbdb:R. *Stallman</code>) 或者如果你需要消除链接尾部的歧义字符,请将链接括
在方括号或者尖括号中.
</p>
</div>
</div>

<div id="outline-container-org78b3dfa" class="outline-3">
<h3 id="org78b3dfa">处理链接(Handling Links)</h3>
<div class="outline-text-3" id="text-org78b3dfa">
<p>
Org 提供了使用正确语法创建链接,插入链接和打开链接的方法.
</p>

<p>
最主要的方法是 <code>org-store-link</code>, 使用 <code>M-x org-store-link</code> 调用.因为其重要性,我们
建议将其绑定为常用快捷键(*Activation TODO). 这个命令会保存光标所在位置的一个
链接.这个链接是为了之后插入到Org 缓冲区而保存的(下面内容).创造的链接的类型取
决于当前的缓冲区:
</p>

<dl class="org-dl">
<dt>Org 模式缓冲区</dt><dd>对于Org 文件,如果光标处有一个 <code>&lt;&lt;target&gt;&gt;</code>, 链接会指向这个
target. 没有,则链接会指向当前的标题(也是链接的描述内容).注意,如果标题包含有
时间戳,时间戳会在链接里被删除,这会导致一个错误的链接,所以你应该避免在标题里
使用时间戳.
如果标题有 <code>CUSTOM_ID</code> 属性,会使用这个自定义的ID 来保存链接.此外,可选的是,根
据 <code>org-id-link-to-org-use-id</code> 的值,来为链接创造全局唯一的 <code>ID</code> 属性(Org 的 ID
库必须要先被加载,要么通过 <code>org-customize</code> 方法,要么在 <code>org-modules</code> 启用 <code>id</code> 模
块,要么就在Emacs init 文件里添加 <code>require 'org-id</code>). 所以,在Org 缓冲区里使用
这个命令可能会创造两个链接:一种使用自定义ID的人类可读的链接,另一种是全局唯
一的即使条目从一个文件移动到另一个文件也有效的链接.在稍后插入链接时,你需要
决定使用那一种链接.</dd>

<dt>邮件/新闻客户端:VM,Rmail,Wanderlust,MH-E,Gnus </dt><dd>几乎所有的Emacs 邮件客户
端都支持.指向当前文章的链接,或者在某些 Gnus 缓冲区里,指向组的链接.描述部分
是根据变量 <code>org-link-email-description-format</code> 来构建的.默认情况下,链接指向收
件人和主题.</dd>

<dt>网页浏览器:W3,W3M 和 EWW</dt><dd>在这里,链接就是当前的URL, 页面标题就是描述部分.</dd>

<dt>联系人(Contacts):BBDB</dt><dd>BBDB 缓冲区里创造的链接指向当前条目.</dd>

<dt>聊天(Chat):IRC</dt><dd>对于IRC 链接,如果 <code>org-irc-link-to-logs</code> 变量非空,则创建
<code>file</code> 类型的链接,指向光标在当前对话的日志文件的位置.若为空,则保存一个 <code>irc</code> 类
型的链接,指向光标所在的用户/频道/服务器.</dd>

<dt>其他文件</dt><dd>对于其他类型文件,链接指向文件,加上指向当前行内容的搜索字符串(见
Search Options TODO). 如果存在选区,选中的文本组成搜索字符串.你可以编写自定
义的Lisp 函数来选择搜索字符串和针对特定文件类型执行搜索(见 Custom Searches
TODO). 你也可以定义指向其他文件的特定链接(见 <a href="#orge6a66a0">Adding Hyperlink Types</a> ).</dd>

<dt>Agenda 视图</dt><dd>当光标位于 Agenda(日程) 视图时,创造的链接会指向光标所在当前
行引用的条目.</dd>
</dl>


<p>
在Org 缓冲区中,下面的命令创建,浏览或者更通俗地讲,对链接进行操作:
</p>

<dl class="org-dl">
<dt><code>C-c C-l</code> &#x2013; <code>(org-insert-link)</code></dt><dd>插入一个链接<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>.会提示输入要
被插入到缓冲区的链接.你可以通过键入内部链接的文本,或者上面例子里提到的链接
类型来插入一个链接.链接会被插入到缓冲区,并且带有描述文本<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup>.如果这时有文本被选中,文本会成为默认
的链接描述. + 插入保存的链接 :: 在当前会话中所有保存的链接都会作为提示输入
的历史记录的一部分,所以你可以使用 <code>&lt;UP&gt;</code> 和 <code>&lt;DOWN&gt;</code> (<code>M-p</code> , <code>M-n</code>) 来获取这些链接.
<dl class="org-dl">
<dt>补全支持</dt><dd>用 <code>&lt;TAB&gt;</code> 触发补全可以帮助你插入有效的链接前缀(像 <code>http</code> 或
<code>ftp</code>), 甚至包括通过链接缩写(见TODO[*链接缩写(Link Abbreviations)]])定义的
缩写.如果你在只插入前缀之后按 <code>&lt;RET&gt;</code>,Org 会提供这些链接类型的特定的补全支
持(<sup><a id="fnr.4" class="footref" href="#fn.4">4</a></sup>).例如, 如果你键入 <code>file&lt;RET&gt;</code> 或者使用 <code>C-u C-c C-l</code> 看接下来会发生什
么,Org会提供文 件名补全.键入 <code>bbdb&lt;RET&gt;</code> 提供联系人名字补全.</dd>
</dl></dd>

<dt><code>C-u C-c C-l</code></dt><dd>当上面的命令加上 <code>C-u</code> 前缀参数一起使用时,插入一个链接到文件
的链接.你可以使用文件名补全来选择文件的类型.如果链接文件在当前目录或当前目
录的子目录,或者路径是使用相对 路径格式 <code>../</code>, 那么插入的文件路径是相对路径;否
则,就会使用绝对路径.如果可能, 使用 <code>~/</code> 来标示家目录.可以使用两个 <code>C-u C-u</code> 来
强制使用绝对路径.</dd>

<dt><code>C-c C-l</code> (光标在链接上)</dt><dd>当光标在链接上时,该命令允许你编辑链接的链接和描述
部分.</dd>

<dt><code>C-c C-o</code> &#x2013; <code>(org-open-at-point)</code></dt><dd>打开光标处链接.链接是URL,该命令会打开网页
浏览器(使用 <code>browse-url-at-point</code> 方法);如果是相应链接,会运行
VM/MH-E/Wanderlust/Rmail/Gnus/BBDBc 程序;如果是脚本链接,会执行脚本.当光标处
是内部链接时,命令会运行相应查找操作.当光标位于标题的标签(tag)部分,命令会创
建一个响应的标签视图.如果光标在时间戳上,命令会搜集那个日期的日程.此外,命令
会访问Emacs <code>file</code> 链接中的文本和远程文件,并为本地非文本文件选择合适的应用程
序.文件的分类只基于文件扩展名.查看选项 <code>org-file-apps</code>. 如果你想覆盖默认应用
程序并用Emacs 打开文件,请使用 <code>C-u</code> 前缀. 如果你想避免使用 Emacs 打开,使用
<code>C-u C-u</code> 前缀.
如果光标在标题上,但标题不是一个链接,命令提供该标题和条目文本里的所有链接.如
果你想设置打开链接的框架配置,自定义 <code>org-link-frame-setup</code>.</dd>

<dt><code>&lt;RET&gt;</code></dt><dd>当设置了 <code>org-return-follows-link</code> 时(设置为t), <code>&lt;RET&gt;</code> 也可以用来打开
光标处的链接.</dd>

<dt><code>mouse-2</code> 或 <code>mouse-1</code></dt><dd>在链接上时,鼠标左键和滑轮像 <code>C-c C-o</code> 一样打开链接.</dd>

<dt><code>mouse-3</code></dt><dd>和鼠标滑轮相似,但是强制链接在Emacs 里打开,而且内部链接会在另一个
窗口里打开并展示(<sup><a id="fnr.5" class="footref" href="#fn.5">5</a></sup>~).</dd>

<dt><code>C-c %</code> &#x2013; <code>(org-mark-ring-push)</code></dt><dd>将光标当前位置加入到Org 的标记环,以便能轻
松返回.打开内部链接的命令会自动完成这一动作.</dd>

<dt><code>C-c &amp;</code> &#x2013; <code>(org-mark-ring-goto)</code></dt><dd>跳转到记录的位置.位置会被打开内部链接的命
令或 <code>C-c %</code> 记录.直接连续多次使用这个命令会在之前记录的位置环里移动光标.</dd>

<dt><code>C-c C-x C-n</code> &#x2013; <code>(org-next-link)</code> , <code>C-c C-x C-p</code> &#x2013; <code>(org-previous-link)</code></dt><dd><p>
向上
或向下移动光标到缓冲区的链接.在缓冲区的限制下,搜索一旦失败,就返回.这个的快
捷键绑定真的太长了,你可能想要将它绑定到 <code>M-n</code> 和 <code>M-p</code>.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">with-eval-after-load</span> 'org
  (define-key org-mode-map (kbd <span style="font-style: italic;">"M-n"</span>) 'org-next-link)
  (define-key org-mode-map (kbd <span style="font-style: italic;">"M-p"</span>) 'org-previous-link))
</pre>
</div></dd>
</dl>
</div>
</div>

<div id="outline-container-org85d8cf7" class="outline-3">
<h3 id="org85d8cf7">Org 文件外部使用链接(Using Links Outside Org)</h3>
<div class="outline-text-3" id="text-org85d8cf7">
<p>
你不只可以在Org 文件里使用Org 语法插入和打开链接,你还可以在任意的Emacs 缓冲区里
使用.针对这个,Org 提供了两个函数: <code>org-insert-link-golobal</code> 和
<code>org-open-at-point-global</code>.
</p>

<p>
你可能想将他们绑定到全局可用快捷键.查看[Activation]TODO 来获取一些建议.
</p>
</div>
</div>

<div id="outline-container-org5818ee7" class="outline-3">
<h3 id="org5818ee7">链接缩写(Link Abbreviations)</h3>
<div class="outline-text-3" id="text-org5818ee7">
<p>
原始链接(长链接)的键入可能很麻烦,而且文档中通常需要许多类似的链接.为此,你可以
使用链接缩写.一个缩写链接长这样:
</p>
<pre class="example">
[[linkword:tag][description]]
</pre>
<p>
其中,tag 是可选的. linkword 必须是一个单词,以字母开头,后面跟着字母,数字, <code>-</code> 和
<code>_</code>.缩写将会根据变量 <code>org-link-abbrev-alist</code> 的信息进行解析,该变量将 linkword 和
替换文本关联起来.下面是一个例子:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">setq</span> org-link-abbrev-alist
      '((<span style="font-style: italic;">"bugzilla"</span>        . <span style="font-style: italic;">"http://10.1.2.9/bugzilla/show_bug.cgi?id="</span>)
        (<span style="font-style: italic;">"Nu Html Checker"</span> . <span style="font-style: italic;">"https://validator.w3.org/nu/?doc=%h"</span>)
        (<span style="font-style: italic;">"duckduckgo"</span>      . <span style="font-style: italic;">"https://duckduckgo.com/?q=%s"</span>)
        (<span style="font-style: italic;">"omap"</span>            . <span style="font-style: italic;">"http://nominatim.openstreetmap.org/search?q=%s&amp;polygon=1"</span>)
        (<span style="font-style: italic;">"ads"</span>             . <span style="font-style: italic;">"https://ui.adsabs.harvard.edu/search/q=%20author%3A\"%s\""</span>)))
</pre>
</div>
<p>
如果替换文本包含字符串 <code>%s</code> ,它将被 tag 替换. 使用 <code>%h</code> 而不是 <code>%s</code> 百分比,会对 tag
进行编码(上面需要将url参数编码的例子). 使用 <code>%(my-function)</code> 会将 tag 传递给自
定义的 Lisp 函数,并将tag 替换成结果字符串.
</p>

<p>
如果替换字符串并不包括任意的指示符,则只需要将其添加到字符串来创建链接.
</p>

<p>
你也可以指定一个 Lisp 函数而不是字符串来创建链接.这样的函数会将 tag 作为唯一
参数进行调用.
</p>

<p>
使用上面的设置,你可以使用 <code>[[bugzilla:129]]</code> 链接到一个特定的bug:29, 使用
<code>[[google:OrgMode]]</code> 来搜索 <code>OrgMode</code> , 使用 <code>[[gmap:51 Franklin Street, Boston]]</code>
来显示自由软件基金会的地图位置或使用 <code>[[omap:Science Park 904, Amsterdam, The
   Netherlands]]</code> 显示Carsten办公室的位置,还可以使用 <code>[[ads:Dominik,C]]</code> 来了解 Org
的作者除了 Emacs hacking 之外还在做些什么.
</p>

<p>
如果你只在单个Org 缓冲区里使用特殊缩写,你可以在文件里面定义他们:
</p>
<pre class="example">
#+LINK: bugzilla  http://10.1.2.9/bugzilla/show_bug.cgi?id=
#+LINK: google    http://www.google.com/search?q=%s
</pre>
<p>
缓冲区补全可以在 <code>[</code> 之后提供补全链接缩写的功能.你也可以定义Lisp 函数来实现特殊
的支持(例如补全功能),以便使用 <code>C-c C-l</code> 来插入这样的链接.这样的函数不应该接受任
何的参数,应该返回带前缀的完整链接. 你可以设置这样一个链接补全函数:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(org-link-set-parameter <span style="font-style: italic;">"type"</span> <span style="font-weight: bold;">:complete</span> #'some-completion-function)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc4a851d" class="outline-3">
<h3 id="orgc4a851d">搜索选项(Search Options)</h3>
<div class="outline-text-3" id="text-orgc4a851d">
<blockquote>
<p>
链接到特定的位置.
</p>
</blockquote>
</div>

<div id="outline-container-orgc85ff15" class="outline-4">
<h4 id="orgc85ff15">文件链接的搜索选项(Search Options in File Links)</h4>
<div class="outline-text-4" id="text-orgc85ff15">
<p>
文件链接可以包含额外的信息,来使Emacs 打开链接时跳转打文件的特定位置.特定位置
可以是行号或在双冒号之后的搜索选项<sup><a id="fnr.6" class="footref" href="#fn.6">6</a></sup>.例如,当 <code>org-store-link</code> 创建一个链文件(见 <a href="#org78b3dfa">处理链接(Handling Links)</a> 链接
时,该命令会将当前行的文本编码为搜索字符串(search string), 可以用于在以后使用
<code>C-c C-o</code> 打开链接时查找到这一行.
</p>

<p>
注意,所有搜索选项应用于附件链接和应用于文件链接的方式相同.
</p>

<p>
以下是将搜索附加到文件链接的不同方法的语法,以及每种方法的说明:
</p>
<pre class="example">
[[file:~/code/main.c::255]]
[[file:~/xx.org::My Target]]
[[file:~/xx.org::*My Target]]
[[file:~/xx.org::#my-custom-id]]
[[file:~/xx.org::/regexp/]]
[[attachment:main.c::255]]

</pre>
<dl class="org-dl">
<dt><code>255</code></dt><dd>跳转到第255行.</dd>
<dt><code>My Target</code></dt><dd>查找链接目标 <code>&lt;&lt;My Target&gt;&gt;</code> 或者进行文本 <code>my target</code> 的查找,和内
部链接的查找相似(见 <a href="#orgc3efa52">内部链接(Internal Links)</a>). 在HTML导出时(参见
 <a href="#org7b70547">HTML 导出(HTML Export)</a>), 这样的文件链接会成为一个指向链接文件里相应命名锚点的HTML
引用.</dd>
<dt><code>*My Target</code></dt><dd>在Org 文件里,将搜索限制到标题.</dd>
<dt><code>#my-custom-id</code></dt><dd>链接到有 <code>CUSTOM_ID</code> 属性的标题.</dd>
<dt><code>/REGEXP/</code></dt><dd>进行一次 <code>REGEXP</code> 的正则表达式查找. 这使用 Emacs 命令 <code>occur</code> 来在
单独窗口显示所有的匹配. 如果目标文件是Org 文件,会使用 <code>org-occur</code> 命令来创建
一个匹配内容的 <code>sparse tree</code> 稀疏树.</dd>
</dl>


<p>
作为次级用法,一个有空文件名的文件链接可以用来搜索当前文件.例如:
<code>[[file:::find me]]</code> 会在当前文件里进行 <code>find me</code> 的查找, 就和 <code>[[find me]]</code> 一样.
</p>
</div>
</div>
</div>


<div id="outline-container-org8110d43" class="outline-3">
<h3 id="org8110d43">自定义搜索(Custom Searches)</h3>
<div class="outline-text-3" id="text-org8110d43">
<blockquote>
<p>
当默认搜索功能不够用时.
</p>
</blockquote>
<p>
创建搜索字符串并且执行与文件链接相关的实际搜索的默认机制可能无法在所有情况下
都正常工作.例如,BibTex 数据库文件有许多像 <code>year="1993"</code> 的条目,这样的条目不能生
成有效的搜索字符串,因为在BibTex 条目里只有引用key 是唯一的标示.
</p>

<p>
如果你碰到了这样的问题,你可以编写自定义的函数,来为特定文件类型设置正确的搜索
字符串,并执行文件里搜索字符串的搜索. 这些方法需要使用 <code>add-hook</code> 添加到钩子变量
(hook variable) <code>org-create-file-search-functions</code> 和
<code>org-execute-file-search-functions</code> 里.查看这些变量的文档字符串来获取更多信息.Org
实际上对 BibTex 数据库文件使用这种机制,而且你可以使用相关的代码作为一个实现的
例子. 查看文件 <code>ol-bibtex.ex</code>
</p>
</div>
</div>
</div>

<div id="outline-container-orgc0e6782" class="outline-2">
<h2 id="orgc0e6782"><span class="done DONE">DONE</span> <code>TODO</code> 条目(TODO Items)</h2>
<div class="outline-text-2" id="text-orgc0e6782">
<p>
Org mode 并不把 TODO 项目当成独立的文档维护<sup><a id="fnr.7" class="footref" href="#fn.7">7</a></sup>,相反的, TODO 项目被视作笔记文件的
一个组成部分, 因为 TODO 项目通常在作笔记时出现(使用)! 在 Org mode 下,只需要将
结构树重任意条目标记为一个 TODO 项目,这样, 信息就不会重复,并且 TODO 项目的整个
上下文总是会显示.
</p>

<p>
当然,这种管理 TODO 项目的技术会将他们分散到你的笔记文件中. 为了补偿这一点, Org
mode 提供了一些方法来让你对你必须要做的事情有一个总览视图.
</p>
</div>

<div id="outline-container-orgc358534" class="outline-3">
<h3 id="orgc358534"><code>TODO</code> 基础(TODO Basics)</h3>
<div class="outline-text-3" id="text-orgc358534">
<p>
标记和展示 TODO 条目.
</p>
</div>

<div id="outline-container-org907022d" class="outline-4">
<h4 id="org907022d">基本的 TODO 功能(Basic TODO Functionality)</h4>
<div class="outline-text-4" id="text-org907022d">
<p>
任何以 'TODO' 开头的标题都会称为一个 TODO 条目, 例如:
</p>
<pre class="example">
*** TODO Write letter to Sam Fortune
</pre>
<p>
和 TODO 条目一起工作的最重要的命令是下面这些:
</p>
<dl class="org-dl">
<dt><code>C-c C-t</code> &#x2013; (<code>org-todo</code>)</dt><dd><p>
让当前 TODO 条目的状态在下面的状态里循环:
</p>
<pre class="example">
,-&gt; (unmarked) -&gt; TODO -&gt; DONE --.
'--------------------------------'
</pre>
<p>
如果 TODO 关键字有快速访问键(
<a href="#orgd8eb08a">快速访问 TODO 状态(Fast access to TODO states)</a>),则会从快速选择界面提示输
入 TODO 关键字;
这个行为在 <code>org-use-fast-todo-selection</code> 变量非 <code>nil</code> 时是默认行为.
同样的状态改变可以通过在 agenda 缓冲区使用 <code>t</code> 命令键完成(TODO[[]]).
</p></dd>
<dt>S-&lt;RIGHT&gt; S-&lt;LEFT&gt;</dt><dd>选择上一个或下一个 TODO 状态, 和循环类似.如果可能有
两个以上的 TODO 状态,则最有用(<a href="#org22b9067"><code>TODO</code> 扩展(TODO Extensions)</a>). 又见
TODO *Conflicts]] 有关用shift选择来进行交互的讨论. 另见变量
<code>org-treat-S-cursor-todo-selection-as-state-change</code> 的文档.</dd>
<dt>C-c / t &#x2013; (org-show-todo-tree)</dt><dd>在稀疏树中查看TODO条目(参见
<a href="#org7e42153">稀疏树(Sparse Trees)</a>).这会折叠整个缓冲区,但只显示所有未完成状态的 TODO 条目,以及
他们上层的标题. 带上前缀参数使用,或者用 <code>C-c / T</code>, 可以查找特定的 TODO 条目,
你会被提示输入关键字,而且你会看到一个像这样的关键字列表 <code>‘KWD1|KWD2|...’</code> 来
展示列表中任何一个与你的输入匹配的条目. 带上数字前缀参数 N 使用时,会展示变
量 <code>org-todo-keywords</code> 里的第 N 个关键字类型的 TODO 条目. 不带前缀参数使用,
会查找并展示所有 TODO 状态的条目,包括完成和未完成的条目.</dd>
<dt>M-x org-agenda t &#x2013; (org-todo-list)</dt><dd>显示全局(所有) TODO 列表.从所有
agenda 文件(见 [[]])中搜集 TODO 条目并汇总到一个新缓冲区中.新的缓冲区处于
Org Agenda mode(模式),并提供了可以在这个新缓冲区里检查和处理 TODO 条目的命
令(见 [TODO Agenda Commands]). 更多信息可以查看 [Global TODO list].</dd>
<dt>S-M-&lt;RET&gt; &#x2013; (org-insert-todo-heading)</dt><dd>在 <span class="underline">当前</span> TODO 条目下面插入一个新
的 TODO 条目.</dd>
</dl>


<p>
改变 TODO 状态也可以触发(导致)标签改变.更多细节查看选项
<code>org-todo-state-tags-triggers</code> 的文档字符串.
</p>
</div>
</div>
</div>

<div id="outline-container-org22b9067" class="outline-3">
<h3 id="org22b9067"><code>TODO</code> 扩展(TODO Extensions)</h3>
<div class="outline-text-3" id="text-org22b9067">
<p>
工作流和工作分配.
默认情况下, 标记为 TODO 的条目只有两种状态中的一个: TODO 和 DONE. Org mode 允
许你使用更复杂的 TODO 关键字(存储在变量 <code>org-todo-keywords</code> 里)来对 TODO 项目分
类.TODO 关键字系统可以通过特殊的设置在不同的文件里以不同的方式工作.
</p>

<p>
请注意, <span class="underline">标签</span> 是另一种分类方式, 通常用来分类标题但也可以用来分类 TODO 项目.
</p>
</div>

<div id="outline-container-org9374373" class="outline-4">
<h4 id="org9374373">工作流状态(Workflow states)</h4>
<div class="outline-text-4" id="text-org9374373">
<p>
一步步从待办(TODO)到完成(DONE).
</p>

<p>
在处理一个项目的过程中,你可以使用 TODO 关键字来表示不一样的,可能是连续的状态,例
如<sup><a id="fnr.8" class="footref" href="#fn.8">8</a></sup>:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">setq</span> org-todo-keywords
      '((sequence <span style="font-style: italic;">"TODO"</span> <span style="font-style: italic;">"FEEDBACK"</span> <span style="font-style: italic;">"VERIFY"</span> <span style="font-style: italic;">"|"</span> <span style="font-style: italic;">"DONE"</span> <span style="font-style: italic;">"DELEGATED"</span>)))
</pre>
</div>
<p>
竖线将 TODO(待办状态,需要完成)关键字和 DONE(完成状态,不需要进一步操作)分隔开.如果不使用竖
线,最后一个状态会被当作是完成状态.
</p>

<p>
使用上面的设置, <code>C-c C-t</code> 命令会让一个条目的状态从 TODO 到 FEEDBACK, 再到
VERIFY 最后到 DONE 和 DELEGATED 里循环切换. 你也可以使用数字前缀参数来快速选
择特定状态.例如 <code>C-3 C-c C-t</code> 会将状态立即切换成 VERIFY. 或者你也可以使用
<code>S-&lt;RIGTH&gt;</code> 和 <code>S-&lt;LEFT&gt;</code> 来向前或向后遍历状态. 如果你定义了许多关键字,你可以使
用缓冲区补全(见 <a href="#org7a8ca1a">Completion</a>) 或者特殊的一键选择模式(见
<a href="#orgd8eb08a">快速访问 TODO 状态(Fast access to TODO states)</a> 来将这些关键字插入到缓冲区.改
变一个 TODO 状态可以记录一个时间戳, 更多信息查看 [[* Tracking TODO state changes
</p>
</div>
</div>



<div id="outline-container-orgbe90b6a" class="outline-4">
<h4 id="orgbe90b6a"><code>TODO</code> 类型(TODO types)</h4>
<div class="outline-text-4" id="text-orgbe90b6a">
<p>
我做这部分,张三做剩下的.
</p>

<p>
第二个用法是使用 TODO 关键字来表示不同类型的待办事项.
</p>

<p>
例如,你可能想指出这些事项是为了工作或者生活. 或者,当你在一个项目里和其他人一
起工作时,你可能希望通过将人员的名字作为 TODO 关键字,将待办事项直接分配给个人.
</p>

<p>
要使用 TODO 类型,它的设置可能像这样:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">setq</span> org-todo-keywords '((type <span style="font-style: italic;">"Fred"</span> <span style="font-style: italic;">"Sara"</span> <span style="font-style: italic;">"Lucy"</span> <span style="font-style: italic;">"|"</span> <span style="font-style: italic;">"DONE"</span>)))
</pre>
</div>
<p>
这种情况下,不同的关键字不表示状态,而是表示不同类型.所以,正常的工作流可以将任
务分配到个人,之后再标记为已完成.Org mode 通过改变命令 <code>C-c C-t</code> <sup><a id="fnr.9" class="footref" href="#fn.9">9</a></sup>的工作方式来支持这一点.当连续使用这个命令几次时,为
了初次选择任务的正确类型,关键字仍然会在所有名字里循环.但当你一段时间后回到该
待办事项,然后再次使用 <code>C-c C-t</code> 命令时,会将类型从任何名字直接转换成 <code>DONE</code> .使用
前缀参数或补全可以快速选择特定名字.你也可以通过使用带数字前缀参数的 <code>C-c / t</code>
命令来在稀疏树中查看一种特定待办类型的条目.
例如,为了查看 Lucy 要做的所有事情,你可以使用 <code>C-3 C-c / t</code>.
为了从所有的 agenda 文件中搜集所有 Lucy 的事项到单个缓冲区,你也可以在创建全
局待办列表时使用数字前缀参数: <code>C-3 M-x org-agenda t</code>
</p>
</div>
</div>

<div id="outline-container-org0668f14" class="outline-4">
<h4 id="org0668f14">多套关键字(Multiple sets in one file)</h4>
<div class="outline-text-4" id="text-org0668f14">
<p>
所有都混合在一起,但仍然能够找到&#x2026;(Mixing it all, still finding your way.)
</p>

<p>
有时候,你可能想同时使用不同系列的待办关键字.
例如,你可能想使用基本的 TODO/DONE, 但也想有一个修复 bug 的工作流和一个单独的
状态来表示被取消的事项,也就是没有完成,但是也不需要处理的事项.
那你可以这样设置:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">setq</span> org-todo-keywords
      '((sequence <span style="font-style: italic;">"TODO"</span> <span style="font-style: italic;">"|"</span> <span style="font-style: italic;">"DONE"</span>)
        (sequence <span style="font-style: italic;">"REPORT"</span> <span style="font-style: italic;">"BUG"</span> <span style="font-style: italic;">"KNOWNCAUSE"</span> <span style="font-style: italic;">"|"</span> <span style="font-style: italic;">"FIXED"</span>)
        (sequence <span style="font-style: italic;">"|"</span> <span style="font-style: italic;">"CANCELED"</span>)))
</pre>
</div>

<p>
关键字应该都不同,这有助于 Org mode 跟踪给定条目应该使用的子序列.使用这个设
置, <code>C-c C-t</code> 只会在字序列里操作,所以,该命令只会将状态从 DONE 切换到
nothing(普通标题结构) 再到 TODO, 从 FIXED 切换到 nothing 再到 REPORT. 因此,
你需要一个能在开始选择正确序列的机制.除了键入关键字或使用补全(见
<a href="#org7a8ca1a">Completion</a>), 你也可以应用下面这些命令:
</p>
<dl class="org-dl">
<dt>'C-u C-u C-c C-t' 'C-S-&lt;RIGHT&gt;' 'C-S-&lt;LEFT&gt;'</dt><dd>这些快捷键从一个待办的子序
列跳转到下一个. 在上面的例子中, <code>C-u C-u C-c C-t</code> 或 <code>C-S-&lt;RIGHT&gt;</code> 会将状态从
TODO 或 DONE 跳转到 REPORT, 会将第二行中的任意一种状态跳转到 CANCELED. 注
意, <code>C-S-</code> 快捷键绑定与 shift-selection (见 [[Conflicts)冲突了.</dd>
<dt>'S-&lt;RIGTH&gt;' 'S-&lt;LEFT&gt;'</dt><dd><code>S-&lt;LEFT&gt;</code> 和 <code>S-&lt;RIGHT&gt;</code> 会遍历所有子序列中的所有关
键字.例如,在上面例子中, <code>S-&lt;RIGHT&gt;</code> 会从 DONE 切换到 REPORT. 有关
shift-selection 的交互的讨论,参见[[Conflicts.</dd>
</dl>
</div>
</div>

<div id="outline-container-orgd8eb08a" class="outline-4">
<h4 id="orgd8eb08a">快速访问 TODO 状态(Fast access to TODO states)</h4>
<div class="outline-text-4" id="text-orgd8eb08a">
<p>
使用单个字母选择状态.
</p>

<p>
如果你想快速改变一个条目的状态为任意的待办状态,而不是通过循环状态来选择,你可
以设置单字符的快捷键来访问这些状态.这个可以通过在每一个关键字后面的括号中添
加选择字符来完成<sup><a id="fnr.10" class="footref" href="#fn.10">10</a></sup>.
例如:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">setq</span> org-todo-keywords
      '((sequence <span style="font-style: italic;">"TODO(t)"</span> <span style="font-style: italic;">"|"</span> <span style="font-style: italic;">"DONE(d)"</span>)
        (sequence <span style="font-style: italic;">"REPORT(r)"</span> <span style="font-style: italic;">"BUG(b)"</span> <span style="font-style: italic;">"KNOWNCAUSE(k)"</span> <span style="font-style: italic;">"|"</span> <span style="font-style: italic;">"FIXED(f)"</span>)
        (sequence <span style="font-style: italic;">"|"</span> <span style="font-style: italic;">"CANCELED(c)"</span>)))
</pre>
</div>

<p>
如果你按下 <code>C-c C-t</code> 再加上一个选择键,条目就会被切换到那个状态. <code>&lt;SPC&gt;</code> 可以用来
移除一个条目的任意待办关键字<sup><a id="fnr.11" class="footref" href="#fn.11">11</a></sup>.
</p>
</div>
</div>


<div id="outline-container-orgadd2f45" class="outline-4">
<h4 id="orgadd2f45">单文件关键字(Per-file keywords)</h4>
<div class="outline-text-4" id="text-orgadd2f45">
<p>
不同的文件,不同的需求.
</p>

<p>
在不同的文件中使用 TODO 机制的不同方面是很有用的.对于文件内设置,你需要添加特
殊行来为该文件设置关键字和解释.例如,为了设置上面讨论过的两个例子,你需要下面
的一行内容,放在在文件的任何一行的行首:
</p>
<pre class="example">
#+TODO: TODO FEEDBACK VERIFY | DONE CANCELED
</pre>
<p>
你也可以使用 <code>#+SEQ_TODO</code> 来明确解释,它和 <code>#+TODO</code> 作用是相同的或者使用下面这个:
</p>
<pre class="example">
#+TYP_TODO: Fred Sara Lucy Mike | DONE
</pre>
<p>
多套关键字同时使用的设置是这样的:
</p>
<pre class="example">
#+TODO: TODO(t) | DONE(d)
#+TODO: REPORT(r) BUG(b) KNOWNCAUSE(k) | FIXED(f)
#+TODO: | CANCELED(c)
</pre>

<p>
为了确保你使用了正确的关键字,在键入 <code>#+</code> 到缓冲区之后使用 <code>M-&lt;TAB&gt;</code> 来补全它(参
见 <a href="#org7a8ca1a">Completion</a>)
</p>

<p>
记住一点,竖线之后的关键字,或者最后一个关键字(如果没有竖线)必须意味着这个条目
是完成了,不过你可以使用不同的单词.在改变这些行里的设置之后,在光标位于改变的
行上时,使用 <code>C-c C-c</code> 来使 Org mode 知道这些改变<sup><a id="fnr.12" class="footref" href="#fn.12">12</a></sup>.
</p>
</div>
</div>


<div id="outline-container-org397929f" class="outline-4">
<h4 id="org397929f"><code>TODO</code> 关键字的外观(Faces for TODO keywords)</h4>
<div class="outline-text-4" id="text-org397929f">
<p>
高亮显示 TODO 项目的状态.
</p>

<p>
Emacs 把颜色,字体这些与外观相关的属性的概念称为 face.
</p>

<p>
Org mode 会使用特殊的外观高亮显示 TODO 关键字: <code>org-todo</code> 外观用来高亮那些表明条目
仍然需要执行的关键字, <code>org-done</code> 外观会高亮那些表明条目已经完成的关键字.如果你
使用超过两种的不同状态,你可能想要为他们中的部分使用特殊的外观,这可以通过使用
变量 <code>org-todo-keyword-faces</code> 来实现.例如:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">setq</span> org-todo-keyword-faces
      '((<span style="font-style: italic;">"TODO"</span> . org-warning) (<span style="font-style: italic;">"STARTED"</span> . <span style="font-style: italic;">"yellow"</span>)
        (<span style="font-style: italic;">"CANCELED"</span> . (<span style="font-weight: bold;">:foreground</span> <span style="font-style: italic;">"blue"</span> <span style="font-weight: bold;">:weight</span> bold))))
</pre>
</div>

<p>
尽管像上面的 <code>CANCELED</code> 展示的使用一个外观属性的列表应该有效,但这并不总是如此.如
果有必要,定义一个特殊的外观并使用它.一个字符串会被解释成一个颜色. 变量
<code>org-faces-easy-properties</code> 决定颜色是被解释成背景色或前景色.
</p>
</div>
</div>

<div id="outline-container-org74f7925" class="outline-4">
<h4 id="org74f7925"><code>TODO</code> 依赖项(TODO dependencies)</h4>
<div class="outline-text-4" id="text-org74f7925">
<p>
一个任务需要等待其他任务完成的情况.
</p>

<p>
Org 文件层级和列表的结构使得它能很容易定义待办依赖项(TODO 依赖项).
</p>

<p>
通常来讲,在所有待办子任务或下级任务被标记为完成之前,上一层级待办任务不应该被
标记为完成.有时候,子任务中存在逻辑序列,所以在某任务的所有前置任务被标记为完
成之前, 它都不能开始完成. 如果你设置变量 <code>org-enforce-todo-dependencies</code> ,在条
目有用为完成的子待办事项时,Org 会阻止你将条目的状态切换为完成.
此外,如果一个条目拥有 <code>ORDERED</code> 属性,在所有前置待办事项完成之前,该条目的子待办
事项将会被阻塞.这是一个例子:
</p>
<pre class="example">
* TODO Blocked until (two) is done
** DONE one
** TODO two

* Parent
:PROPERTIES:
:ORDERED:  t
:END:
** TODO a
** TODO b, needs to wait for (a)
** TODO c, needs to wait for (a) and (b)
</pre>

<p>
你也可以使用 <code>NOBLOCKING</code> 属性来保证一个条目绝不会被阻塞(见 [[Properties and
Columns):
</p>
<pre class="example">
* This entry is never blocked
:PROPERTIES:
:NOBLOCKING: t
:END:
</pre>

<dl class="org-dl">
<dt>C-c C-x o &#x2013; (org-toggle-ordered-property)</dt><dd>切换当前条目的 <code>ORDERED</code> 属性.使
用属性来设置这个行为是因为这个行为应该作用于当前条目,而不是像标签一样从上
层继承(见<a href="#org0792758">标签(Tags)</a>). 然而,如果你为了更好的可见性,想要使用标签来追踪这个属性的值,请
设置变量 <code>org-track-ordered-property-with-tag</code>.</dd>
<dt>C-u C-u C-u C-c C-t</dt><dd>改变 TODO 状态,无视任何状态阻塞.</dd>
</dl>


<p>
如果你设置了变量 <code>org-agenda-dim-blocked-tasks</code>, 在 agenda 视图里,待办条目不能
被标记为完成,因为未被标记的子条目使用黯淡的字体显示甚至是被隐藏了,详情参见
<a href="#org7296ea5">Agenda Views</a>.
</p>

<p>
你也可以通过使用复选框来阻塞待办状态的改变,参见 <a href="#orgfb4970a">复选框(Checkboxes)</a>. 如果你
色纸了变量 <code>org-enforce-todo-checkbox-dependencies</code>, 拥有未勾选的复选框的条目
将被阻止切换到 DONE.
</p>

<p>
如果你需要更复杂的依赖结构,例如在不同树结构或文件中的条目之间的依赖,请查看
在 <code>org-contrib</code> 仓库里的 <code>org-depend.el</code> 模块.
</p>
</div>
</div>
</div>
<div id="outline-container-org52ddf6e" class="outline-3">
<h3 id="org52ddf6e">进度记录(Progress Logging)</h3>
<div class="outline-text-3" id="text-org52ddf6e">
<p>
进度的日期和笔记.
</p>

<p>
当待办状态改变时,想要记录时间戳和笔记,请带上前缀参数调用命令 <code>org-todo</code>
</p>

<dl class="org-dl">
<dt>C-u C-c C-t &#x2013; (org-todo)</dt><dd><p>
提示输入笔记,并记录待办状态改变的时间.笔记会
作为一个列表被插入到标题之下, 但是也可以被放置到一个 drawer 里,详情参见
<a href="#org410d180">跟踪待办状态改变(Tracking TODO state changes)</a>
</p>

<p>
如果你想更有系统性,Org 可以在你将一个条目标记未完成时或者在你每次改变待办
事项的状态时,自动记录时间戳并有选择性的记录笔记.这个系统是高度可定制的,设
置可以基于每个关键字,并且可以本地化到文件甚至是子树.对于如何为任务计时的信
息,参见 <a href="#orgfd54c4c">计时工作时间(Clocking Work Time)</a>.
</p></dd>
</dl>
</div>

<div id="outline-container-org3214957" class="outline-4">
<h4 id="org3214957">关闭条目(Closing items)</h4>
<div class="outline-text-4" id="text-org3214957">
<p>
什么时候将条目标记未已完成?
</p>

<p>
最基本的自动记录是记录某个待办事项何时标记为完成.可以通过下面代码实现:<sup><a id="fnr.13" class="footref" href="#fn.13">13</a></sup>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">setq</span> org-log-done 'time)
</pre>
</div>
<p>
然后每一次你将一个待办状态(非已完成状态)转换成任意一种已完成状态时,一行
<code>CLOSED: [timestamp]</code> 这样的文本将会插入到标题之下.如果你通过进一步状态循环,将
待办事项状态转换成待办类型,这一行又会被删除. 如果你将条目转换回非待办事项的
状态(例如使用 <code>C-c C-t &lt;SPC&gt;</code>), 这一行也会被删除,除非你把变量
<code>org-closed-keep-when-no-todo</code> 为非 <code>nil</code>. 如果你想随着时间戳一起记录笔记,使
用:<sup><a id="fnr.14" class="footref" href="#fn.14">14</a></sup>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">setq</span> org-log-done 'note)
</pre>
</div>
<p>
使用这个设置,你会被提示输入一条笔记,这条笔记会被存储在条目之下的名为
<code>Closing Note</code> 的标题里.
</p>
</div>
</div>

<div id="outline-container-org410d180" class="outline-4">
<h4 id="org410d180">跟踪待办状态改变(Tracking TODO state changes)</h4>
<div class="outline-text-4" id="text-org410d180">
<p>
状态是什么时候改变的?
</p>

<p>
你可能想要自动跟踪状态发生变化的时间,并记录此更改.你可以只记录时间戳也可以记
录带时间戳的笔记.这些记录会被作为逐项列表的形式插入到标题之下,作为最新的一行
<sup><a id="fnr.15" class="footref" href="#fn.15">15</a></sup>.当记下了很多笔记之后,你可能想
要将这些笔记放到抽屉(见 <a href="#org9fdee05">抽屉 (Drawers)</a>). 配置变量 <code>org-log-into-drawer</code> 来实
现这一行为.对于这些笔记,推荐的抽屉叫做 <code>LOGBOOK</code> <sup><a id="fnr.16" class="footref" href="#fn.16">16</a></sup>.你也可以针对
子树覆盖这个变量的配置,只需通过设置 <code>LOG_INTO_DRAWER</code> 属性.
</p>

<p>
因为对每个状态都记录一条笔记通常来说都太多了,所以 Org mode 希望基于每个关键
字对此进行设置. 这个可以通过在每个关键字后面的括号里添加特殊符号 <code>!</code> (代表时间
戳)或 <code>@</code> (代表带时间戳的笔记)来实现. 例如,使用下面的设置:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">setq</span> org-todo-keywords
      '((sequence <span style="font-style: italic;">"TODO(t)"</span> <span style="font-style: italic;">"WAIT(w@/!)"</span> <span style="font-style: italic;">"|"</span> <span style="font-style: italic;">"DONE(d!)"</span> <span style="font-style: italic;">"CANCELED(c@)"</span>)))
</pre>
</div>
<p>
你不仅定义了全局待办关键字和快速访问键,而且要求在条目标记为 DONE 时记录时间,
在被标记未 WAIT 或 CANCELED 时记录笔记 <sup><a id="fnr.17" class="footref" href="#fn.17">17</a></sup>.
WAIT 的设置更为特殊:斜杠之后的 <code>!</code> 意味着,除了切换到该状态时记录笔记,从该状态切
出时也会记录时间戳,当且仅当切出后的状态没有配置记录日志时.也就是说,当从 WAIT
切换到 DONE 状态时,因为 DONE 配置了只记录时间戳,所以并不会记录 WAIT 切出的时
间.但当从 WAIT 切换回 TODO 时,WAIT 配置里的 <code>/!</code> 会触发一个时间戳记录,尽管
TODO 并没有配置日志的记录.
</p>

<p>
你可以使用完全相同的语法来设置本地缓冲区的日志记录首选项:
</p>
<pre class="example">
#+TODO: TODO(t) WAIT(w@/!) | DONE(d!) CANCELED(c@)
</pre>
<p>
给配置了 <code>@</code> 的待办关键字记录一条不带笔记的时间戳,只需要在提示输入时键入 <code>C-c
    C-c</code> 来插入一条空白笔记.
</p>

<p>
想要定义子树或单个条目的日志设置,在这个条目里定义一个 <code>LOGGING</code> 属性.任何一个
非空的 <code>LOGGING</code> 属性都会将所有日志设置重置为 <code>nil</code>. 然后你可以用 <code>STARTUP</code> 关键字
来为这个特定的条目开启日志记录,例如 <code>lognotedone</code> 或 <code>logrepeat</code>, 或者是添加状态
的具体设置(例如 <code>TODO(!)</code>). 下面是一个例子:
</p>
<pre class="example">
* TODO Log each state with only a time
  :PROPERTIES:
  :LOGGING: TODO(!) WAIT(!) DONE(!) CANCELED(!)
  :END:
* TODO Only log when switching to WAIT, and when repeating
  :PROPERTIES:
  :LOGGING: WAIT(@) logrepeat
  :END:
* TODO No logging at all
  :PROPERTIES:
  :LOGGING: nil
  :END:
</pre>
</div>
</div>

<div id="outline-container-orge6b9563" class="outline-4">
<h4 id="orge6b9563">跟踪你的习惯</h4>
<div class="outline-text-4" id="text-orge6b9563">
<p>
你有多坚持?
</p>

<p>
Org 拥有跟踪一种特殊类别的待办事项的连贯性的功能,这种功能被称作 "habits".要
使用这一功能,你必须通过定制变量 <code>org-modules</code> 启用 <code>habits</code> 模块.
</p>

<p>
一个习惯拥有下列属性:
</p>
<ol class="org-ol">
<li>习惯是一个待办事项,拥有一个待办关键字来表示启用的状态.</li>
<li>属性 <code>STYLE</code> 值要被设置为 <code>habit</code>, 参见 <a href="#orgdb0527e">属性和列(Properties and Columns)</a></li>
<li>待办有一个计划日期,通常带上一个 <code>.+</code> 格式的重复间隔时间.一个 <code>++</code> 格式适合有
时间限制的习惯,例如,必须在周末完成的.或者一个 <code>+</code> 格式用于表示可能有积压工
作(待办事项)的习惯,例如,每周报告.</li>
<li>TODO 还可以使用 <code>.+2d/3d</code> 语法指定最大和最小范围,这表示你希望至多每三天完成
一次任务,最多每两天完成一次.</li>
<li>DONE 状态的状态日志是启用的(参见 <a href="#org410d180">跟踪待办状态改变(Tracking TODO state changes)</a>) ,以便能用连贯的图表展示历史数据.如果没有启用,不是一个错误,但连
续性图表很大程度上就没有意义了.</li>
</ol>


<p>
为了让你了解上述规则在实际操作中是怎样的,这里有一个带历史记录的习惯:
</p>
<pre class="example">
** TODO Shave
   SCHEDULED: &lt;2009-10-17 Sat .+2d/4d&gt;
   :PROPERTIES:
   :STYLE:    habit
   :LAST_REPEAT: [2009-10-19 Mon 00:36]
   :END:
   - State "DONE"       from "TODO"       [2009-10-15 Thu]
   - State "DONE"       from "TODO"       [2009-10-12 Mon]
   - State "DONE"       from "TODO"       [2009-10-10 Sat]
   - State "DONE"       from "TODO"       [2009-10-04 Sun]
   - State "DONE"       from "TODO"       [2009-10-02 Fri]
   - State "DONE"       from "TODO"       [2009-09-29 Tue]
   - State "DONE"       from "TODO"       [2009-09-25 Fri]
   - State "DONE"       from "TODO"       [2009-09-19 Sat]
   - State "DONE"       from "TODO"       [2009-09-16 Wed]
   - State "DONE"       from "TODO"       [2009-09-12 Sat]
</pre>

<p>
这个习惯描述的是:我想最多每2天最少每4天要刮一次胡子(根据给定的 <code>SCHEDULED</code> 日
期和重复间隔).如果今天是15号,这个习惯在至少两天之后的17号首次出现在日程里(参
见 <a href="#org7296ea5">Agenda Views</a>), 并将在四天之后的19号之后过期.
</p>

<p>
habits 真正有用的地方在于它展现出来的连贯性图标,展示你过去完成该任务的一致性.这
个图表展示了过去三个星期的完成任务的每一天,以及每一天的颜色,颜色的含义:
</p>
<dl class="org-dl">
<dt>蓝色</dt><dd>如果当天任务还没有完成.</dd>
<dt>绿色</dt><dd>如果那天任务已被完成.</dd>
<dt>黄色</dt><dd>如果任务明天会过期.</dd>
<dt>红色</dt><dd>如果任务在当天已经过期.</dd>
</dl>


<p>
除了给每一天图上颜色之外,如果当天的任务确实完成了,那天还会被用一个星号标记,
并用感叹号标记来展示当天在图表中的位置.
</p>

<p>
这里有几个配置变量可以用来改变习惯在日程里展示的方式.
</p>
<dl class="org-dl">
<dt>org-habit-graph-column</dt><dd>持续性图表应该被绘制在缓冲区的哪一列.这会覆盖哪
一列的任意文本,所以保持习惯的标题简介明了是一个好主意.</dd>
<dt>org-habit-preceding-days</dt><dd>持续性图表中展示的历史量,以今天之前的天数为单
位.</dd>
<dt>org-habit-following-days</dt><dd>持续性图表中显示的今天之后的天数.</dd>
<dt>org-habit-show-habits-only-for-today</dt><dd>如果是非 <code>nil</code>, 只在今天的日程视图里
展示习惯. 默认值是 <code>t</code>. 在日程视图使用 <code>C-u K</code> 可以开关这个变量.</dd>
</dl>


<p>
最后,日程缓冲区里按 <code>K</code> 会导致习惯暂时被关闭,并不再显示.再次按 <code>K</code> 可以再次显示
出来.如果你有一些习惯只在特定的环境下进行,他们也会受到标签过滤的影响.
</p>
</div>
</div>
</div>

<div id="outline-container-org89f294b" class="outline-3">
<h3 id="org89f294b">优先级(Priorities)</h3>
<div class="outline-text-3" id="text-org89f294b">
<p>
一些比其他事情更重要的事.
</p>

<p>
如果你经常使用 Org mode, 你可能会有足够多的待办事项,使得开始对他们进行优先级
排序变得有意义.优先级排序可以通过将 优先级cookie 放置在 TODO 条目的标题的
TODO 关键字之后实现,就像这样:
</p>
<pre class="example">
*** TODO [#A] Write letter to Sam Fortune
</pre>

<p>
Org mode 默认支持三个优先级: <code>A</code> , <code>B</code> 和 <code>C</code>.其中 <code>A</code> 是最高优先级.一个没有 cookie
的条目被视作其拥有 <code>B</code> 优先级.优先级只会对日程中的排序操作产生影响(参见
<a href="#org3479471">Weekly/daily agenda</a>). 在日程之外,他们对 Org mode 来说没有固有意义.这些
cookies 的外观是由变量 <code>org-priority-faces</code> 定义的,是可以自定义的.
</p>

<p>
你也可以使用数字值表示优先级,例如:
</p>
<pre class="example">
*** TODO [#1] Write letter to Sam Fortune
</pre>

<p>
当使用数字优先级时,你需要将变量 <code>org-priority-highest</code>, <code>org-priority-lowest</code>
和 <code>org-priority-default</code> 设置为整数,这些整数必须严格低于65.
</p>

<p>
优先级可以被附加到任意大纲节点,他们并不需要是待办事项.
</p>

<dl class="org-dl">
<dt>C-c , &#x2013; (org-priority)</dt><dd>设置当前标题的优先级. 这个命令提示输入优先级字
符 <code>A</code> , <code>B</code> 或 <code>C</code>. 当你输入的是 <code>&lt;SPC&gt;</code> 时,如果已有优先级 cookie 设置,会清除该优
先级设置.在 agenda 缓冲区里使用命令 <code>,</code> 也可以 "远程" 改变优先级,参见
<a href="#orgde0d47e">Agenda Commands</a>.</dd>
<dt>S-&lt;UP&gt; &#x2013; (org-priority-up) , S-&lt;DOWN&gt; &#x2013; (org-priority-down)</dt><dd>提高/降低
当前标题的优先级<sup><a id="fnr.18" class="footref" href="#fn.18">18</a></sup>.注意,这
些快捷键也用来修改时间戳(见 <a href="#orgd2651d1">创建时间戳(Creating Timestamps)</a>). 另见
<a href="#orge6e17fa">Conflicts</a> 里关于使用 shift-选择 进行交互的讨论.</dd>
</dl>


<p>
你可以通过设置变量 <code>org-priority-highest</code> , <code>org-priority-lowest</code> 和
<code>org-priority-default</code> 来改变允许的优先级范围. 对于一个单独的缓冲区,你可以这样
设置这些值(最高,最低和默认值,请确保最高优先级在字母表里比最低优先级要更靠前):
</p>
<pre class="example">
#+PRIORITIES: A C B
</pre>
<p>
或者使用数字值:
</p>
<pre class="example">
#+PRIORITIES: 1 10 5
</pre>
</div>
</div>


<div id="outline-container-org1ee36e2" class="outline-3">
<h3 id="org1ee36e2">分解任务(Breaking Down Tasks)</h3>
<div class="outline-text-3" id="text-org1ee36e2">
<p>
拆分任务为便于管理的子任务.
</p>

<p>
通常建议将大的任务拆分成更小的,便于管理的子任务.你可以通过在 TODO 条目下创建
一个大纲树来实现这一点,该树上有详细的子任务<sup><a id="fnr.19" class="footref" href="#fn.19">19</a></sup>. 要对子任务中已经标记为已完成
的部分进行概述,请在标题中的任何位置插入 cookie : <code>[/]</code> 或 <code>[%]</code>. 每次在子任务状态
改变时,或者在 cookie 上按 <code>C-c C-c</code> 时,这些 cookie 都会更新.
例如:
</p>
<pre class="example">
* Organize Party [33%]
** TODO Call people [1/2]
*** TODO Peter
*** DONE Sarah
** TODO Buy food
** DONE Talk to neighbor
</pre>

<p>
如果一个标题树里同时有复选框和待办子树,这个统计 cookie 的意义就不明确了.将属
性 <code>COOKIE_DATA</code> 的值设置为 <code>checkbox</code> 或 <code>todo</code> 来解决这一问题.
</p>

<p>
如果你想让这个统计 cookie 计算子树中任意的待办条目(而不仅仅是直接子树条目),
请配置变量 <code>org-hierarchical-todo-statistics</code> .要为单个子树设置,可将单词
<code>recursive</code> (递归)添加到属性 <code>COOKIE_DATA</code> 的值里.
</p>
<pre class="example">
* Parent capturing statistics [2/20]
:PROPERTIES:
:COOKIE_DATA: todo recursive
:END:
</pre>

<p>
如果你想要一个条目在所有子待办都完成时自动被标记为已完成,你可以使用下面的设
置:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">org-summary-todo</span> (n-done n-not-done)
  <span style="font-style: italic;">"Switch entry to DONE when all subentries are done, to TODO otherwise."</span>
  (<span style="font-weight: bold;">let</span> (org-log-done org-log-states)   <span style="font-weight: bold; font-style: italic;">; </span><span style="font-weight: bold; font-style: italic;">turn off logging</span>
    (org-todo (<span style="font-weight: bold;">if</span> (= n-not-done 0) <span style="font-style: italic;">"DONE"</span> <span style="font-style: italic;">"TODO"</span>))))

(add-hook 'org-after-todo-statistics-hook #'org-summary-todo)
</pre>
</div>

<p>
另一个可选的用法是使用复选框(参见 <a href="#orgfb4970a">复选框(Checkboxes)</a>)来标识大量子任务.
</p>
</div>
</div>


<div id="outline-container-orgfb4970a" class="outline-3">
<h3 id="orgfb4970a">复选框(Checkboxes)</h3>
<div class="outline-text-3" id="text-orgfb4970a">
<p>
勾选清单.
</p>


<p>
每一个普通列表<sup><a id="fnr.20" class="footref" href="#fn.20">20</a></sup> 都可以通过以 <code>[ ]</code> 字符串开头来设置称为一个
复选框.这个特性和 TODO条目(见 <a href="#orgc0e6782"><code>TODO</code> 条目(TODO Items)</a>)类似,但是更为轻量级.复
选框并不包含在全局待办列表里,所以使用他们来将任务拆分为多个简单的步骤非常有用.或
者你也可以在购物清单里使用他们.
</p>

<p>
这里有一个复选框列表的例子:
</p>
<pre class="example">
* TODO Organize party [2/4]
  - [-] call people [1/3]
    - [ ] Peter
    - [X] Sarah
    - [ ] Sam
  - [X] order food
  - [ ] think about what music to play
  - [X] talk to the neighbors

</pre>

<p>
复选框是按层级工作的,所以,如果一个复选框有子项复选框,勾选其中一个子复选框会使
得父项复选框反应是否勾选了子项,勾选部分子项或勾选了全部子项.
</p>

<p>
第一和第二行的 <code>[2/4]</code> 和 <code>[1/3]</code> 是 cookie, 用来表示这个条目里有多少复选框被勾选
了,总共有多少复选框.这可以让你知道有多少复选框剩余,即使你不展开折叠的条目.这
个 cookie 可以放置到标题里也可以放置在一个普通列表条目(的第一行)里.每一个
cookie 的范围涵盖了该 cookie 所在的条目/标题结构上的直接子节点<sup><a id="fnr.21" class="footref" href="#fn.21">21</a></sup>.
</p>

<p>
你必须自己手动键入 <code>[/]</code> 或 <code>[%]</code> cookie. 使用 <code>[/]</code> 你会得到一个 <code>n out of m</code> (几分
之几) 的结果,如上例.使用 <code>[%]</code> 你会得到复选框勾选的百分比的信息(在上例中分别会
是 <code>[50%]</code> 和 <code>[33%]</code>). 在标题中, 这个 cookie 会计算标题之下的复选框和子项的 TODO
状态,并显示最近变化的一类的状态.将 <code>COOKIE_DATA</code> 属性设置为 <code>checkbox</code> 或 <code>todo</code> 可
以解决这一问题.
</p>

<p>
如果当前标题有一个 <code>ORDERED</code> 属性, 复选框则必须按照顺序勾选,并在你试图勾选一个
前面仍有未勾选的条目的复选框时抛出一个错误.
</p>

<p>
下面这些命令适用于复选框:
</p>
<dl class="org-dl">
<dt>C-c C-c &#x2013;(org-toggle-checkbox)</dt><dd>切换复选框状态,或者带上前缀参数使用,切换
光标处复选框的存在状态.加上一个前缀参数,会添加一个空的复选框,或移除当前复选
框<sup><a id="fnr.22" class="footref" href="#fn.22">22</a></sup>. 加上两个前缀参数使用,会将条目设置为 <code>[-]</code> ,这被视为中间状态.</dd>
<dt>C-c C-x C-b &#x2013; (org-toggle-checkbox)</dt><dd>切换复选框状态,或者带上前缀参数使用,切
换光标出复选框的存在状态.带上双前缀参数使用,会将其设置为 <code>[-]</code> 的中间状态.
<ul class="org-ul">
<li>如果有选中区域,切换区域中第一个复选框的状态,并将剩下的复选框设置为和第一
个一样的状态.加上单前缀参数使用,为区域里所有条目添加或删除复选框.</li>
<li>如果光标在标题上,会切换这个标题和下个标题之间的区域里复选框的状态,而不是
整个子树范围.</li>
<li>如果没有选中区域,仅仅切换光标处的复选框.</li>
</ul></dd>

<dt>C-c C-x C-r &#x2013; (org-toggle-radio-button)</dt><dd>将光标处的条目的当作单选按钮来
切换复选框状态:当复选框状态切换时,同级的其他复选框都会被关闭(取消勾选).使用
通用的前缀参数,会切换复选框的存在状态.使用双前缀参数,会切换到 <code>[-]</code> 状态.
<code>C-c C-c</code> 也能被视为复选框的单选按钮,只需在列表之前设置 <code>#+ATTR_ORG: :radio t</code>
或者调用 <code>M-x org-list-checkbox-radio-mode</code> 来激活这个副模式.</dd>
<dt>M-S-&lt;RET&gt; &#x2013; (org-insert-todo-heading)</dt><dd>插入一个新的带复选框的条目,这只在
光标处已经有一个简单列表条目时生效(见 <a href="#org7083e39">简单列表(Plain Lists)</a>)</dd>
<dt>C-c C-x o &#x2013; (org-toggle-ordered-property)</dt><dd>切换条目的 <code>ORDERED</code> 属性,如果
复选框必须按顺序勾选,请打开该选项.使用属性来设置这一行为是因为它应该只针对
当前条目,而不是像标签一样可以继承.然而,如果你为了更好的可见性,想用标签来跟
踪这个属性的值,请自定义 <code>org-track-ordered-property-with-tag</code>.</dd>
<dt>C-c # &#x2013; (org-update-statistics-cookies)</dt><dd>更新当前大纲条目的统计
cookie. 当加上 <code>C-u</code> 前缀调用,会更新整个文件的统计 cookie. 如果你使用 <code>C-c C-c</code>
切换复选框状态或者使用 <code>M-S-&lt;RET&gt;</code> 创建新复选框,复选框的统计 cookie 会自动更
新. TODO 的统计 cookie 会在 TODO 状态改变时更新.如果你手动添加或改变复选框/
条目,使用这个命令来恢复统计状态的同步.</dd>
</dl>
</div>
</div>
</div>

<div id="outline-container-org0792758" class="outline-2">
<h2 id="org0792758"><span class="done DONE">DONE</span> 标签(Tags)</h2>
<div class="outline-text-2" id="text-org0792758">
<p>
实现标签和上下的信息互相关联的一个很好的方法是为标题指定 <span class="underline">标签</span>.Org mode 广泛支持
标签.
每一个标题都可以包含一个标签列表,他们出现在标题的末尾.标签通常包含字母,数字, <code>_</code>
和 <code>@</code>.标签前面和后面必须有一个冒号,例如: <code>:work:</code>. 多个标签可以这样指定:
<code>:work:urgent:</code>. 标签默认用粗体显示,颜色和标题一行.你可以使用变量 <code>org-tag-faces</code> 为
特殊的标签指定特殊外观,其方式与 TODO 关键字的方式大致相同,详情可以参见
<a href="#org397929f"><code>TODO</code> 关键字的外观(Faces for TODO keywords)</a>).
</p>
</div>

<div id="outline-container-org46b40cb" class="outline-3">
<h3 id="org46b40cb">标签继承(Tag Inheritance)</h3>
<div class="outline-text-3" id="text-org46b40cb">
<p>
标签使用大纲的树结构.
</p>

<p>
如果一个标题有一个特定标签,其所有的子标题也继承这个标签.例如,在下面这个列表中:
</p>
<pre class="example">
* Meeting with the French group      :work:
** Summary by Frank                  :boss:notes:
*** TODO Prepare slides for him      :action:
</pre>
<p>
最后一个标题有这些标签 <code>work</code>, <code>boss</code>, <code>notes</code> 和 <code>action</code>, 即使最后一个标题并没有显式标
识这些标签. 你还可以设置文件中所有条目都应该继承的标签,就像这些标签时定义在围绕
整个文件的假定层级零里一样.就像下面这样<sup><a id="fnr.23" class="footref" href="#fn.23">23</a></sup>:
</p>
<pre class="example">
#+FILETAGS: :Peter:Boss:Secret:
</pre>

<p>
要限制特定标签的标签继承,或彻底禁用它的继承功能,使用变量 <code>org-use-tag-inheritance</code>
和 <code>org-tags-exclude-from-inheritance</code>.
</p>

<p>
在标签继承开启的情况下,当一个标题匹配标签搜索时(指简单匹配格式),所有的子树也会被
匹配<sup><a id="fnr.24" class="footref" href="#fn.24">24</a></sup>. 此时匹配的列表会变得非常长. 如果你只想看到子树里的第一个标签匹配结
果,请配置变量 <code>org-tags-match-list-sublevels</code> (并不推荐这样做).
</p>

<p>
在 agenda 搜索试图匹配 <code>tags</code> 或 <code>tags-todo</code> 类型的标记时,标签继承也是相应的. 对于其
他的 agenda 类型, <code>org-use-tag-inheritance</code> 没有效果.不过,你可能希望在 agenda 里正
确设置标签,以便标签过滤能很好处理继承的标签. 设置 <code>org-agenda-use-tag-inheritance</code>
变量来控制这一行为: 默认值包括所有 agenda 类型,但将其设置为 <code>nil</code> 可以加快 agenda
的生成.
</p>
</div>
</div>


<div id="outline-container-org75a8818" class="outline-3">
<h3 id="org75a8818">设置标签(Setting Tags)</h3>
<div class="outline-text-3" id="text-org75a8818">
<p>
如何给标题指定标签.
</p>

<p>
标签可以简单的键入标题末尾的缓冲区中.在冒号之后,使用 <code>M-&lt;TAB&gt;</code> 提供标签的补全.这还
有用于插入标签的特殊命令:
</p>
<dl class="org-dl">
<dt>C-c C-q &#x2013; (org-set-tags-command)</dt><dd>为当前标题输入新标签. Org mode 也提供了补
全或特殊的单快捷键来设置标签,见下文. 在按了 <code>&lt;RET&gt;</code> 之后,标签会被插入并对齐到
<code>org-tags-column</code> 设置的列. 带上 <code>C-u</code> 前缀一起调用,当前缓冲区的所有标签都会对齐到
该列,只为看起来更好看.标签在升级,降级和 TODO 状态改变时会自动进行重对齐(参见
<a href="#orgc358534"><code>TODO</code> 基础(TODO Basics)</a>)</dd>
<dt>C-c C-c &#x2013; (org-set-tags-command)</dt><dd>当光标在标签上时,和 <code>C-c C-q</code> 一样.</dd>
</dl>

<p>
Org 支持基于标签列表的标签插入.默认情况下,该列表是动态构建的,包括了当前缓冲区中
使用的所有标签<sup><a id="fnr.25" class="footref" href="#fn.25">25</a></sup>.你
也可以使用变量 <code>org-tag-alist</code> 在全局指定一个标签的硬列表.最后,你可以使用 <code>TAGS</code> 关
键字对给定的文件设置默认标签,就像这样:
</p>
<pre class="example">
#+TAGS: @work @home @tennisclub
#+TAGS: laptop car pc sailboat
</pre>
<p>
如果你已经使用 <code>org-tag-alist</code> 全局定义了一组首选的标签,但是想要在特定的文件里使用
动态的标签列表,请在该文件里添加一个空白的 <code>TAGS</code> 关键字:
</p>
<pre class="example">
#+TAGS:
</pre>

<p>
如果你希望在每个文件中使用一组首选的标签,除了在每个文件中使用 <code>TAGS</code> 关键字定义之
外,还可以通过 <code>org-tag-persistent-alist</code> 变量指定一个标签列表. 你可以通过在每个文
件中添 <code>STARTUP</code> 关键字来关闭这一功能:
</p>
<pre class="example">
#+STARTUP: noptag
</pre>

<p>
默认情况下, Org mode 使用标准的 minibuffer 补全功能来输入标签.然而,Org mode 也实
现了另一个更快的标签选择方式,叫做 <span class="underline">快速标签选择(fast tag selection)</span>. 这个功能允许
你只按一次按键即可选择和取消选择标签.为了使其正常工作,你应该为你最常使用的标签分
配独一无二的字母.你可以通过在 Emacs init 文件里配置变量 <code>org-tag-alist</code> 来全局实现
这一功能.例如,你可能会发现需要用 <code>@home</code> 标记不同文件中的许多条目.这种情况下,可以
设置如下内容:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">setq</span> org-tag-alist '((<span style="font-style: italic;">"@work"</span> . ?w) (<span style="font-style: italic;">"@home"</span> . ?h) (<span style="font-style: italic;">"laptop"</span> . ?l)))
</pre>
</div>

<p>
如果该标签只与你正在处理的文件有关,那么你可以将 <code>TAGS</code> 关键字设置为这样:
</p>
<pre class="example">
#+TAGS: @work(w)  @home(h)  @tennisclub(t)  laptop(l)  pc(p)
</pre>

<p>
标签界面会在弹出的界面中显示可用的标签.如果你想在某个特定的标签之后插入新的一行,
可以在标签列表里插入 <code>\n</code>:
</p>
<pre class="example">
#+TAGS: @work(w) @home(h) @tennisclub(t) \n laptop(l) pc(p)
</pre>
<p>
或者将他们写成两行:
</p>
<pre class="example">
#+TAGS: @work(w)  @home(h)  @tennisclub(t)
#+TAGS: laptop(l)  pc(p)
</pre>

<p>
你也可以用大括号将互斥的标签组合在一起:
</p>
<pre class="example">
#+TAGS: { @work(w)  @home(h)  @tennisclub(t) }  laptop(l)  pc(p)
</pre>
<p>
这表明在 <code>@work</code> , <code>@home</code> 和 <code>@tennisclub</code> 里最多只有一个被选中.允许存在多个这样的组
合.
</p>

<p>
不要忘记将光标放置在这些行上按 <code>C-c C-c</code> 来让这些改变生效.
</p>

<p>
要在变量 <code>org-tags-alist</code> 里设置这些互斥的组合,你必须使用虚拟标签 <code>:startgroup</code> 和
<code>:endgroup</code> 而不是大括号. 类似的,你可以使用 <code>:newline</code> 来表示断行. 上面的例子可以通
过下面的配置来全局设置:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">setq</span> org-tag-alist '((<span style="font-weight: bold;">:startgroup</span> . nil)
                      (<span style="font-style: italic;">"@work"</span> . ?w) (<span style="font-style: italic;">"@home"</span> . ?h)
                      (<span style="font-style: italic;">"@tennisclub"</span> . ?t)
                      (<span style="font-weight: bold;">:endgroup</span> . nil)
                      (<span style="font-style: italic;">"laptop"</span> . ?l) (<span style="font-style: italic;">"pc"</span> . ?p)))
</pre>
</div>
<p>
如果至少有一个标签有选择键,那么按 <code>C-c C-c</code> 会自动给你展示一个特殊的界面,列出了继
承的标签,当前标题的标签,和所有有效的标签列表以及对应快捷键<sup><a id="fnr.26" class="footref" href="#fn.26">26</a></sup>.
</p>

<p>
按分配给标签的快捷键会在当前行的标签列表里删除或添加他们.选择互斥标签组合中的一
个标签会移除组合里的其他任何标签.
</p>

<p>
在这个特殊界面中,你可以使用下列特殊的快捷键:
</p>
<dl class="org-dl">
<dt>&lt;TAB&gt;</dt><dd>在 minibuffer 里键入标签,即使这个标签并不在预定义的列表里.你可以基于
缓冲区中出现的所有标签和 <code>org-tag-alist</code> , <code>org-tag-persistent-alist</code> 里全局预定义
的标签进行补全. 你也可以添加多个标签:只需将他们用逗号隔开.</dd>
<dt>&lt;SPC&gt;</dt><dd>清除该行的所有标签.</dd>
<dt>&lt;RET&gt;</dt><dd>接受更改的设置.</dd>
<dt>C-g</dt><dd>不保存更改并退出.</dd>
<dt>q</dt><dd>如果 <code>q</code> 没有被分配给一个标签(快捷键), 它会像 <code>C-g</code> 一样终止更改.</dd>
<dt>!</dt><dd>关闭互斥标签的组合.使用这个(作为例外)来从这个互斥组合里分配多个标签.</dd>
<dt>C-c</dt><dd>开关在下一个更改之后的 "自动退出"功能(见下文).如果你正在使用专家模式
(expert mode),第一个 <code>C-c</code> 将会显示选择窗口.</dd>
</dl>

<p>
快速选择可以让你使用很少的按键就能为标题分配标签.使用上面的设置,你可以清空当前标
签,并设置 <code>@home</code> , <code>laptop</code> 和 <code>pc</code> 标签,只需使用下面的按键: <code>C-c C-c &lt;SPC&gt; h l p
&lt;RET&gt;</code>. 从 <code>@home</code> 切换到 <code>@work</code> 可用 <code>C-c C-c w &lt;RET&gt;</code> 或者 <code>C-c C-c C-c w</code> 完成. 添加
一个未预定义的标签 <code>sarah</code> 可以用 <code>C-c C-c &lt;TAB&gt; s a r a h &lt;RET&gt;</code> 完成.
</p>

<p>
如果你发现大多数时候只需要一个键就可以修改标签列表,请设置变量
<code>org-fast-tag-selection-single-key</code>. 然后你就不再需要按 <code>&lt;RET&gt;</code> 来退出快速标签选择了,它
会在第一个改变之后自己退出. 如果你偶尔需要更多快捷键, 按 <code>C-c</code> 来关闭当前标签选择
的自动退出功能(实际上:用 <code>C-c C-c C-c</code> 而不是 <code>C-c C-c</code> 来打开标签选择).如果你将变量
设置为了 <code>expert</code> 值,则单键标签选择的特殊窗口甚至都不会出现,只有在按额外的 <code>C-c</code> 时
才会显示.
</p>
</div>
</div>


<div id="outline-container-org1cf6710" class="outline-3">
<h3 id="org1cf6710">标签层级(Tag Hierarchy)</h3>
<div class="outline-text-3" id="text-org1cf6710">
<p>
创建标签的层级.
</p>

<p>
标签可以在层级结构中定义. 一个标签可以定义为一组其他标签的 <span class="underline">组标签</span>. 组标签可以视
为其所在标签集的 "广义术语"(大概是同义词的意思).定义多个组标签并嵌套它们会创造一
个标签的层级结构.
</p>

<p>
一个用例就是创建标签的分类法,可用于对文档或文档集中的节点进行分类.
</p>

<p>
当你搜索一个组标签时,结果会返回组及其子组中所有成员的匹配项. 在 agenda 视图里,按
组标签进行过滤会显示或隐藏至少一个由组成员或其子组标记的标题. 这使得标签搜索和过
滤更加灵活.
</p>

<p>
你可以用括号并在组标签及其相关标签之间插入冒号来设置组标签.请注意,所有的空格都是
必填的,以便 Org 能正确解析此行:
</p>
<pre class="example">
#+TAGS: [ GTD : Control Persp ]
</pre>
<p>
在这个例子里, <code>GTD</code> 是组标签,它与另外两个标签相关联: <code>Control</code> , <code>Persp</code>. 将 <code>Control</code>
和 <code>Persp</code> 定义为组标签会创建标签的层级:
</p>
<pre class="example">
#+TAGS: [ Control : Context Task ]
#+TAGS: [ Persp : Vision Goal AOF Project ]
</pre>
<p>
这个可以视为概念上的标签的层级:
</p>
<pre class="example">
• ‘GTD’
     • ‘Persp’
	  • ‘Vision’
	  • ‘Goal’
	  • ‘AOF’
	  • ‘Project’
     • ‘Control’
	  • ‘Context’
	  • ‘Task’
</pre>

<p>
当你直接设置 <code>org-tag-alist</code> 变量的时候,你可以直接使用 <code>:startgtouptag</code> , <code>:grouptags</code>
和 <code>:endgrouptag</code> 关键字:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">setq</span> org-tag-alist '((<span style="font-weight: bold;">:startgrouptag</span>)
                      (<span style="font-style: italic;">"GTD"</span>)
                      (<span style="font-weight: bold;">:grouptags</span>)
                      (<span style="font-style: italic;">"Control"</span>)
                      (<span style="font-style: italic;">"Persp"</span>)
                      (<span style="font-weight: bold;">:endgrouptag</span>)
                      (<span style="font-weight: bold;">:startgrouptag</span>)
                      (<span style="font-style: italic;">"Control"</span>)
                      (<span style="font-weight: bold;">:grouptags</span>)
                      (<span style="font-style: italic;">"Context"</span>)
                      (<span style="font-style: italic;">"Task"</span>)
                      (<span style="font-weight: bold;">:endgrouptag</span>)))
</pre>
</div>

<p>
如果使用将互斥组标签分组的相同组语法,则组中的标签可以是互斥的,使用花括号:
</p>
<pre class="example">
#+TAGS: { Context : @Home @Work @Call }
</pre>

<p>
当设置 <code>org-tag-alist</code> 时, 你可以使用 <code>:startgroup</code> 和 <code>:endgroup</code> 而不是
<code>:startgrouptag</code> 和 <code>:endgrouptag</code> 来让标签互斥.
</p>

<p>
此外,一个组标签的成员可以是正则表达式,从而创造一种更动态的,基于规则的标签结构(请
参见 <a href="#org3d187b4">正则表达式(Regular Expressions)</a>). 组里的正则表达式必须在花括号内指定.下面
是一个扩展实例:
</p>
<pre class="example">
#+TAGS: [ Vision : {V@.+} ]
#+TAGS: [ Goal : {G@.+} ]
#+TAGS: [ AOF : {AOF@.+} ]
#+TAGS: [ Project : {P@.+} ]
</pre>
<p>
现在搜索标签 <code>Project</code> 会列出所有标签,包括 <code>P@.+</code> 的正则表达式匹配项. <code>Vision</code> ,
<code>Goal</code> 和 <code>AOF</code> 的标签搜索也是类似. 例如,这对一个使用公共项目标识符的项目来说是很好
的,比方说 <code>P@2014_OrgTags</code>.
</p>

<p>
如果你项暂时忽视组标签,使用 <code>org-toggle-tags-groups</code> 命令可以开关组标签的支持,命令
绑定到 <code>C-c C-x q</code> 快捷键. 如果你像完全禁用组标签,将 <code>org-group-tags</code> 设置为 <code>nil</code>.
</p>
</div>
</div>


<div id="outline-container-org4c0e9a9" class="outline-3">
<h3 id="org4c0e9a9">标签搜索(Tag Searches)</h3>
<div class="outline-text-3" id="text-org4c0e9a9">
<p>
查找标签的组合.
</p>

<p>
一旦一个标签系统被设置完成,则该系统可以用来搜集相关信息到特殊列表中.
</p>

<dl class="org-dl">
<dt><code>C-c / m</code> or <code>C-c \</code> &#x2013; (org-match-sparse-tree)</dt><dd>创建一个所有标签题都匹配标签搜
索的稀疏树.带上 <code>C-u</code> 前缀参数,会忽视非待办标题.</dd>
<dt>M-x org-agenda m &#x2013; (org-tags-view)</dt><dd>从所有 agenda 文件中创建一个标签匹配的
全局列表. 参见 <a href="#org74ac745">匹配标签和属性(Matching tags and properties)</a>.</dd>
<dt>M-x org-agenda M &#x2013; (org-tags-view)</dt><dd>从所有 agenda 文件中创建一个标签匹配的
全局列表,但只检查 TODO 条目,并强制检查子条目(参见选项
<code>org-tags-match-list-sublevels</code> ).</dd>
</dl>


<p>
这些命令都会提示你输入匹配字符串,该字符串允许基本的布尔逻辑,如
<code>+boss+urgent-project1</code>, 用来查找带有标签 <code>boss</code> 和 <code>urgent</code> 但不带标签 <code>project1</code> 的条
目;或者 <code>Kathy|Sally</code>, 用来查找带有标签 <code>Kathy</code> 或者带有标签 <code>Sally</code> 的条目. 搜索字符
串的全部语法是非常丰富的,并且其还允许匹配 TODO 关键字,条目层级和属性.关于许多示
例的完成描述,请参见 <a href="#org74ac745">匹配标签和属性(Matching tags and properties)</a>.
</p>
</div>
</div>
</div>

<div id="outline-container-orgdb0527e" class="outline-2">
<h2 id="orgdb0527e"><span class="done DONE">DONE</span> 属性和列(Properties and Columns)</h2>
<div class="outline-text-2" id="text-orgdb0527e">
<p>
<span class="underline">属性</span> 是一个与条目关联的 <span class="underline">键值对</span>. 属性可以设置为与单个条目关联,与一个树结构中的所
有条目关联或者与整个缓冲区相关联.
</p>

<p>
Org mode 里有两个属性的主要运用.
</p>

<p>
第一种,属性就像标签一样,但是带有一个值.想象一下,你需要维护一个文件,在里面你要记
录 bug 并计划软件的发布.不使用 <code>release_1</code> , <code>release_2</code> 这样的标签,你可以使用一个属
性,比如 <code>Release</code> ,在不同的子树中有不同的值,比如 <code>1.0</code> 或 <code>2.0</code>.
</p>

<p>
第二种,你可以使用属性在 Org 缓冲区中实现(非常基本的)数据库功能.想象一下,跟踪你的
音乐CD, 其属性可能是专辑,艺术家,发行日期,曲目数量等等.
</p>

<p>
可以在列视图中方便地编辑和查看属性(参见 <a href="#orgc1b7a76">列视图(Column View)</a>).
</p>
</div>

<div id="outline-container-orga6e491a" class="outline-3">
<h3 id="orga6e491a">属性语法(Property Syntax)</h3>
<div class="outline-text-3" id="text-orga6e491a">
<p>
属性是如何拼写.
</p>

<p>
属性是键值对. 当他们与一个条目或一个树结构关联时,需要将他们插入到一个名为
<code>PROPERTIES</code> 的特殊抽屉里(见 <a href="#org9fdee05">抽屉 (Drawers)</a>), 该抽屉必须位于标题的正下方,如果适用,还
需要位于标题的规划行(参见 <a href="#org1e3c531">截止时间和日程安排(Deadlines and Scheduling)</a>)的下方.每
一个属性都在一行中指定,首先是由冒号包围的 <span class="underline">键</span> ,后面跟着是 <span class="underline">值</span>. <span class="underline">键</span> 是大小写敏感的.
这里是一个例子:
</p>
<pre class="example">
* CD collection
** Classic
*** Goldberg Variations
    :PROPERTIES:
    :Title:     Goldberg Variations
    :Composer:  J.S. Bach
    :Artist:    Glenn Gould
    :Publisher: Deutsche Grammophon
    :NDisks:    1
    :END:
</pre>

<p>
用这种方式设置的属性值,要么与单个条目关联,要么与该条目的子树相关联,这取决于变量
<code>org-use-property-inheritance</code> 的值, 请参见 <a href="#org0a74dd0">属性继承(Property Inheritance)</a>.
</p>

<p>
你可以通过设置属性 <code>Xyz_ALL</code> 来定义特定属性 <code>Xyz</code> 的允许值. 这个特殊属性是继承的,所
以如果你在级别1的条目设置它,它将应用到整个树结构.当定义了允许值时,设置相应的属性
变得更容易,也不太容易出现键入错误. 对于 CD 搜集的例子,我们可以预定义发布者和盒子
里的磁盘数:
</p>
<pre class="example">
* CD collection
  :PROPERTIES:
  :NDisks_ALL:  1 2 3 4
  :Publisher_ALL: "Deutsche Grammophon" Philips EMI
  :END:
</pre>

<p>
属性可以在缓冲区层级插入. 意思是他们可以应用在第一个标题之前,并被文件里所有条目
继承.定义在第一个标题之前的属性块需要放置在缓冲区顶部,其上面只允许存在注释.
</p>

<p>
属性也可以用下面的行定义:
</p>
<pre class="example">
#+PROPERTY: NDisks_ALL 1 2 3 4
</pre>

<p>
如果你想添加值到已有属性,请在属性名后面加上 <code>+</code>. 下面的例子的结果是属性 <code>var</code> 拥有值
<code>foo=1 bar=2</code>.
</p>
<pre class="example">
#+PROPERTY: var  foo=1
#+PROPERTY: var+ bar=2
</pre>

<p>
添加值到继承的属性也是可行的.下面例子的结果是 <code>Goldberg Variations</code> 子树下的属性
<code>Genres</code> 拥有属性值 <code>Classic Baroque</code>.
</p>
<pre class="example">
* CD collection
** Classic
    :PROPERTIES:
    :Genres: Classic
    :END:
*** Goldberg Variations
    :PROPERTIES:
    :Title:     Goldberg Variations
    :Composer:  J.S. Bach
    :Artist:    Glenn Gould
    :Publisher: Deutsche Grammophon
    :NDisks:    1
    :Genres+:   Baroque
    :END:
</pre>

<p>
请注意,一个属性只能在每个抽屉里只能拥有一个条目.就是不能出现下面这种:
</p>
<pre class="example">
* head1
:PROPERTIES:
:Title: title
:Title: tittt
:END:
</pre>

<p>
属性值可以通过全局变量 <code>org-global-properties</code> 设置,并可以在所有Org 文件中被所有条
目继承.
</p>

<p>
下面的命令有助于处理属性:
</p>
<dl class="org-dl">
<dt>M-&lt;TAB&gt; &#x2013; (pcomplete)</dt><dd>在一行的初始冒号之后,补全属性 <span class="underline">键</span>.当前文件里使用的所
有键都被提供为可能的补全.</dd>
<dt>C-c C-x p &#x2013; (org-set-property)</dt><dd>设置一个属性. 这个命令会提示你输入属性名和
属性值. 若有必要,属性抽屉也会被创建.</dd>
<dt>C-u M-x org-insert-drawer</dt><dd>在当前条目插入一个属性抽屉.抽屉会在条目的前部分插
入,但会在带有计划信息(如截止时间)的行之后.如果在第一个标题之前使用,则抽屉会插
入到文件的顶部,且在任何可能的评论之后.</dd>
<dt>C-c C-c &#x2013; (org-property-action)</dt><dd>当光标在属性抽屉里时,它会执行属性命令.</dd>
<dt>C-c C-c s &#x2013; (org-set-property)</dt><dd>在当前条目设置一个属性.属性(键)和值都可以使
用补全进行插入.当光标位于属性抽屉里时有效.</dd>
<dt>S-&lt;RIGTH&gt; &#x2013; (org-property-next-allowed-values), S-&lt;LEFT&gt; &#x2013; (org-property-previous-allowed-value)</dt><dd>切换光标处的属性值到上一个/下一个允许
值.</dd>
<dt>C-c C-c d &#x2013; (org-delete-property)</dt><dd>从当前条目删除一个属性.</dd>
<dt>C-c C-c D &#x2013; (org-delete-property-globally)</dt><dd>从当前文件的所有条目中全局地删
除一个属性.</dd>
<dt>C-c C-c c &#x2013; (org-compute-property-at-point)</dt><dd>使用最近的列公式定义里的操作符
和范围计算光标处的属性.</dd>
</dl>
</div>
</div>

<div id="outline-container-orgd882f8c" class="outline-3">
<h3 id="orgd882f8c">特殊属性(Special Properties)</h3>
<div class="outline-text-3" id="text-orgd882f8c">
<p>
使用其他的 Org mode 功能.
</p>

<p>
特殊的属性提供了对 Org mode 功能的另一种访问方式,如前面所述的 TODO 状态或者条目
的优先级.此接口的存在让你可以在列视图(参见 <a href="#orgc1b7a76">列视图(Column View)</a>)中包含这些状态,
或者在查询中使用它们.下面的属性名是特殊的,不应用作属性抽屉中的 <span class="underline">键</span>:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">属性名</th>
<th scope="col" class="org-left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">ALLTAGS</td>
<td class="org-left">所有标签,包括继承的标签.</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">BLOCKED</td>
<td class="org-left">如果当前任务被子节点或兄弟节点阻塞,则为 <code>t</code></td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">CATEGORY</td>
<td class="org-left">条目的类别.</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">CLOCKSUM</td>
<td class="org-left">子树的 CLOCK 间隔(时间)总和.必须先运行  <code>org-clock-sum</code> 来计算当前缓冲区中的值.</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">CLOCKSUM_T</td>
<td class="org-left">子树中今天的 CLOCK 间隔(时间)总和. 必须先运行  <code>org-clock-sum</code> 来计算当前缓冲区中的值.</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">CLOSED</td>
<td class="org-left">条目是什么时候关闭的?</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">DEADLINE</td>
<td class="org-left">截止日期的时间戳.</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">FILE</td>
<td class="org-left">条目所在的文件名.</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">ITEM</td>
<td class="org-left">条目的标题.</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">PRIORITY</td>
<td class="org-left">条目的优先级, 一个单字符的字符串.</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">SCHEDULED</td>
<td class="org-left">计划的时间戳.</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">TAGS</td>
<td class="org-left">直接定义在标题中的标签.</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">TIMESTAMP</td>
<td class="org-left">条目中第一个无关键字时间戳.</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">TIMESTAMP_IA</td>
<td class="org-left">条目中第一个未激活的时间戳.</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">TODO</td>
<td class="org-left">条目的 TODO 关键字.</td>
</tr>
</tbody>
</table>
</div>
</div>




<div id="outline-container-org20a9924" class="outline-3">
<h3 id="org20a9924">属性搜索(Property Searches)</h3>
<div class="outline-text-3" id="text-org20a9924">
<p>
匹配属性值.
</p>

<p>
要创建稀疏树和基于属性选择的特殊列表,可以使用与标签搜索相同的命令.可参考标签搜索
的内容:<a href="#org4c0e9a9">标签搜索(Tag Searches)</a> 对照使用.
</p>

<dl class="org-dl">
<dt>C-c / m 或 C-c \ &#x2013; (org-match-sparse-tree)</dt><dd>创建一个所有匹配条目的稀疏树.加
上前缀参数 <code>C-u</code> 使用,会忽视不是 TODO 的标题.</dd>
<dt>M-x org-agenda m &#x2013; (org-tags-view)</dt><dd>从所有 agenda 文件中创建标签/属性匹配的
全局列表.</dd>
<dt>M-x org-agenda M &#x2013; (org-tags-view)</dt><dd>从所有 agenda 文件中创建标签匹配的全局
列表,但只检查 TODO 条目,并强制检查子条目(参见选项 <code>org-tags-match-list-sublevels</code>).</dd>
</dl>


<p>
搜索字符串的语法在 <a href="#org74ac745">匹配标签和属性(Matching tags and properties)</a> 里有具体描述.
</p>

<p>
还有一个特殊的命令,用于基于单个属性创建稀疏树.
</p>

<dl class="org-dl">
<dt>C-c / p</dt><dd>基于属性的值创建稀疏树.该命令首先会提示输入属性的名字,然后是属性值.这
会创建一个稀疏树,其中包含所有用给定值定义给定属性的条目.如果你用花括号将值包裹,那
它将会被解释成一个正则表达式,并用它取匹配属性值(参见 <a href="#org3d187b4">正则表达式(Regular Expressions)</a>).</dd>
</dl>
</div>
</div>



<div id="outline-container-org0a74dd0" class="outline-3">
<h3 id="org0a74dd0">属性继承(Property Inheritance)</h3>
<div class="outline-text-3" id="text-org0a74dd0">
<p>
向下传递值.
</p>

<p>
Org 文档的大纲结构适合于属性的继承模型:如果树的父级具有特定属性,则子级可继承该属
性. Org mode 默认并不开启属性继承,因为它会显著降低属性搜索的速度,而且通常是不需
要的. 然而,如果你发现继承有用,你可以通过设置变量 <code>org-use-property-inheritance</code> 来
开启属性继承.可以将其设置为 <code>t</code> 来让所有属性都从父级继承,或设置为应该继承的属性列
表,或设置为匹配继承属性的正则表达式. 如果某个属性的值为 <code>nil</code> 这将被解释为该属性的
显式"未定义",因此继承搜索将在该值处停止,并返回 <code>nil</code>. 也就是说该属性会被认为是未定
义,不会参与继承过程,可以通过设置某个条目的属性为 <code>nil</code> 表示该条目并不继承该属性.
</p>

<p>
Org mode 有几个属性的继承是硬核编码的,至少对于使用他们的特殊运用是这样的:
</p>
<dl class="org-dl">
<dt>COLUMNS</dt><dd><code>COLUMNS</code> 属性定义列视图的格式,参见<a href="#orgc1b7a76">列视图(Column View)</a>. 从定义
<code>COLUMNS</code> 属性的级别作为列视图表的起点的意义上来说,它是继承的,与打开列视图的子树
中的位置无关.</dd>
<dt><code>CATEGORY</code></dt><dd>对于 agenda 视图,通过 <code>CATEGORY</code> 属性设置的类别适用于整个子树.</dd>
<dt>ARCHIVE</dt><dd>对于归档(archiving), <code>ARCHIVE</code> 属性可以定义整个子树的归档位置(请参见
<a href="#orgc5c7310">移动子树(Moving subtrees)</a>).</dd>
<dt>LOGGING</dt><dd><code>LOGGING</code> 属性可能会定义一个条目或子树的日志设置(请参阅:
<a href="#org410d180">跟踪待办状态改变(Tracking TODO state changes)</a>).</dd>
</dl>
</div>
</div>



<div id="outline-container-orgc1b7a76" class="outline-3">
<h3 id="orgc1b7a76">列视图(Column View)</h3>
<div class="outline-text-3" id="text-orgc1b7a76">
<p>
表格查看和编辑.
</p>

<p>
在大纲中查看和编辑属性的一个好方法是 <span class="underline">列视图</span>. 在列视图中,每一个大纲节点被转换成一
个表格行. 表格里的列提供对条目属性的访问. Org mode 通过在每个条目的标题上覆盖表
格结构来实现列.虽然标题已经被转换成了表格行,但你仍然可以改变大纲树的可见性.比如
说,当列视图处于激活状态时,通过切换到 "目录视图",可以得到一张紧凑的表格--<code>S-&lt;TAB&gt;</code>
<code>S-&lt;TAB&gt;</code> 或直接 <code>c</code> .但你仍然可以打开,阅读和编辑每个标题下的条目.或者,你可以在执行
稀疏树命令之后切换到列视图,并用这种方式仅为所选的条目创造一个表格.列视图也适用于
agenda 缓冲区(参见 <a href="#org7296ea5">Agenda Views</a>), 其中搜集了选中条目的查询结果可能来自多个文件.
</p>
</div>

<div id="outline-container-org0482b6f" class="outline-4">
<h4 id="org0482b6f">定义列(Defining columns)</h4>
<div class="outline-text-4" id="text-org0482b6f">
<p>
列格式属性.
</p>

<p>
设置一个列视图,首先需要定义列.这是通过定义列格式行来实现的.
</p>
</div>

<ul class="org-ul">
<li><a id="org4632e5e"></a>列定义的范围(Scope of column definitions)<br />
<div class="outline-text-5" id="text-org4632e5e">
<p>
在哪定义?在哪有效?
</p>

<p>
要指定仅应用于特定树的格式,请在特定树的顶部节点定义 <code>COLUMNS</code> 属性,例如:
</p>
<pre class="example">
** Top node for columns view
   :PROPERTIES:
   :COLUMNS: %25ITEM %TAGS %PRIORITY %TODO
   :END:
</pre>

<p>
第一个标题之前的属性抽屉中的 <code>COLUMNS</code> 属性将会应用到整个文件.除了属性抽屉之外,还
可以使用类似下面的行来为整个文件定义关键字:
</p>
<pre class="example">
#+COLUMNS: %25ITEM %TAGS %PRIORITY %TODO
</pre>

<p>
如果一个 <code>COLUMNS</code> 属性在一个条目中出现,它为条目本身和其下的整个子树定义列.由于列
定义是文档层级结构的一部分,因此,你可以在级别1上定义对所有子级别足够通用的列,当你
编辑到树的较深部分时,再定义更详细的列.
</p>
</div>
</li>

<li><a id="orgee1b317"></a>列属性(Column attributes)<br />
<div class="outline-text-5" id="text-orgee1b317">
<p>
列的内容和外观.
</p>

<p>
一个列定义设置列的属性.一般定义如下所示:
</p>
<pre class="example">
%[WIDTH]PROPERTY[(TITLE)][{SUMMARY-TYPE}]
</pre>
<p>
除了百分号和属性名,其他所有项都是可选的.各部分的含义如下:
</p>
<dl class="org-dl">
<dt>WIDTH</dt><dd>以字符为单位指定列的宽度的整数.如果省略,宽度将自动确定.</dd>
<dt>PROPERTY</dt><dd>应该在列里编辑的属性.这里也允许使用表示元数据的特殊属性,请参见
<a href="#orgd882f8c">特殊属性(Special Properties)</a>.</dd>
<dt>TITLE</dt><dd>列的标题文本.如果省略,则为属性名称.</dd>
<dt>SUMMARY-TYPE</dt><dd><p>
摘要类型.如果指定,父节点的列值将从子节点开始计算<sup><a id="fnr.27" class="footref" href="#fn.27">27</a></sup>.
支持的摘要类型有:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">‘+’</td>
<td class="org-left">此列中的数字总和.</td>
</tr>

<tr>
<td class="org-left">‘+;%.1f’</td>
<td class="org-left">和 <code>+</code> 类似,但结果用 "%.1f" 格式.</td>
</tr>

<tr>
<td class="org-left">‘$’</td>
<td class="org-left">货币,是 "+;%.2f" 的缩写.</td>
</tr>

<tr>
<td class="org-left">‘min’</td>
<td class="org-left">列中最小的数字.</td>
</tr>

<tr>
<td class="org-left">‘max’</td>
<td class="org-left">列中最大的数字.</td>
</tr>

<tr>
<td class="org-left">‘mean’</td>
<td class="org-left">算术平均数.</td>
</tr>

<tr>
<td class="org-left">‘X’</td>
<td class="org-left">复选框状态,如果所有子项都是 "[X]", 则复选框状态为 "[X]".</td>
</tr>

<tr>
<td class="org-left">‘X/’</td>
<td class="org-left">复选框状态, "[n/m]".</td>
</tr>

<tr>
<td class="org-left">‘X%’</td>
<td class="org-left">复选框状态, "[n%]".</td>
</tr>

<tr>
<td class="org-left">‘:’</td>
<td class="org-left">求和时间, HH:MM, 纯数字表示分钟.</td>
</tr>

<tr>
<td class="org-left">‘:min’</td>
<td class="org-left">列中最小的时间值.</td>
</tr>

<tr>
<td class="org-left">‘:max’</td>
<td class="org-left">列中最大的时间值.</td>
</tr>

<tr>
<td class="org-left">‘:mean’</td>
<td class="org-left">时间值的算术平均值.</td>
</tr>

<tr>
<td class="org-left">‘@min’</td>
<td class="org-left">最小时间段<sup><a id="fnr.28" class="footref" href="#fn.28">28</a></sup>(in days/hours/mins/seconds).</td>
</tr>

<tr>
<td class="org-left">‘@max’</td>
<td class="org-left">最大时间段(in days/hours/mins/seconds).</td>
</tr>

<tr>
<td class="org-left">‘@mean’</td>
<td class="org-left">时间段的算术平均值.(in days/hours/mins/seconds).</td>
</tr>

<tr>
<td class="org-left">‘est+’</td>
<td class="org-left">加上 low-high 估算.</td>
</tr>
</tbody>
</table>
<p>
  你也可以设置 <code>org-columns-summary-types</code> 来定义自定义摘要类型.
  <code>est+</code> 摘要类型需要进一步解释说明.它用于组合估计,表示为 低-高范围.例如,如果你
相当有信心知道工作需要多久,你可以将其估计为5-6天,而不是估计某个任务需要5天,如
果你真不知道要做什么,那你可以估计为1-10天.这两个区间平均为5.5天,但第一个区间代
表了更可预测的交付.
当组合这样一组估计时,简单地将低点和高点相加,就会产生一个不现实的广泛结果.相反
<code>est+</code> 将子任务的统计平均值和方差相加,从总和生成最终估计值.例如,假设你有10个任务,每
一个都估计在0.5到2天的工作量.直接相加会产生一个5到20天的估计,表示如果一切都非
常顺利或者非常糟糕会发生什么.相反地, <code>est+</code> 更现实地估计整个工作时间为10-15天.
</p></dd>
</dl>


<p>
这有一个完整的列定义的例子,以及允许的值<sup><a id="fnr.29" class="footref" href="#fn.29">29</a></sup>:
</p>
<pre class="example">
:COLUMNS:  %25ITEM %9Approved(Approved?){X} %Owner %11Status \
		   %10Time_Estimate{:} %CLOCKSUM %CLOCKSUM_T
:Owner_ALL:    Tammy Mark Karl Lisa Don
:Status_ALL:   "In progress" "Not started yet" "Finished" ""
:Approved_ALL: "[ ]" "[X]"
</pre>
<p>
第一个列, <code>%25ITEM</code>, 意味着条目本身的前25个字符,即标题的前25个字符.你可能应该总是
以 <code>ITEM</code> 说明符开始定义列.其他的说明符创建了列 <code>Owner</code>, 列中的名称列表为允许的值,创
建 <code>Status</code> 列,为四个不同的可能值; <code>Approved</code> 列为复选框字段.当 <code>%</code> 字符之后没有给
定宽度时,该列的宽度为正好可以显示期所有值的宽度. <code>Approved</code> 列的标题已修改
(<code>Approved?</code> ,带上了一个问号.) 摘要是为了 "Time_Estimate" 创建的,方法是添加时长表
达式如 HH:MM. 为 <code>Approved</code> 创建的摘要,如果所有子项都勾选了,则提供 <code>[X]</code> 状
态. <code>CLOCKSUM</code> 和 <code>CLOCKSUM_T</code> 列是特殊的,他们列出所有子树中的所有时间总和或只有今天
的时间总和.
</p>
</div>
</li>
</ul>
</div>




<div id="outline-container-org2d4db1a" class="outline-4">
<h4 id="org2d4db1a">使用列视图(Using column view)</h4>
<div class="outline-text-4" id="text-org2d4db1a">
<p>
如何创造和使用列视图
</p>

<p>
<b>开启或关闭列视图</b>
</p>

<dl class="org-dl">
<dt>C-c C-x C-c &#x2013; (org-columns)</dt><dd>开启列视图.如果光标位于文件的第一个标题之前,列
视图会使用 <code>#+COLUMNS</code> 的定义为整个文件开启.如果光标位于大纲的某处,这个命令会从
光标处开始向上搜索层级结构,寻找定义了格式的 <code>COLUMNS</code> 属性.当找到时,将从包含
<code>COLUMNS</code> 属性的条目开始为树创建列视图表.如果没有找到这样一个属性, 列定义的格式
会从 <code>#+COLUMNS</code> 行或从 <code>org-columns-default-format</code> 里读取,并为当前条目和其子树建
立列视图.</dd>
<dt>在列视图行使用 r 或 g &#x2013;(org-columns-redo)</dt><dd>重新创建列视图以包括缓冲区中最近
所做更改.</dd>
<dt>C-c C-c 或在列视图行里使用 q &#x2013; (org-columns-quit)</dt><dd>推出列视图.</dd>
</dl>


<p>
<b>编辑值</b>
</p>

<dl class="org-dl">
<dt>&lt;LEFT&gt;, &lt;RIGHT&gt;, &lt;UP&gt;, &lt;DOWN&gt;</dt><dd>从列视图中的一个字段移动到另一个字段.</dd>
<dt>1..9,0</dt><dd>直接选择第N个允许的值,"0" 选择第十个值.</dd>
<dt>n 或者 S-&lt;RIGHT&gt; &#x2013; (org-columns-next-allowed-value)</dt><dd>选择字段的下一个允许值.为
此,你必须为属性指定允许的值.</dd>
<dt>p 或者 S-&lt;LEFT&gt; &#x2013; (org-columns-previous-allowed-value)</dt><dd>和上面类似,但选择的
是上一个允许值.</dd>
<dt>e &#x2013; (org-columns-edit-value)</dt><dd>编辑光标出的属性.对于特殊属性,这个命令会调用
你平常用来改变该属性的相同接口.例如,当编辑 <code>TAGS</code> 属性的时候,会弹出标签补全或者
快速选择界面.</dd>
<dt>C-c C-c &#x2013; (org-columns-toggle-or-columns-quit)</dt><dd>当光标位于复选框上时,切换它
的状态.否则,就推出列视图.</dd>
<dt>a &#x2013; (org-columns-edit-allowed)</dt><dd>编辑这个属性的允许值的列表.如果列表在层级结
构中找到了,更改的值会存储在该列表中. 如果没有找到列表,那么新的值会存储在当前列
视图的第一个条目中.</dd>
</dl>
<p>
<b>即时修改列视图</b>
</p>
<dl class="org-dl">
<dt>&lt; &#x2013; (org-columns-narrow) ; &gt; &#x2013; (org-columns-widen)</dt><dd>使当前列扩大/缩小一个
字符.</dd>
<dt>S-M-&lt;RIGHT&gt; &#x2013; (org-columns-new)</dt><dd>插入一个新列到当前列的左边.</dd>
<dt>S-M-&lt;LEFT&gt; &#x2013; (org-columns-delete)</dt><dd>删除当前列.</dd>
</dl>
</div>
</div>

<div id="outline-container-org4478de5" class="outline-4">
<h4 id="org4478de5">捕获列视图(Capturing column view)</h4>
<div class="outline-text-4" id="text-org4478de5">
<p>
列视图的动态块.
</p>

<p>
因为列视图只是缓冲区上的一个覆盖,所以它无法直接打印或导出. 如果你想捕获列视图,请
使用 <code>columnview</code> 动态块(参见 <a href="#org70fc20b">Dynamic Blocks</a>). 该块的框架如下:
</p>
<pre class="example">
* The column view
#+BEGIN: columnview :hlines 1 :id "label"

#+END:
</pre>
<p>
这个动态块有如下参数:
</p>

<dl class="org-dl">
<dt>:id</dt><dd>这是最重要的参数.列视图是一个通常定位在某个(子)树上的功能,捕获块则可能
位于文件中不同的位置.要标识获取哪一个树的视图,你可以使用下面4个值:
<dl class="org-dl">
<dt>local</dt><dd>使用捕获块所在的树.</dd>
<dt>global</dt><dd>制造一个全局视图,包括文件中所有的标题.</dd>
<dt><code>file:FILENAME</code></dt><dd>在 FILENAME 文件里运行列视图.</dd>
<dt>LABEL</dt><dd>在拥有值为 LABEL 的 ID 属性的树里调用列视图.你可以使用 <code>M-x
    org-id-copy</code> 来为当前条目创造全局唯一的 ID 并将其复制到 kill-ring(暂时理解为
剪切板).</dd>
</dl></dd>
<dt>:match</dt><dd>当设置为一个字符串时,使用它作为标签/属性的匹配过滤器,来选择一个由
<code>:id</code> 参数设置的范围里标题的子集.</dd>
<dt>:hlines</dt><dd>当其为 <code>t</code> 时,在每一行之后插入一条水平线. 当为数字 N 时,在每一个层级
"&lt;= N" 的标题之前插入一条水平线.</dd>
<dt>:vlines</dt><dd>当为非 <code>nil</code> 值时,强制列组获得垂直线.</dd>
<dt>:maxlevel</dt><dd>当设置为一个数字时,不捕获这一层级之下的条目.</dd>
<dt>:skip-empty-rows</dt><dd>非 <code>nil</code> 时,跳过列视图中唯一非空说明符为 <code>ITEM</code> 的行.</dd>
<dt>:exclude-tags</dt><dd>要从列视图中排除的标签列表:有这些标签的条目将从列视图中排除.</dd>
<dt>:indent</dt><dd>非 <code>nil</code> 时,根据层级缩进每一个 <code>ITEM</code> 字段.</dd>
<dt>:format</dt><dd>为动态块指定一个列属性(参见 <a href="#orgee1b317">列属性(Column attributes)</a>).</dd>
</dl>


<p>
下面的命令插入或更新动态块:
</p>

<dl class="org-dl">
<dt>org-columns-insert-dblock</dt><dd>插入一个捕获列视图的动态块.提示输入视图的范围或
ID. 这个命令可以通过调用 <code>org-dynamic-block-insert-dblock</code> (绑定为 <code>C-c C-x x</code>) 并
选择 "columnview" 来启动(参见 <a href="#org70fc20b">Dynamic Blocks</a>).</dd>
<dt>C-c C-c 或 C-c C-x C-u &#x2013; (org-dblock-update)</dt><dd>更新光标处的动态块.光标需要位
于动态块的 <code>#+BEGIN</code> 行.</dd>
<dt>C-u C-c C-x C-u &#x2013; (org-update-all-dblocks)</dt><dd>更新所有动态块(参见 <a href="#org70fc20b">Dynamic Blocks</a>). 如果你的缓冲区中有多个时钟表块,列捕获块或其他动态块时是很有用的.</dd>
</dl>


<p>
你可以将公式添加到列视图表格中,你也可以在表格前面添加绘图指令,这些指令在块更新后
仍然有效.如果表格后面有 <code>TBLFM</code> 关键字,则更新后会自动重新计算表格.
</p>

<p>
Eric Schulte 的 <code>org-collector.el</code> 包提供了另一种将属性值捕获并处理到表格中的方法.该
包位于 <code>org-contrib</code><sup><a id="fnr.30" class="footref" href="#fn.30">30</a></sup> 里.它提供了一个通用 API, 用于特定范围的条
目中搜集属性,以及搜集属性 Lisp 表达式用来在值插入到表格或动态块之前处理这些值.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org17b3112" class="outline-2">
<h2 id="org17b3112"><span class="done DONE">DONE</span> 日期和时间(Dates and Times)</h2>
<div class="outline-text-2" id="text-org17b3112">
</div>
<div id="outline-container-org1d92752" class="outline-3">
<h3 id="org1d92752">时间戳(Timestamps)</h3>
<div class="outline-text-3" id="text-org1d92752">
<p>
时间戳是特殊格式的日期规范(可能带有时间或时间范围),可以使 <code>&lt;2022-05-02 Mon&gt;</code> 或
<code>&lt;2022-05-02 Mon 02:44&gt;</code> 或 <code>&lt;2022-05-02 Mon 12:00-12:30&gt;</code><sup><a id="fnr.31" class="footref" href="#fn.31">31</a></sup>.
一个时间戳可以出现在 Org 树条目的标题或正文中的任何位置.他的存在会导致条目出现在
agenda 的特定日期显示里(参见 <a href="#org3479471">Weekly/daily agenda</a>). 我们区分下面概念:
</p>
<dl class="org-dl">
<dt>简单时间戳;事件;预约</dt><dd><p>
一个简单时间戳只是为一个条目分配一个时间/日期.这就像在
纸上写下一个约会或事件.在 agenda 显示里,有普通时间戳的条目会正好出现在该日期.
</p>
<pre class="example">
* Meet Peter at the movies
  &lt;2006-11-01 Wed 19:15&gt;
* Discussion on climate change
  &lt;2006-11-02 Thu 20:00-22:00&gt;
</pre></dd>
<dt>带重复间隔的时间戳</dt><dd><p>
一个时间戳可能包含一个重复间隔,表示它不仅应用于给定日期,
并且在特定的 N 天(d), 周(w), 月(m) 或年(y) 的时间间隔之后一次次重复.下面的例子
会在agenda 的每个周一出现:
</p>
<pre class="example">
* Pick up Sam at school
  &lt;2007-05-16 Wed 12:30 +1w&gt;
</pre></dd>
<dt>日记式表达条目</dt><dd><p>
对于更复杂的日期规范,Org mode 支持使用 Emacs 的 Calendar 包
里实现的特殊表达日记条目<sup><a id="fnr.32" class="footref" href="#fn.32">32</a></sup>.例如,使用可选时间:
</p>
<pre class="example">
* 22:00-23:00 The nerd meeting on every 2nd Thursday of the month
  &lt;%%(diary-float t 4 2)&gt;
</pre></dd>
<dt>时间/日期范围</dt><dd><p>
用 <code>--</code> 连接的两个时间戳表示一个范围.标题会在范围的第一天,最后
一天和任何一个在范围内的日期里显示.下面是一个示例:
</p>
<pre class="example">
** Meeting in Amsterdam
   &lt;2004-08-23 Mon&gt;--&lt;2004-08-26 Thu&gt;
</pre></dd>
<dt>无效时间戳</dt><dd><p>
和简单时间戳类似,但是使用方括号而不是尖括号.这种时间戳是不活跃的,因
为他们不会导致条目出现在 agenda 里:
</p>
<pre class="example">
* Gillian comes late for the fifth time
  [2006-11-01 Wed]
</pre></dd>
</dl>
</div>
</div>
<div id="outline-container-orgd2651d1" class="outline-3">
<h3 id="orgd2651d1">创建时间戳(Creating Timestamps)</h3>
<div class="outline-text-3" id="text-orgd2651d1">
<p>
为了让 Org mode 能识别时间戳,时间戳需要使用特定的格式.下面列出的所有命令都能产生
正确格式的时间戳:
</p>
<dl class="org-dl">
<dt>C-c . &#x2013; (org-time-stamp)</dt><dd>提示输入日期并插入相应时间戳.当光标位于一个已存在
的时间戳上时,该命令会用来修改该时间戳而不是插入一个新的. 当连续使用这个命令两
次,一个时间范围会被插入.
当带上前缀参数使用时,将使用包含时间和日期的替代格式.默认的时间可以被圆整到5的
倍数,参考选项 <code>org-time-stamp-rounding-minutes</code>.
加上两个前缀参数,会插入一个当前时间的有效时间戳,不会有提示输入.</dd>
<dt>C-c ! &#x2013; (org-time-stamp-inactive)</dt><dd>和 <code>C-c .</code> 类似,但是会插入一个不会生成
agenda 条目的无效(不活跃的)时间戳.</dd>
<dt>C-c C-c</dt><dd>标准化时间戳,插入或修正日期名,如果有错误或者缺失的话.</dd>
<dt>C-c &lt; &#x2013; (org-date-from-calendar)</dt><dd>插入一个 calendar 缓冲区里光标所处位置日
期对应的时间戳.</dd>
<dt>C-c &gt; &#x2013; (org-goto-calendar)</dt><dd>从当前日期访问 Emacs calendar(Emacs 的日历程
序).如果当前行有一个时间戳,则会从其对应的时间访问日历.</dd>
<dt>C-c C-o &#x2013; (org-opne-at-point)</dt><dd>从光标处的时间戳或时间戳范围给定的日期访问
agenda (参见 <a href="#org3479471">Weekly/daily agenda</a>).</dd>
<dt>S-&lt;LEFT&gt; &#x2013; (org-timestamp-down-day)</dt><dd>将光标处的时间戳日期减少一天.</dd>
<dt>S-&lt;RIGHT&gt; &#x2013; (org-timestamp-up-day)</dt><dd>将光标处的时间戳日期增加一天.这个快捷键
和上一个快捷键绑定与 shift-selection 和相关模式有冲突(详情见 <a href="#orge6e17fa">Conflicts</a>).</dd>
<dt>C-c C-y &#x2013; (org-evaluate-time-range)</dt><dd>通过计算开始和结束的差来计算一个时间范
围. 带上前缀参数使用,会在时间范围之后插入结果(在表格中则会将结果插入到下一列).</dd>
</dl>
</div>
<div id="outline-container-org23493ab" class="outline-4">
<h4 id="org23493ab">日期/时间提示(The date/time prompt)</h4>
<div class="outline-text-4" id="text-org23493ab">
<p>
Org mode 会帮助你输入日期和时间.
</p>

<p>
当Org mode 提示你输入一个时间/日期时,默认是用默认的日期/时间格式显示,因此提示看
起来像是要求输入特定的格式. 但实际上它能接受各种不同的日期/时间信息格式. 通常来
说时间信息应该从字符串的开头开始. Org mode 会找出其中有什么信息,并从默认的日期和
时间里派生出您未指定的任何信息. 默认的通常是当前日期和时间,但是当修改一个已有的
时间戳时,或者当输入范围的第二个时间戳时,Org 会从当前缓冲区里的时间戳取值.当填写
信息时,Org mode 假设大多数情况下你想输入的日期是在未来:如果你给定一个今天之前的
日期,忽略 月/年 并且给定了 天/月,Org 假设你指的是一个将来的日期<sup><a id="fnr.33" class="footref" href="#fn.33">33</a></sup>. 如果日期被自动变换成未来日期,时间提示会将其用 <code>(=&gt;F)</code> 展示.
</p>

<p>
例如,让我们假设今天是 <b>June 13, 2006</b>. 下面显示不同的输入是如何被解释的,被Org mode
填入的条目是加粗的(用两个 <code>*</code> 包裹):
</p>
<pre class="example">
‘3-2-5’          ⇒ 2003-02-05
‘2/5/3’          ⇒ 2003-02-05
‘14’             ⇒ *2006*-*06*-14
‘12’             ⇒ *2006*-*07*-12
‘2/5’            ⇒ *2007*-02-05
‘Fri’            ⇒ nearest Friday (default date or later)
‘sep 15’         ⇒ *2006*-09-15
‘feb 15’         ⇒ *2007*-02-15
‘sep 12 9’       ⇒ 2009-09-12
‘12:45’          ⇒ *2006*-*06*-*13* 12:45
‘22 sept 0:34’   ⇒ *2006*-09-22 0:34
‘w4’             ⇒ ISO week for of the current year *2006*
‘2012 w4 fri’    ⇒ Friday of ISO week 4 in 2012
‘2012-w04-5’     ⇒ Same as above
</pre>

<p>
此外,你可以指定一个相对日期,通过给定一个加/减号,一个数字加上一个字母作为首要输入
来实现.字母可为 <code>h</code>, <code>d</code>, <code>w</code>, <code>m</code> 或 <code>y</code> 来表示以小时天,周,月或年为单位改变.使用 <code>h</code> ,日期
会相对于当前时间;使用其他字母和一个加号或减号,日期是相对于今天的 00:00.使用双加
号或减号,日期相对于默认日期. 如果使用日期名的缩写,而不是单个字母,则日期为第 N 天,例
如:
</p>
<pre class="example">
‘+0’      ⇒ today
‘.’       ⇒ today
‘+2h’     ⇒ two hours from now
‘+4d’     ⇒ four days from today
‘+4’      ⇒ same as +4d
‘+2w’     ⇒ two weeks from today
‘++5’     ⇒ five days from default date
‘+2tue’   ⇒ second Tuesday from now
</pre>
<p>
该功能理解英文的月份和周缩写.如果你想使用其他语言或者不使用缩写名,请配置变量
<code>parse-time-moths</code> 和 <code>parse-time-weekdays</code>.
</p>

<p>
不是所有的日期都能在给定的 Emacs 实现中表示.默认情况下, Org mode 将日期强制设置
为兼容范围 1970-2037,这适用于所有 Emacs 实现. 如果你想使用该范围之外的日期,请阅
读变量 <code>org-read-date-force-compatible-dates</code> 的文档字符串.
</p>

<p>
你可以通过给定开始和结束时间或者给定一个开始时间和持续时间(用HH:MM格式)来指定一
个时间范围. 前者使用一个或两个破折号作为分隔符,后者使用 <code>+</code> 作为分隔符,例如:
</p>
<pre class="example">
‘11am-1:15pm’    ⇒ 11:00-13:15
‘11h-13h15’      ⇒ same as above
‘11am--1:15pm’   ⇒ same as above
‘11am+2:15’      ⇒ same as above
</pre>

<p>
minibuffer 提示出现的同时,一个日历会弹出<sup><a id="fnr.34" class="footref" href="#fn.34">34</a></sup>. 当你通过单击日历中的日期或者按 <code>&lt;RET&gt;</code> 退出
日期提示时,日历中选中的日期将会和提示中输入的信息相结合.你可以从 minibuffer 里完
全控制 calendar:
</p>
<dl class="org-dl">
<dt>‘&lt;RET&gt;’       </dt><dd>Choose date at point in calendar.</dd>
<dt>‘mouse-1’     </dt><dd>Select date by clicking on it.</dd>
<dt>‘S-&lt;RIGHT&gt;’   </dt><dd>One day forward.</dd>
<dt>‘S-&lt;LEFT&gt;’    </dt><dd>One day backward.</dd>
<dt>‘S-&lt;DOWN&gt;’    </dt><dd>One week forward.</dd>
<dt>‘S-&lt;UP&gt;’      </dt><dd>One week backward.</dd>
<dt>‘M-S-&lt;RIGHT&gt;’ </dt><dd>One month forward.</dd>
<dt>‘M-S-&lt;LEFT&gt;’  </dt><dd>One month backward.</dd>
<dt>‘&gt;’           </dt><dd>Scroll calendar forward by one month.</dd>
<dt>‘&lt;’           </dt><dd>Scroll calendar backward by one month.</dd>
<dt>‘M-v’         </dt><dd>Scroll calendar forward by 3 months.</dd>
<dt>‘C-v’         </dt><dd>Scroll calendar backward by 3 months.</dd>
<dt>‘C-.’         </dt><dd>Select today’s date<sup><a id="fnr.35" class="footref" href="#fn.35">35</a></sup></dd>
</dl>


<p>
日期/时间提示的操作似乎很复杂,但是我保证你会越来越喜欢它,并且你会开始对其他任何
输入时间/日期的方式感到恼火.为了帮助你理解正在发生的事情,你输入的即时解释将会实
时展示在 minibuffer<sup><a id="fnr.36" class="footref" href="#fn.36">36</a></sup> 中.
</p>
</div>
</div>
<div id="outline-container-orga990c7a" class="outline-4">
<h4 id="orga990c7a">自定义时间格式(Custom time format)</h4>
<div class="outline-text-4" id="text-orga990c7a">
<p>
让日期看起来不一样.
Org mode 使用ISO 8601 中定义的时间和日期的标准 ISO 标记法. 如果你不习惯这种表示
法并想使用另一种让你开心的时间和日期的表示法,你可以通过自定义变量
<code>org-display-custom-times</code> 和 <code>org-time-stamp-custom-formats</code> 来实现.
</p>
<dl class="org-dl">
<dt>C-c C-x C-t &#x2013; (org-toggle-time-stamp-overlays)</dt><dd>切换日期和时间的自定义展示.
Org mode 需要使用默认格式进行扫描,所以自定义格式不会替换默认格式.相反地,它使用
文本属性来将自定义格式放在默认格式之上.这会产生下列影响:
<ul class="org-ul">
<li>你再也不能把光标放置到时间戳上了,只有放到时间戳之前或之后.</li>
<li><code>S-&lt;UP&gt;</code> 和 <code>S-&lt;DOWN&gt;</code> 不能在用来调整时间戳的每个组件了.如果光标位于时间戳的开
头, <code>S-&lt;UP&gt;</code> 和 <code>S-&lt;DOWN&gt;</code> 按天改变时间戳,如同 <code>S-&lt;LEFT&gt;</code> 和 <code>S-&lt;RIGHT&gt;</code> 一样. 光标
位于时间戳末尾,按分钟改变时间.</li>
<li>如果时间戳包含时间范围或重复间隔,它们并不会被自定义格式覆盖,而是保留原样.</li>
<li>当你逐字删除时间戳时,只有当所有(不可见的)属于 ISO 格式的时间戳被删除之后,时
间戳才会从缓冲区里消失.</li>
<li>如果自定义的时间戳格式比默认的长,并且你正在表格里使用时间戳,那么表格布局会被
打乱.如果自定义格式较默认更短,一切都按预期方式工作.</li>
</ul></dd>
</dl>
</div>
</div>
</div>

<div id="outline-container-org1e3c531" class="outline-3">
<h3 id="org1e3c531">截止时间和日程安排(Deadlines and Scheduling)</h3>
<div class="outline-text-3" id="text-org1e3c531">
<p>
时间戳前可以加上特殊关键字,以便于计划.时间戳和关键字都必须紧跟在它们所指的任务之
后.
</p>

<dl class="org-dl">
<dt>DEADLINE</dt><dd><p>
意义:任务&#x2013;多数情况下是待办事项,应该在那个日期(前)完成(尽管不是必
须的).在 deadline date(截止日期)那一天,任务会出现在 agenda 里. 此外,在 <span class="underline">今天</span> 的
日程视图里会有一条关于临近或者错过截止日期的警告,从截止日期前的
<code>org-deadline-warning-days</code> 天开始,一直持续到条目被标记为完成为止. 例如:
</p>
<pre class="example">
*** TODO write article about the Earth for the Guide
    DEADLINE: &lt;2004-02-29 Sun&gt;
    The editor in charge is [[bbdb:Ford Prefect]]
</pre>
<p>
你也可以使用下面的语法来特定截止日期指定不同的警告提前期.这是一个提前5天开始警
告的例子: <code>DEADLINE: &lt;2004-02-29 Sun -5d&gt;</code> .如果该任务被"计划了"(见下文),并且你
将 <code>org-agenda-skip-deadline-prewarning-if-scheduled</code> 设置为了 <code>t</code> ,那么该例子的警
告就会是未激活的(不生效).
</p></dd>
<dt>SCHEDULE</dt><dd><p>
意义:你计划在给定的日期开始进行该任务.
标题会在给定的日期里在 agenda 视图中列出<sup><a id="fnr.37" class="footref" href="#fn.37">37</a></sup>.此外,一个计划日期已经过去了的提醒会出现在
今天的待办收集中,指导该条目被标记未完成为止.也就是说,任务会自动向前推移,直到它
被完成.
</p>
<pre class="example">
*** TODO Call Trillian for a date on New Years Eve.
    SCHEDULED: &lt;2004-12-25 Sat&gt;
</pre>
<p>
如果你想 <span class="underline">推迟</span> 该任务在 agenda 里的显示,可以使用 <code>SCHEDULED:
  &lt;2004-12-25 Sat -2d&gt;</code> :该任务仍然计划在 25号,但会在25号的两天后才会出现在
agenda 里,也就是27号才会出现在 agenda 里.如果任务中有重复器(repeater, 中继器,
但这里还是觉得翻译成重复器好理解一点 <a href="#org50dcbf1">重复的任务(Repeated tasks)</a>),则延迟显示会
影响所有该任务的出现;如果你想只延迟显示任务的第一次出现,请使用 <code>--2d</code>. 更多关于
如何全局或者每个 agenda 里控制这一行为的详情,请参考变量
<code>org-scheduled-delay-days</code> 和 <code>org-agenda-skip-scheduled-delay-if-deadline</code>.
</p>
<blockquote>
<p>
重要提示:在 Org mode 里 Schedule 一个条目不应该和我们理解的计划一个会议相同.为
一个会议设置一个日期只是一个简单的约定,你应该使用简单时间戳来标记这个条目,以便
其显示在合适的日期.这是一个 Org 用户经常产生的误解.在 Org mode
里, <span class="underline">scheduling(计划)</span> 意味着设置一个开始着手处理某个操作项的日期.
</p>
</blockquote></dd>
</dl>


<p>
你可以在有计划日期和截止时间的条目中使用带重复器的时间戳.Org mode 会基于时间戳中
重复器表示的最近一个实例的假设来发出早期和晚期警告.然而在计划和截止日期时间戳里,
这种日记表达条目的使用是被限制的:
</p>
<pre class="example">
&lt;%%(diary-float t 42)&gt;
</pre>
<p>
Org mode 对每个函数的内部结构了解不足,无法发布早期和晚期警告.然而,它会在表达式条
目匹配的日期里显示该条目.
</p>
</div>

<div id="outline-container-org16a4e2e" class="outline-4">
<h4 id="org16a4e2e">插入截止日期/日程安排(Inserting deadline/schedule)</h4>
<div class="outline-text-4" id="text-org16a4e2e">
<p>
规划项目.
</p>

<p>
下面的命令允许你快速插入一个截止日期或者计划一个任务<sup><a id="fnr.38" class="footref" href="#fn.38">38</a></sup>:
</p>
<dl class="org-dl">
<dt>C-c C-d &#x2013; (org-deadline)</dt><dd>插入一个带 <code>DEADLINE</code> 关键字的时间戳.插入的时间戳会
直接放置在标题的下一行.还会移除所有 <code>CLOSED</code> 时间戳. 当带上前缀参数使用时,也会移
除条目中所有已存在的截止时间. <code>org-log-redeadline</code> 决定当改变一个已有截止时间时
是否需要记录一条笔记<sup><a id="fnr.39" class="footref" href="#fn.39">39</a></sup>.</dd>
<dt>C-c C-s &#x2013; (org-schedule)</dt><dd>插入一个带 <code>SCHEDULED</code> 关键字的时间戳.时间戳会直接
放置在标题的下一行.还会移除所有 <code>CLOSED</code> 时间戳.当带上前缀参数使用时,也会移除条
目中的计划数据. <code>org-log-reschedule</code> 决定了当改变已有计划时间时是否需要记录一条
笔记<sup><a id="fnr.40" class="footref" href="#fn.40">40</a></sup>.</dd>
<dt>C-c / d &#x2013; (org-check-deadlines)</dt><dd>创造一个带所有截止日期的稀疏树,不管该日期
是已经过期或者是在 <code>org-deadline-warning-days</code> 天内将要过期的时间戳.带上 <code>C-u</code> 前缀,
会展示文件里所有的截止日期.带上数字前缀参数N使用,会查看 N 天内的截止日期,例如
<code>C-1 C-c / d</code> 会显示到明天为止的所有截止日期.</dd>
<dt>C-c / b &#x2013; (org-check-before-date)</dt><dd>创建一个在给定日期之前的截止日期和计划事
项的稀疏树.</dd>
<dt>C-c / a &#x2013; (org-check-after-date)</dt><dd>创建一个在给定日期之后的截止日期和计划事
项的稀疏树.</dd>
</dl>

<p>
请注意, <code>org-schedule</code> 和 <code>org-deadline</code> 支持用指示相对时间来设置日期.例如, <code>+1d</code> 将日
期设置为今天之后的一天, <code>--1w</code> 将日期设置为当前时间戳的前一个星期.
</p>
</div>
</div>
<div id="outline-container-org50dcbf1" class="outline-4">
<h4 id="org50dcbf1">重复的任务(Repeated tasks)</h4>
<div class="outline-text-4" id="text-org50dcbf1">
<p>
一次又一次出现的项目.
</p>

<p>
有一些任务需要一遍又一遍的重复. Org mode 使用所谓的 repeater(中继器/重复器)来帮
助组织这一类任务.一个重复器可以被放置在 <code>DEADLINE</code> , <code>SCHEDULED</code> 或者简单时间戳<sup><a id="fnr.41" class="footref" href="#fn.41">41</a></sup>. 请看下面的例子:
</p>
<pre class="example">
** TODO Pay the rent
   DEADLINE: &lt;2005-10-01 Sat +1m&gt;
</pre>
<p>
这个例子中 <code>+1m</code> 就是一个重复器;预期的解释是,任务的截止日期是 <code>&lt;2005-10-01&gt;</code> 并从该
时间开始每一个月重复一次. 你可以使用 <code>y/m/w/d/h</code> 来表示按年/月/周/天/小时重复的重
复器.如果你需要在一个截止日期里同时拥有一个重复器和一个特殊的警告时期,重复器应该
在警告时期的前面:
</p>
<pre class="example">
DEADLINE: &lt;2005-10-01 Sat +1m -3d&gt;
</pre>
<p>
要让一个有重复器的任务标记为 <code>DONE</code>, 请使用 <code>C--1 C-c C-t</code>, 也就是说带数字前缀参数
<code>-1</code> 的 <code>org-todo</code> 命令.
</p>

<p>
时间戳会被添加到截止日期之下<sup><a id="fnr.42" class="footref" href="#fn.42">42</a></sup>, 来记录你在这个截止日期之前实际完成的该事
项的上一个实例.
</p>

<p>
由于更改了基准日期,在检查过去的日期时,该条目在 agenda 里不可见,但是其所有的未来
的实例都是可见的.
</p>

<p>
使用 <code>+1m</code> cookie, 日期的变动刚好是一个月.因此,如果你已经三个月没付房租了,将这个事
项标记为DONE仍然会将其视为逾期期限.取决于任务类型,这可能并不是最好的处理它的方式.例
如,如果你已经三个星期每个你父亲打电话了,在一天之内给他打三次电话来弥补是没有意义
的.最后,有一些任务应该总是在你最后一次完成后的特定时间内重复,例如换电池.对于这些
任务,Org mode 使用特殊的重复器 <code>++</code> 和 <code>.+</code> .例如:
</p>
<pre class="example">
** TODO Call Father
   DEADLINE: &lt;2008-02-10 Sun ++1w&gt;
   Marking this DONE shifts the date by at least one week, but also
   by as many weeks as it takes to get this date into the future.
   However, it stays on a Sunday, even if you called and marked it
   done on Saturday.

** TODO Empty kitchen trash
   DEADLINE: &lt;2008-02-08 Fri 20:00 ++1d&gt;
   Marking this DONE shifts the date by at least one day, and also
   by as many days as it takes to get the timestamp into the future.
   Since there is a time in the timestamp, the next deadline in the
   future will be on today's date if you complete the task before
   20:00.

** TODO Check the batteries in the smoke detectors
   DEADLINE: &lt;2005-11-01 Tue .+1m&gt;
   Marking this DONE shifts the date to one month after today.

** TODO Wash my hands
   DEADLINE: &lt;2019-04-05 08:00 Sun .+1h&gt;
   Marking this DONE shifts the date to exactly one hour from now.
</pre>

<p>
你可以为特定任务同时指定计划和截止日期的信息.如果重复器只在计划信息里设置了,你可
能想要让重复器在截止日期之后就被忽略.如果确实如此,请将变量
<code>org-agenda-skip-scheduled-if-deadline-is-shown</code> 设置为 <code>repeated-after-deadline</code>
.然而任何没有重复器的计划信息在任务标记为完成之后就与该任务没有关联了,也就是停止
了该任务的重复.如果你想计划信息和截止日期信息都在相同时间间隔后重复,请为两种时间
戳设置相同的重复器.
</p>

<p>
另一种使用重复器的方式是创建许多任务子树的副本子树,日期随副本变化. <code>C-c C-x c</code> 命
令就是基于次命令创造的;该命令的详细描述在 <a href="#orgbc32feb">结构编辑(Structure Editing)</a> 中.
</p>
</div>
</div>
</div>


<div id="outline-container-orgfd54c4c" class="outline-3">
<h3 id="orgfd54c4c">计时工作时间(Clocking Work Time)</h3>
<div class="outline-text-3" id="text-orgfd54c4c">
<p>
Org mode 允许你对在一个项目中的特定任务上所花的时间进行计时.当你开始处理一个事项
时,你可以开始计时.当你停止执行该任务或者当你标记该任务为已完成时,计时会停止,并记
录相应的时间间隔.Org 也会计算一个项目中每个子树所花时间的整体时间<sup><a id="fnr.43" class="footref" href="#fn.43">43</a></sup>. 并且 Org 会记住最近计时的任务或一段历史记录,因此你可以在一系列占用你时间的任务
中快速跳转.
</p>

<p>
要跨 Emacs 会话保存计时历史记录,请使用:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">setq</span> org-clock-persist 'history)
(org-clock-persistence-insinuate)
</pre>
</div>

<p>
当你重新启动 Emacs ,并对一个新的任务开始计时,未完成的计时<sup><a id="fnr.44" class="footref" href="#fn.44">44</a></sup>会恢复并
且会提示你要对该任务进行什么操作(参见 <a href="#org07851a5">解决空闲时间(Resolving idle time)</a>).
</p>
</div>

<div id="outline-container-org743be46" class="outline-4">
<h4 id="org743be46">计时命令(Clocking commands)</h4>
<div class="outline-text-4" id="text-org743be46">
<p>
开始和停止计时.
</p>

<dl class="org-dl">
<dt>C-c C-x C-i &#x2013; (org-clock-in)</dt><dd>在当前事项上开始计时.该命令会插入一个带 <code>CLOCK</code>
关键字的时间戳.如果这不是该事项的第一次计时,多个 <code>CLOCK</code> 行会被放进一个 <code>LOGBOOK</code>
抽屉里(令参见变量 <code>org-clock-into-drawer</code> ).你也可以通过设置子树的
<code>CLOCK_INTO_DRAWER</code> 或 <code>LOG_INTI_DRAWER</code> 属性来覆盖这个变量的设置.当带上 <code>C-u</code> 前缀
使用时,从最近计时的任务列表的选择任务.当带上 <code>C-u C-u</code> 前缀时,通过从最后一次计时
停止时开始计时来强制连续性计时.
当计时正在进行时,Org 会在 mode line 里展示当前的计时时间和计时任务的标题.显示
的计时时间时为该任务和其子任务计时的所有时间.如果该任务有一个工作量估计(参见
<a href="#org18dc1cf">工作量估算(Effort Estimates)</a>),mode line 会展示工作量估计的当前计时时间<sup><a id="fnr.45" class="footref" href="#fn.45">45</a></sup>. 如果任务是
重复任务(参见 <a href="#org50dcbf1">重复的任务(Repeated tasks)</a>), 只展示从上一次重置起的时间<sup><a id="fnr.46" class="footref" href="#fn.46">46</a></sup>. 你可以使用 <code>CLOCK_MODELINE_TOTAL</code> 属
性对显示时间进行更多的控制. 该属性可以有值 <code>current</code> 来只展示当前计时实例,值
<code>today</code> 来显示今天这个任务所有的计时时间(另见变量 <code>org-extend-today-util</code>), 值 <code>all</code>
来包括所有的时间,或者是默认值 <code>auto</code> .<sup><a id="fnr.47" class="footref" href="#fn.47">47</a></sup>
在 mode line 上点击 <code>mouse-1</code> (也就是鼠标左键)会弹出计时选项菜单.</dd>

<dt>C-c C-x C-o &#x2013; (org-clock-out)</dt><dd>停止计时.命令会在最近一次计时开始的时间戳的
相同位置插入另一个时间戳.命令也会直接计算时间结果,并将其插入时间范围之后的
<code>HH:MM</code> 里.查看变量 <code>org-log-note-clock-out</code> 了解是否可以和计时停止时间戳一起记录
一个额外的笔记<sup><a id="fnr.48" class="footref" href="#fn.48">48</a></sup>.</dd>
<dt>C-c C-x C-x &#x2013; (org-clock-in-last)</dt><dd>重新计时上次计时的任务.加上 <code>C-u</code> 前缀参数,从
计时历史里选择任务.带上两个 <code>C-u</code> 参数,通过从上一次计时停止的地方开始计时来进行
强制连续性计时</dd>
<dt>C-c C-x C-e &#x2013; (org-clock-modify-effort-estimate)</dt><dd>更新当前计时任务的工作量
估计.</dd>
<dt>C-c C-c or C-c C-y &#x2013; (org-evaluate-time-range)</dt><dd>在其中一个时间戳改变后重新
计算时间间隔.这只在你手动编辑时间戳时有必要.如果你使用 <code>S-&lt;cursor&gt;</code> 快捷键,更新
是自动的.</dd>
<dt>C-S-&lt;UP&gt; &#x2013; (org-clock-timestamp-up)</dt><dd>见下一项.</dd>
<dt>C-S-&lt;DOWN&gt; &#x2013; (org-clock-timestamps-down)</dt><dd>在 <code>CLOCK</code> 日志行上, 增加/减少光标
处的两个时间戳,以便计时持续时间保持相同的值.</dd>
<dt>S-M-&lt;UP&gt; &#x2013; (org-timestamp-up)</dt><dd>见下一项.</dd>
<dt>S-M-&lt;DOWN&gt; &#x2013; (org-timestamp-down)</dt><dd>在 <code>CLOCK</code> 日志行,增加/减少光标处的时间戳
和上一个或下一个时间戳相同的持续时间.例如,如果你使用 <code>S-M-&lt;UP&gt;</code> 来为计时关闭的时
间戳增加5分钟,那么下一次计时的开始计时时间戳会增加5分钟.</dd>
<dt>C-c C-t &#x2013; (org-todo)</dt><dd>若计时正在当前条目运行,改变该条目的 TODO 状态为 DONE
会自动停止计时.</dd>
<dt>C-c C-x C-q &#x2013; (org-clock-cancel)</dt><dd>取消当前计时.这在你错误的开始了计时或者你
最终做了其他事情时很有用.</dd>
<dt>C-c C-x C-j &#x2013; (org-clock-goto)</dt><dd>跳转到当前计时的任务的标题.带上一个 <code>C-u</code> 前
缀参数,会从最近计时的任务列表里选择目标任务.</dd>
<dt>C-c C-x C-d &#x2013; (org-clock-display)</dt><dd>展示当前缓冲区内的每个子树的时间汇总.这
会在每个标题之后放置一个 overlay(图层),显示该标题之下记录的总时间,包括所有子标
题.你可以使用可视性循环来研究树,但是当你修改缓冲区(参见变量
<code>org-remove-highlights-with-change</code>) 或者按 <code>C-c C-c</code> 之后,显示时间的图层会消失.</dd>
</dl>


<p>
<code>l</code> 键可以用于 agenda 中(参见<a href="#org3479471">Weekly/daily agenda</a>)来显示一天中哪些任务已完成或结束.
</p>

<p>
<b>重要:</b> 请注意 <code>org-clock-out</code> 和 <code>org-clock-in-last</code> 都可以具有全局快捷键绑定,并且不
会改变窗口配置.
</p>
</div>
</div>

<div id="outline-container-org2635179" class="outline-4">
<h4 id="org2635179"><span class="todo TODO">TODO</span> 计时表格(The clock table)</h4>
<div class="outline-text-4" id="text-org2635179">
<p>
详情报告.
</p>
</div>
</div>
<div id="outline-container-org07851a5" class="outline-4">
<h4 id="org07851a5">解决空闲时间(Resolving idle time)</h4>
<div class="outline-text-4" id="text-org07851a5">
<p>
解决你空闲的时间.
</p>
</div>
</div>
</div>
<div id="outline-container-org18dc1cf" class="outline-3">
<h3 id="org18dc1cf">工作量估算(Effort Estimates)</h3>
<div class="outline-text-3" id="text-org18dc1cf">
<p>
如果你像以一种更详细的方式计划你的工作,或者你需要生成带有工作量估计的报价,你可能
需要给事项分配工作量估计.如果你也想要为你的工作计时,你稍后可能希望将估计时间和实
际时间相比较,这是改进计划估计的好方法.
</p>

<p>
工作量估计存储在特殊属性 <code>EFFORT</code> 里.支持多种格式,例如 <code>3:12</code>, <code>1:23:45</code> 或 <code>1d3h5min</code>;
查看文件 <code>org-duration.el</code> 了解关于格式的更详细信息.
</p>

<p>
你可以使用下列命令为一个条目设置工作量估计:
</p>
<dl class="org-dl">
<dt>C-c C-x e &#x2013; (org-set-effort)</dt><dd>为当前条目设置工作量估计.加上一个前缀参数,会
将其设置为下一个允许值(见下文).这个命令也可以在 agenda 里使用 <code>e</code> 键调用.</dd>
<dt>C-c C-x C-e &#x2013; (org-clock-modify-effort-estimate)</dt><dd>修改当前正在计时的条目的
工作量估计.</dd>
</dl>

<p>
很显然,使用工作量估计最好的方式是通过列视图(参见<a href="#orgc1b7a76">列视图(Column View)</a>). 你应该从
给工作量估计设置一个不连续值开始,而且一个 <code>COLUMNS</code> 格式会和计时总和一起展示这些值
(如果你想计时的话). 对于特定缓冲区,你可以使用:
</p>
<pre class="example">
#+PROPERTY: Effort_ALL 0 0:10 0:30 1:00 2:00 3:00 4:00 5:00 6:00 7:00
#+COLUMNS: %40ITEM(Task) %17Effort(Estimated Effort){:} %CLOCKSUM
</pre>
<p>
或者更好的方法,你可以通过自定义变量 <code>org-global-properties</code> 和
<code>org-columns-default-format</code> 来全局设置这些值. 特别的,如果你想在 agenda 里使用这个
设置,那么建议使用这种全局设置的方法.
</p>

<p>
那么之后为单独事项分配估计值的方法是切换到 column 模式,然后使用 <code>S-&lt;RIGHT&gt;</code> 和
<code>S-&lt;LEFT&gt;</code> 来改变这些值. 这些你键入的值会在层级结构里立即相加起来.在它旁边的列视图
里,所有的计时都会显示.
</p>

<p>
如果你在 daily/weekly agenda 里切换到列视图,工作量估计的一列会总结每天的估计的工
作量<sup><a id="fnr.49" class="footref" href="#fn.49">49</a></sup>, 并且,
你可以使用这个来在你的日程计划里找到空闲时间. 要获得一天中全部工作的概览,你可以
设置选项 <code>org-agenda-columns-add-appointments-to-effort-sum</code>. 某一天中占据了特定时
间段的约会也会被添加到当天的工作量估计中.
</p>

<p>
工作量估计可以用于 <code>/</code> 键触发的二级 agenda 筛选中(参见<a href="#orgde0d47e">Agenda Commands</a>). 如果你对
工作量估值的定义是一致的,那么只需要两次或三次按键就可以缩小列表范围,找到某个可用
的时间段.
</p>
</div>
</div>
<div id="outline-container-org75e1f6d" class="outline-3">
<h3 id="org75e1f6d">计时器(Times)</h3>
<div class="outline-text-3" id="text-org75e1f6d">
<p>
Org 提供了两种类型的计时器.一种是正向计数的相对计时器,在会议或者观看视频期间记笔
记非常有用. 另一种是倒计时计数器.
相对和倒计时由单独的命令开始:
</p>
<dl class="org-dl">
<dt>C-c C-x 0 &#x2013; (org-timer-start)</dt><dd>开始或重置相对计时器.默认情况下,计时器会设置
为0. 当使用 <code>C-u</code> 前缀调用时,提示用户输入开始偏移量.如果光标处有一个计时器字符串
了,则提供一种便利的方法在流程中断后重新开始记笔记,这是默认行为.当使用 <code>C-u C-u</code>
调用时,按特定数量修改选中区域内所有计时器字符串.如果计时器没有在正确的时间启动,
则这用来修正计时器字符串.</dd>
<dt>C-c C-x ; &#x2013; (org-timer-set-timer)</dt><dd>开始倒计时计时器.会提示用户输入一个持续
时间段. <code>org-timer-default-timer</code> 设置默认的倒计时值.使用数字前缀参数会覆盖这个
默认值. 该命令在 agenda 缓冲区里可以通过 <code>;</code> 调用.</dd>
</dl>


<p>
一旦计时器启动,相对和倒计时计时器都用同样的命令控制:
</p>
<dl class="org-dl">
<dt>C-c C-x . &#x2013; (org-timer)</dt><dd>插入一个相对时间到缓冲区. 你第一次调用这个命令时,
计时器会启动.使用前缀参数来重启.</dd>
<dt>C-c C-x - &#x2013; (org-timer-item)</dt><dd>插入一个带当前相对时间的描述列表条目.带上前缀
参数,会先将计时器设置为0.</dd>
<dt>M-&lt;RET&gt; &#x2013; (org-insert-heading)</dt><dd>一旦计时器列表启动了(就是上面那个命令插入的
列表),你可以使用 <code>M-&lt;RET&gt;</code> 来插入新的计时器条目.</dd>
<dt>C-c C-x , &#x2013; (org-timer-pause-or-continue)</dt><dd>暂停计时器,如果已经暂停,则继续计
时.</dd>
<dt>C-c C-x _ &#x2013; (org-timer-stop)</dt><dd>停止计时器.调用这个命令后,你只能重新开始一个
新的计时器,而不能继续使用旧的了.这个命令也会从 mode line 里删除计时器.</dd>
</dl>
</div>
</div>
</div>
<div id="outline-container-orge9fbc8f" class="outline-2">
<h2 id="orge9fbc8f"><span class="done DONE">DONE</span> 重新归档和存档(Refiling and Archiving)</h2>
<div class="outline-text-2" id="text-orge9fbc8f">
<p>
一旦信息存在于系统里,它就可能需要到处移动. Org 为此提供了重新归档,复制和存档命令.重
新归档和复制命令帮助移动和复制大纲.归档有助于保持系统的紧凑型和快速性.
</p>
</div>

<div id="outline-container-org2d99101" class="outline-3">
<h3 id="org2d99101">重新归档和复制(Refile and Copy)</h3>
<div class="outline-text-3" id="text-org2d99101">
<p>
当复习捕获的数据时,你可能会想将其中的一些重新归档或复制到不同的列表中去,例如复制
到一个项目中去.剪切,找到正确位置,然后粘贴笔记是很麻烦的.为了简化这一过程,你可以
使用下面的特殊命令:
</p>
<dl class="org-dl">
<dt>C-c C-w &#x2013; (org-refile)</dt><dd>将光标处的选取或条目重新归档. 这个命令会为重新归档
提供可能的位置,并允许你使用补全来选择一个位置.该条目(或者选取中所有的条目)会被
填充到目标标题下作为一个子条目. 根据 <code>org-reverse-note-order</code> 的值,它会位于第一
个或者最后一个子条目.
默认情况下,当前缓冲区中的层级为1的标题会被视作为目标标题,但是你可以在许多文件
中使用更复杂定义.更多细节请查看变量 <code>org-refile-targets</code>. 如果你想通过文件路径类
似的补全(如沿着大纲路径),请参阅变量 <code>org-refile-use-outline-path</code> 和
<code>org-outline-path-complete-in-steps</code>. 如果你想要能够在重新归档时即时创造一个新的
节点作为新的父节点,请查看变量 <code>org-refile-allow-creating-parent-nodes</code>. 当设置了
变量 <code>org-log-refile</code> <sup><a id="fnr.50" class="footref" href="#fn.50">50</a></sup> 时,每当一个条目被重新归档,就会记录一个时间戳或一
条笔记.</dd>
<dt>C-u C-c C-w</dt><dd>使用重新归档界面来跳转到标题.</dd>
<dt>C-u C-u C-c C-w &#x2013; (org-refile-goto-last-stored)</dt><dd>跳转到 <code>org-refile</code> 命令最后
一次移动到的位置.</dd>
<dt>C-2 C-c C-w</dt><dd>重新归档到当前正在计时的条目的子条目.</dd>
<dt>C-3 C-c C-w</dt><dd>重新归档,并保持条目在原位置.令参阅 <code>org-refile-keep</code> 来使这一行为
默认,请注意,这可能会导致重复的 <code>ID</code> 属性.</dd>
<dt>C-0 C-c C-w 或 C-u C-u C-u C-c C-w &#x2013; (org-refile-cache-clear)</dt><dd>清除目标缓存.重
新归档的目标的缓存功能可以通过设置 <code>org-refile-use-cache</code> 来开启. 为了让命令看到
新的可能的目标,你必须使用这个命令清除缓存.</dd>
<dt>C-c M-w &#x2013; (org-refile-copy)</dt><dd>复制并重新归档. 和重新归档一样工作,只不过不会
删除原笔记.</dd>
<dt>C-c C-M-w &#x2013; (org-refile-reverse)</dt><dd>和重新归档工作原理类似,除了它会暂时切换变
量 <code>org-reverse-note-order</code> 的值如何应用到当前缓冲区的表现. 所以,如果 <code>org-refile</code>
要将条目添加到目标条目的最后一个条目, <code>org-refile-reverse</code> 会将它添加到第一个条
目之前,反之亦然.</dd>
</dl>
</div>
</div>


<div id="outline-container-orgb3e7753" class="outline-3">
<h3 id="orgb3e7753"><span class="done DONE">DONE</span> 存档(Archiving)</h3>
<div class="outline-text-3" id="text-orgb3e7753">
<p>
对已完成的笔记做些什么.
</p>

<p>
当一个(子)树代表的项目被完成了,你可能希望将树移动到以便,并让它不再参与 agenda.
存档对于保持工作文件的紧凑性和全局搜索(例如 agenda 视图的构建)的快速性是很重要的.
</p>

<dl class="org-dl">
<dt>C-c C-x C-a &#x2013; (org-archive-subtree-default)</dt><dd>使用变量
<code>org-archive-default-command</code> 里指定的命令将当前条目存档.</dd>
</dl>
</div>

<div id="outline-container-orgc5c7310" class="outline-4">
<h4 id="orgc5c7310">移动子树(Moving subtrees)</h4>
<div class="outline-text-4" id="text-orgc5c7310">
<p>
移动树到存档文件.
</p>

<p>
最常用的存档操作是移动一个项目树到另一个文件,即存档文件.
</p>

<dl class="org-dl">
<dt>C-c C-x C-s 或 C-c $ &#x2013; (org-archive-subtree)</dt><dd>将从光标出开始的子树存档到
<code>org-archive-location</code> 变量给定的位置.</dd>
<dt>C-u C-c C-x C-s</dt><dd>检查当前标题的任何直接子节点是否能被移动到存档里. 为此,请检
查每个子树里是否有打开的 TODO 事项.如果没有找到打开的 TODO ,该命令会提示你是否
将其移动到存档位置.如果调用该命令时,光标 <b>不在</b> 标题上, 则会检查层级为1的树.</dd>
<dt>C-u C-u C-c C-x C-s</dt><dd>和上面类似,但检查子树的时间戳而不是 TODO 事项. 如果检查
结果不含时间戳或者时间戳是过去时间,该命令会提示你是否将子树存档,</dd>
</dl>


<p>
默认的存档位置是当前文件的相同目录,其名字是通过在当前文件名后添加 <code>_archive</code> 得到
的.你还可以选择存档项目的标题,并可以将其添加到文件的日期树中.有关如何指定文件和
标题的信息和示例,请参阅变量 <code>org-archive-location</code> 的文档字符串.
这个变量也有相应的缓冲区内设置,例如:
</p>
<pre class="example">
#+ARCHIVE: %s_done::
</pre>
<p>
如果你想要为单个条目或子树设置一个特殊的存档位置,给定该条目一个 <code>ARCHIVE</code> 属性,位
置作为属性值(参见 <a href="#orgdb0527e">属性和列(Properties and Columns)</a>).
</p>

<p>
当一个子树被移动时,它会收到一些特殊属性,这些属性记录上下文信息,例如条目来自的文
件,其大纲路径和存档时间等.请配置变量 <code>org-archive-save-context-info</code> 来调整要添加
的信息量.
当 <code>org-archive-subtree-save-file-p</code> 是非 <code>nil</code> 时,保存目标存档缓冲区.
</p>
</div>
</div>
<div id="outline-container-orgdbef97d" class="outline-4">
<h4 id="orgdbef97d">内部存档(Internal archiving)</h4>
<div class="outline-text-4" id="text-orgdbef97d">
<p>
"关掉"树,但仍保留在文件中.
</p>

<p>
如果只是想要关闭某些子树的 agenda 视图,而不是将它们移动到其他文件,你可以使用
<code>ARCHIVE</code> 标签.
</p>

<p>
一个用 <code>ARCHIVE</code> 标签(<a href="#org0792758">标签(Tags)</a>)标记了的标题会保持其在大纲树中的位置,但具有下面
表现:
</p>
<ul class="org-ul">
<li>当你视图使用可视性循环命令时(<a href="#org1ba22fe">标题可视性切换(Visibility Cycling)</a>),它不会被打开
(可见).你可以使用 <code>C-&lt;TAB&gt;</code> 强制切换存档子树可视性,或者设置选项
<code>org-cycle-opne-archived-trees</code>. 常用的大纲命令,例如 <code>outline-show-all</code> 也会打开存
档的子树.</li>
<li>在稀疏树(参见 <a href="#org7e42153">稀疏树(Sparse Trees)</a>)的构造期间,除非配置了选项
<code>org-sparse-tree-open-archived-trees</code> 否则不会公开存档子树中的匹配项.</li>
<li>在 agenda 视图(参见 <a href="#org7296ea5">Agenda Views</a>)构造期间,除非你配置了选项
<code>org-agenda-skip-archived-trees</code> ,否则存档树里的内容都会被忽略.在 agenda 里,你可
以按 <code>v a</code> 来让暂时包括存档.</li>
<li>在导出时(见 <a href="#org9c28439">导出(Exporting)</a>), 只有标题会被导出,存档树不会被导出.使用变量
<code>org-export-with-archived-trees</code> 配置更多细节.</li>
<li>除非变量 <code>org-columns-skip-archived-trees</code> 被配置为 <code>nil</code>, 否则存档的树会被排除在
列视图之外.</li>
</ul>


<p>
下面的命令有助于管理 <code>ARCHIVE</code> 标签:
</p>
<dl class="org-dl">
<dt>C-c C-x a &#x2013; (org-toggle-archive-tag)</dt><dd>切换当前标题的 archive 标签. 当标签被
设置时,标题会变成阴影配色,并且其子树会被隐藏.</dd>
<dt>C-u C-c C-x a</dt><dd>检查当前标题的任意直接子树是否应该被存档.为此,会检查每个子树
中是否有打开的待办事项.如果没有打开的待办事项,该命令会提示你是否为该子树设置
<code>ARCHIVE</code> 标签.如果调用该命令时光标不在某个标题上,那么从层级为1的子树开始检查.</dd>
<dt>C-c C-&lt;TAB&gt; &#x2013; (org-force-cycle-archived)</dt><dd>切换树的可视性,即使它被标记为 <code>ARCHIVE</code>.</dd>
<dt>C-c C-x A &#x2013; (org-arhcive-to-archive-sibling)</dt><dd>将当前条目移动到 <span class="underline">同级存档</span>. 这
是一个有着 <code>Archive</code> 标题和 <code>ARCHIVE</code> 标签的同级条目. 当前条目会成为同级存档的子项,用
这种方法会保留原本的内容,包括继承的标签和在大纲中的大致位置.</dd>
</dl>
</div>
</div>
</div>
</div>

<div id="outline-container-orgadde8a5" class="outline-2">
<h2 id="orgadde8a5"><span class="done DONE">DONE</span> 捕获和附件(Capture and Attachments)</h2>
<div class="outline-text-2" id="text-orgadde8a5">
<p>
任何组织系统系统的一个重要部分就是能快速捕获新点子和任务,并将参考资料与之相关联
的能力. Org 使用一个叫做 <span class="underline">capture</span> 的流程来实现这一能力.它也能用来将与任务(附件)相
关联的文件储存在特殊的目录中.最后,它能解析 RSS 提要来获取信息.要知道如何让外部程
序(如网页浏览器)触发 Org 来捕获材料,请参阅 <a href="#orgeffbbc5">Protocols</a>.
</p>
</div>
<div id="outline-container-org736a35f" class="outline-3">
<h3 id="org736a35f">捕获(Capture)</h3>
<div class="outline-text-3" id="text-org736a35f">
<p>
捕获新事物.
</p>

<p>
<span class="underline">Capture</span> 让你能在不中断工作流程的情况下快速存储笔记. Org 用来捕获新条目的方法深受
John Wiegley 的优秀 <a href="https://github.com/jwiegley/remember">Remember</a> 包的启发.
</p>
</div>
<div id="outline-container-org9b764f7" class="outline-4">
<h4 id="org9b764f7">设置捕获(Setting up capture)</h4>
<div class="outline-text-4" id="text-org9b764f7">
<p>
下面的自定义设置了一个笔记的默认目标文件:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">setq</span> org-default-notes-file (concat org-directory <span style="font-style: italic;">"/notes.org"</span>))
</pre>
</div>
<p>
你可以定义一个全局快捷键来捕获新材料(参见<a href="#org0cf7316">激活(Activation)</a>)
</p>
</div>
</div>

<div id="outline-container-orgdbc4925" class="outline-4">
<h4 id="orgdbc4925">使用捕获(Using capture)</h4>
<div class="outline-text-4" id="text-orgdbc4925">
<dl class="org-dl">
<dt>M-x org-capture &#x2013; (org-capture)</dt><dd>显示捕获模版菜单. 如果你定义了模版
(参见<a href="#orgb6e3898">捕获模版(Capture templates)</a>), 该命令会提供这些模版供你选择或者是使用一个
新的Org 大纲节点作为默认模版.该命令会插入模版到目标文件中,并切换到一个定位到新
节点的间接缓冲区.然后,你可以插入所需要的信息了.</dd>
<dt>C-c C-c &#x2013; (org-capture-finalize)</dt><dd>一旦你完成了键入信息到捕获缓冲区里的工作,
<code>C-c C-c</code> 会让你返回捕获操作之前的窗口配置,这样你就可以继续工作,而不会进一步分心.当
带上前缀参数调用时,完成操作并跳转到捕获的条目位置.</dd>
<dt>C-c C-w &#x2013; (org-capture-refile)</dt><dd>通过将笔记重新归档到其他地方来完成捕获操作
(参见 <a href="#org2d99101">重新归档和复制(Refile and Copy)</a>). 请注意,这将会执行一个常规的重新归档命
令,因此,在你运行这个命令时光标的位置是很重要的.如果你插入了一个带有父级和子级
节点的树,请先将光标移动到父节点位置.所有传递给该命令的前缀参数都会传递给
<code>org-refile</code> 命令.</dd>
<dt>C-c C-k &#x2013; (org-capture-kill)</dt><dd>中止捕获操作并返回到之前的窗口.</dd>
</dl>


<p>
你也可以从 agenda 里使用一种特殊的方式调用 <code>org-capture</code>, 就是使用 <code>k c</code> 的快捷键组
合.使用这种方式调用,所有根据选中模版插入的时间戳都会默认为 agenda 里光标位置处的
日期,而不是当前日期.
</p>

<p>
要找到最近存储的捕获的位置,请使用带前缀参数的 <code>org-capture</code> 命令:
</p>
<dl class="org-dl">
<dt>C-u M-x org-capture</dt><dd>访问一个捕获模版的目标位置.你要和平常一样选择模版.</dd>
<dt>C-u C-u M-x org-capture</dt><dd>在最近捕获的条目的缓冲区里浏览该条目.</dd>
</dl>


<p>
你也可以跳转到书签 <code>org-capture-last-stored</code> 处,它是自动创建的,除非你将
<code>org-capture-bookmark</code> 设置为 <code>nil</code>.
</p>
</div>
</div>
<div id="outline-container-orgb6e3898" class="outline-4">
<h4 id="orgb6e3898">捕获模版(Capture templates)</h4>
<div class="outline-text-4" id="text-orgb6e3898">
<p>
你可以为不同类型的捕获条目和不同的目标位置使用模版.创建模版的最容易的方法就是通
过自定义界面.
</p>

<dl class="org-dl">
<dt>C</dt><dd>自定义变量 <code>org-capture-templates</code>.</dd>
</dl>


<p>
在我们给出模版定义的正式解释之前,让我们来看一个例子.假设你想使用一个模版来创建常
规待办事项,而且你想将这些事项放在 <code>~/org/gtd.org</code> 文件的 <code>Tasks</code> 标题下.此外,文件
<code>journal.org</code> 里的日期树应该捕获日记条目.那么一个可能的配置就像下面这样:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">setq</span> org-capture-templates
      '((<span style="font-style: italic;">"t"</span> <span style="font-style: italic;">"Todo"</span> entry (file+headline <span style="font-style: italic;">"~/org/gtd.org"</span> <span style="font-style: italic;">"Tasks"</span>)
         <span style="font-style: italic;">"* TODO %?\n  %i\n  %a"</span>)
        (<span style="font-style: italic;">"j"</span> <span style="font-style: italic;">"Journal"</span> entry (file+datetree <span style="font-style: italic;">"~/org/journal.org"</span>)
         <span style="font-style: italic;">"* %?\nEntered on %U\n  %i\n  %a"</span>)))
</pre>
</div>
<p>
如果你在捕获菜单里按 <code>t</code>, Org 会为你准备一个这样的模版:
</p>
<pre class="example">
* TODO
  [[file:LINK TO WHERE YOU INITIATED CAPTURE]]
</pre>
<p>
在模版的扩展过程中, <code>%a</code> 被一个链接到你调用捕获命令的位置的链接替换.例如,这对于从
电子邮件中获取任务非常有用. 你填写完任务的定义,然后按 <code>C-c C-c</code> ,Org 会将您返回到
开始捕获过程的同一位置.
</p>

<p>
要定义一个特殊的快捷键用来捕获特定的模版而不通过交互性的模版选择,你可以创建这样
的快捷键绑定:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(define-key global-map (kbd <span style="font-style: italic;">"C-c x"</span>)
  (<span style="font-weight: bold;">lambda</span> () (<span style="font-weight: bold;">interactive</span>) (org-capture nil <span style="font-style: italic;">"x"</span>)))
</pre>
</div>
</div>

<ul class="org-ul">
<li><a id="orgc2648f8"></a>模版元素(Template elements)<br />
<div class="outline-text-5" id="text-orgc2648f8">
<p>
完整的模版条目需要些什么.
</p>

<p>
现在,让我们来看看模版定义中的元素. <code>org-capture-templates</code> 中的每个条目都是一个带
有下面元素的条目:
</p>
<dl class="org-dl">
<dt>keys</dt><dd><p>
选择模版的快捷键,字符串形式,仅限字符,例如, <code>a</code> 表示要使用单个键选择模版,
或者 <code>bt</code> 表示两个键选择模版.当使用多个键时,使用同一前缀的键在列表里必须是连续的,并
且前面必须有一个解释前缀键的两个元素的条目,例如:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-style: italic;">"b"</span> <span style="font-style: italic;">"Templates for marking stuff to buy"</span>)
</pre>
</div>
<p>
如果你没有为 <code>C</code> 键定义一个模版,该键会打开这个复杂变量的自定义缓冲区.
</p></dd>
<dt>description</dt><dd>一个描述模版的简短字符串,在模版选择期间显示.</dd>
<dt>type</dt><dd>条目的类型,是一个 symbol. 有效的值为:
<dl class="org-dl">
<dt>entry</dt><dd>一个 Org 节点,带标题.会被作为目标条目的子条目或顶级条目填入.目标文
件应该为 Org 文件.</dd>
<dt>item</dt><dd>一个简单列表项,位于目标位置的第一个简单列表.同样,目标文件应该为 Org
文件.</dd>
<dt>checkitem</dt><dd>一个复选框项.只与默认模版下的简单列表不同.</dd>
<dt>table-line</dt><dd>目标位置第一个表格的一个新行.插入该行的具体位置取决于属性
<code>:prepend</code> 和 <code>:table-line-pos</code> (见下文).</dd>
<dt>plain</dt><dd>按原样插入的文本.</dd>
</dl></dd>
<dt>taeget</dt><dd>捕获的条目应该放置在哪里的说明.在 Org 文件里,目标通常是定义一个节点.捕
获的条目会称为这个目标节点的子条目.捕获的其他类型会被添加到这个节点内容的表格
或列表里.大多数目标说明包含有文件名.如果文件名是空字符串,那么文件名默认为变量
<code>org-default-notes-file</code> 的值.文件也可以由一个变量或者由一个不带参数的方法给出.当
没有使用绝对路径指明目标位置时,路径是相对于变量 <code>org-directory</code> 定义的路径的.
有效的 target 值为:
<dl class="org-dl">
<dt>(file "path/to/file")</dt><dd>文本会被放置到该文件的开头或末尾.</dd>
<dt>(id "id of existing org entry")</dt><dd>作为该条目的子条目或者作为该条目的内容填
入.</dd>
<dt>(file+headline "filename" "node headline")</dt><dd>如果目标标题在文件中是唯一的,
则使用这种快速配置.</dd>
<dt>(file+olp "filename" "Level 1 heading" "Level 2" &#x2026;)</dt><dd>对于非唯一的标题,使
用完整路径更为安全.</dd>
<dt>(file+regexp "filename" "regexp to find location")</dt><dd>使用正则表达式来定位.</dd>
<dt>(file+olp+datetree "filename" [ "Level 1 heading" &#x2026;])</dt><dd>这个目标<sup><a id="fnr.51" class="footref" href="#fn.51">51</a></sup>
在日期树<sup><a id="fnr.52" class="footref" href="#fn.52">52</a></sup> 里为今天的日期创建一个标题.如
果给定了可选的大纲路径(方括号的部分表示可选内容),那么树将会在路径指定的节点
下构建.附加选项请查看下面的 <code>:time-prompt</code> 和 <code>:tree-type</code> 属性.</dd>
<dt>(file+function "filename" function-finding-location)</dt><dd>一个在文件中查找正确
位置的方法.</dd>
<dt>(clock)</dt><dd>定位到当前正在计时的条目</dd>
<dt>(function function-finding-location)</dt><dd>最常用的方式:编写你自己的方法来访问
文件并将光标移动到正确位置.</dd>
</dl></dd>
<dt>template</dt><dd><p>
创建捕获的条目的模版.如果你将这个元素留空,一个合适的默认模版将会被
使用.否则,这是一个带转义码的字符串,其内容将会根据捕获调用的时间和上下文进行替
换.你也可以从一个文件<sup><a id="fnr.53" class="footref" href="#fn.53">53</a></sup>里获得这个模版字符串,或者使用下面任一语法从函数里动态获
取次模版字符串:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(file <span style="font-style: italic;">"/path/to/template-file"</span>)
(<span style="font-weight: bold;">function</span> FUNCTION-RETURNING-THE-TEMPLATE)
</pre>
</div></dd>
<dt>properties</dt><dd>模版条目剩下的部分是一个额外选项的属性列表.
可识别的属性有:
<dl class="org-dl">
<dt>:prepend</dt><dd>正常情况下,新捕获的信息会被追加到目标位置之后(最后一个子条目,最
后一个表格行,最后一个列表项,&#x2026;), 设置该属性会改变这一行为.</dd>
<dt>:immediate-finish</dt><dd>当设置了该属性时,不会提供编辑信息的功能,只会将信息立即
归档.如果模版只需要可以自动添加的信息,这样做是有意义的.</dd>
<dt>:jump-to-captured</dt><dd>当设置了该属性,完成捕获操作时会跳转到捕获的条目位置.</dd>
<dt>:empty-lines</dt><dd>该属性设置新项目前面和后面要插入的空白行的数目.默认为0,唯一
的其他常用值为1.</dd>
<dt>:empty-lines-after</dt><dd>该属性设置新条目之后要插入的空白行数目.会覆盖
<code>:empty-lines</code> 设置的新条目之后的空白行数.</dd>
<dt>:empty-lines-before</dt><dd>设置该属性为新条目之前要被插入的空白行数目.会覆盖
<code>:empty-lines</code> 设置的新条目之前的空白行树.</dd>
<dt>:clock-in</dt><dd>在这个条目里开始计时.</dd>
<dt>:clock-keep</dt><dd>在填写捕获的条目时保持计时运行.</dd>
<dt>:clock-resume</dt><dd>如果启动捕获中断了一个计时,配置该选项会在完成捕获时重新开始
该计时过程.请注意 <code>:clock-keep</code> 比 <code>:clock-resume</code> 的优先级要高.当将这两个属性都
设置为非 <code>nil</code> 时,当前的计时会继续运行,上一个计时不会恢复(也就是这个属性不会生
效).</dd>
<dt>:time-prompt</dt><dd>在填写模版和日期/星期树时提示输入日期/时间.不使用这个属性,捕
获会使用当前日期和时间.即使这个属性没有被设置,你也可以通过调用带前缀参数 <code>C-1</code>
的 <code>org-capture</code> 命令来强制使用这一行为.</dd>
<dt>:tree-type</dt><dd>使用 <code>week</code> 来生成一个星期树而不是一个月-日树,也就是说,将每一天
的标题放置到当前 ISO 周的标题下. 使用 <code>month</code> 来将条目仅按月份分组.默认为按天
分组.</dd>
<dt>:unnarrowed</dt><dd>不缩小缓冲区,只显示完整的缓冲区.默认行为是将缓冲区缩小,以便只
看到新的材料.</dd>
<dt>:table-line-pos</dt><dd>指明新的表格行应该插入到表格里的位置. 该属性值应该是像
<code>II-3</code> 这样的字符串,意思是新的行应该称为第二个水平分割线之前部分的第三个行.</dd>
<dt>:kill-buffer</dt><dd>如果目标文件在启动捕获时未被访问过,那么在捕获过程完成之后关
闭缓冲区.</dd>
<dt>:no-save</dt><dd>在完成捕获后不保存目标文件.也就是说将新捕获的内容添加到缓冲区,但
不保存到硬盘中.</dd>
<dt>~:refile-targets</dt><dd>暂时将 'org-refile-targets' 的值设置为该属性的值.</dd>
</dl></dd>
</dl>
</div>
</li>
<li><a id="org9a3a21c"></a>模版扩展(Template expansion)<br />
<div class="outline-text-5" id="text-org9a3a21c">
<p>
填写关于时间和内容的信息.
</p>

<p>
在模版里,特殊的 "%-escapes"<sup><a id="fnr.54" class="footref" href="#fn.54">54</a></sup> 允许内容的动态插入.模版按此处给出的顺序扩展:
</p>
<dl class="org-dl">
<dt>%[FILE]</dt><dd>插入 FILE 给定的文件内容.</dd>
<dt>%(EXP)</dt><dd>执行 Elisp 表达式 EXP 并将该转义替换为执行结果.这个 EXP 表单必须返回
一个字符串.只有模版中预先存在的占位符或者由 <code>%[file]</code> 引入的占位符按这种方式展开.因
为这是在扩展非交互式的 "%-escapes" 之后发生的,所以可以用这些来填充表达式.</dd>
<dt>%&lt;FORMAT&gt;</dt><dd>格式规范中格式时间字符串的结果.</dd>
<dt>%t</dt><dd>时间戳,仅限日期.</dd>
<dt>%T</dt><dd>时间戳,日期和时间.</dd>
<dt>%u, %U</dt><dd>和上面 %t, %T 类似,但插入未激活的时间戳:<span class="timestamp-wrapper"><span class="timestamp">[2022-05-17 Tue]</span></span></dd>
<dt>%i</dt><dd>初始文本,在调用捕获时处于激活状态的选中区域.如果在同一行的 <code>%i</code> 之前有文本,例
如缩进,而且 <code>%i</code> 不在一个 <code>%(exp)</code> 表单里,那么该前缀会被添加到插入的文本的每一行之
前.</dd>
<dt>%a</dt><dd>批注,注解,注释(annotation),通常是由 <code>org-store-link</code> 创建的链接.</dd>
<dt>%A</dt><dd>类似于 <code>%a</code> ,但是提示你输入描述部分.</dd>
<dt>%l</dt><dd>类似于 <code>%a</code> ,但是只插入文本链接.</dd>
<dt>%L</dt><dd>类似于 <code>%l</code> ,但没有括号(只含链接内容本身).</dd>
<dt>%c</dt><dd>当前剪切环的头部.</dd>
<dt>%x</dt><dd>X 剪切板的内容.</dd>
<dt>%k</dt><dd>当前计时的任务的标题.</dd>
<dt>%K</dt><dd>连接到当前计时的任务的链接.</dd>
<dt>%n</dt><dd>用户名(来自变量 <code>user-full-name</code>)</dd>
<dt>%f</dt><dd>当调用捕获时当前缓冲区正在访问的文件.</dd>
<dt>%F</dt><dd>当前缓冲区正在访问的文件或目录的完整路径.</dd>
<dt>%:keyword</dt><dd>特定链接类型的具体信息,见下文.</dd>
<dt>%^g</dt><dd>提示你输入标签,并使用目标文件里的标签进行补全.</dd>
<dt>%^G</dt><dd>提示你输入标签,并使用所有 agenda 文件里的所有标签进行补全.</dd>
<dt>%^t</dt><dd>类似于 <code>%t</code> 但提示你输入日期. 类似的还有 <code>%^T</code> , <code>%^u</code> , <code>%^U</code> .你也可以定义一
个这样的提示: <code>%^{Birthday}t</code>.</dd>
<dt>%^C</dt><dd>交互式选择使用哪个剪切环或剪切板.</dd>
<dt>%^L</dt><dd>类似于 <code>%^C</code> 但是作为一个链接插入.</dd>
<dt>%^{PROP}p</dt><dd>提示用户输入属性 PROP 的值.你可以使用 <code>%^{PROP|default}</code> 来指定默认
值.</dd>
<dt>%^{PROMPT}</dt><dd>提示用户输入用来替换该序列的字符串.你可以使用
<code>%^{prompt|default|completion2|completion3...}</code> 来指定默认值和一个补全表. 方向键
访问提示的历史记录.</dd>
<dt>%\N</dt><dd>插入输入的第 N 个 <code>%^{PROMPT}</code> 的文本, N 是数字,从1开始.</dd>
<dt>%?</dt><dd>在补全模版之后,将光标放置到此处.</dd>
</dl>


<p>
对于特定的链接类型,定义了下面的关键字<sup><a id="fnr.55" class="footref" href="#fn.55">55</a></sup>:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">链接类型</th>
<th scope="col" class="org-left">可用关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">bbdb</td>
<td class="org-left"><code>%:name</code> , <code>%:company</code></td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">irc</td>
<td class="org-left">‘%:server’, ‘%:port’, ‘%:nick’</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">mh, rmail</td>
<td class="org-left">‘%:type’, ‘%:subject’, ‘%:message-id’</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">‘%:from’, ‘%:fromname’, ‘%:fromaddress’</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">‘%:to’, ‘%:toname’, ‘%:toaddress’</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">‘%:date’ (message date header field)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">‘%:date-timestamp’ (date as active timestamp)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">‘%:date-timestamp-inactive’ (date as inactive timestamp)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">‘%:fromto’ (either “to NAME” or “from NAME”)<sup><a id="fnr.56" class="footref" href="#fn.56">56</a></sup></td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">gnus</td>
<td class="org-left">‘%:group’, for messages also all email fields</td>
</tr>

<tr>
<td class="org-left">w3, w3m</td>
<td class="org-left">‘%:url’</td>
</tr>

<tr>
<td class="org-left">info</td>
<td class="org-left">‘%:file’, ‘%:node’</td>
</tr>

<tr>
<td class="org-left">calendar</td>
<td class="org-left">‘%:date’</td>
</tr>

<tr>
<td class="org-left">org-protocol</td>
<td class="org-left">‘%:link’, ‘%:description’, ‘%:annotation’</td>
</tr>
</tbody>
</table>
</div>
</li>
<li><a id="org7923007"></a>上下文中的模版(Templates in contexts)<br />
<div class="outline-text-5" id="text-org7923007">
<p>
仅在特定上下文中显示模版.
</p>

<p>
要控制一个捕获模版是否能在特定上下文中可以被访问,你可以自定义变量
<code>org-capture-templates-contexts</code>. 例如,假设你有一个捕获模版 "p", 用于储存包含补丁
的 Gnus 电子邮件.那么你可以将该选项设置为下面这个样子:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">setq</span> org-capture-templates-contexts
      '((<span style="font-style: italic;">"p"</span> ((in-mode . <span style="font-style: italic;">"message-mode"</span>)))))
</pre>
</div>
<p>
你也可以让命令快捷键 <code>p</code> 指向另一模版.在这种情况下,像这样添加该命令快捷键:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">setq</span> org-capture-templates-contexts
      '((<span style="font-style: italic;">"p"</span> <span style="font-style: italic;">"q"</span> ((in-mode . <span style="font-style: italic;">"message-mode"</span>)))))
</pre>
</div>
<p>
更多信息请查阅变量的文档字符串.
</p>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-orge357962" class="outline-3">
<h3 id="orge357962">附件(Attachments)</h3>
<div class="outline-text-3" id="text-orge357962">
<p>
将文件附加到大纲.
</p>

<p>
将参考资料和大纲节点关联起来通常是很有用的.小的纯文本块可以简单的存储在项目的子
树中.超链接(见<a href="#org4ead1a4">超链接(Hyperlinks)</a>) 可以与本地甚至是远程计算机上其他位置的文件建
立关联, 例如属于项目的电子邮件或者源代码文件.
</p>

<p>
另一种建立关联的方法就是附件,它是属于大纲节点的目录中的文件. Org 使用由每个条目
唯一的 ID 或者 <code>DIR</code> 属性来命名的目录.
</p>
</div>


<div id="outline-container-orga642faf" class="outline-4">
<h4 id="orga642faf">附件默认设置和调度程序(Attachment defaults and dispatcher)</h4>
<div class="outline-text-4" id="text-orga642faf">
<p>
如何访问附件命令
</p>

<p>
默认情况下, Org attach(附加操作) 在向大纲节点添加附件时使用 ID 属性.这使得附件的
使用完全自动化.无需决定文件夹名称或位置.基于 ID 的目录默认位于 <code>data/</code> 目录中,该目
录和你的 Org 文件所在目录相同<sup><a id="fnr.57" class="footref" href="#fn.57">57</a></sup>.
</p>

<p>
当使用 <code>org-attach</code> 命令生成一个附件时,一个默认的 <code>ATTACH</code> 标签会被添加到获取附件的
节点上.
</p>

<p>
关于对设置的更多控制,请参见 <a href="#orgac1ccaa">附件选项(Attachment options)</a>.
</p>

<p>
下面的命令用来处理附件:
</p>
<dl class="org-dl">
<dt>C-c C-a &#x2013; (org-attach)</dt><dd>该命令的调度器与附件系统相关.在使用该快捷键后,会展
示一个命令列表,你必须按另一个按键来选择命令:
<dl class="org-dl">
<dt>a &#x2013; (org-attach-attach)</dt><dd>选择一个文件并将它移动到任务的附件目录.该文件是
被复制,移动或链接取决于 <code>org-attach-method</code> 的设置.请注意,并非所有系统都支持硬
链接.</dd>
<dt>c/m/l</dt><dd>使用复制(c)/移动(m)/链接(l) 方式附加一个文件.请注意,并非所有系统都
支持硬链接.</dd>
<dt>b &#x2013; (org-attach-buffer)</dt><dd>选择一个缓冲区,并将其保存为任务的附件目录中的文
件.</dd>
<dt>n &#x2013; (org-attach-new)</dt><dd>创建一个新的附件作为一个 Emacs 缓冲区.</dd>
<dt>z &#x2013; (org-attach-sync)</dt><dd>将当前任务和其附件目录同步,以防你自己添加了附件.</dd>
<dt>o &#x2013; (org-attach-open)</dt><dd>打开当前任务的附件.如果附件数多于1,则提示你先输入
文件名.打开方式遵循  <code>org-file-apps</code> 设置的规则.更多细节请查看超链接的信息(请
参阅<a href="#org78b3dfa">处理链接(Handling Links)</a>).</dd>
<dt>O &#x2013; (org-attach-open-in-emacs)</dt><dd>也是打开附件,但是强制在 Emacs 里打开文件.</dd>
<dt>f &#x2013; (org-attach-reveal)</dt><dd>打开当前任务的附件目录.</dd>
<dt>F &#x2013; (org-attach-reveal-in-emacs)</dt><dd>也是打开目录,但是强制在 Emacs 里使用
Dired 打开.</dd>
<dt>d &#x2013; (org-attach-delete-one)</dt><dd>选择并删除单个附件.</dd>
<dt>D &#x2013; (org-attach-delete-all)</dt><dd>删除任务的所有附件.另一个更安全的方法是在
Dired 里打开目录然后再删除附件.</dd>
<dt>s &#x2013; (org-attach-set-directory)</dt><dd>设置一个特定路径作为条目的附件目录.这是通
过将目录路径放到 <code>DIR</code> 属性值里实现的.</dd>
<dt>S &#x2013; (org-attach-unset-directory)</dt><dd>删除附件目录.这个命令会移除 <code>DIR</code> 属性,并
询问用户是否移动该目录下的内容,如果设置了 <code>ID</code> 属性,则删除内容,或者让目录保持
原样,但不再附加到大纲节点.</dd>
</dl></dd>
</dl>
</div>
</div>

<div id="outline-container-orgac1ccaa" class="outline-4">
<h4 id="orgac1ccaa">附件选项(Attachment options)</h4>
<div class="outline-text-4" id="text-orgac1ccaa">
<p>
配置附件系统
</p>

<p>
有一些附件的选项值得一提:
</p>
<dl class="org-dl">
<dt>org-attach-id-dir</dt><dd>当使用 <code>ID</code> 方法时,存储附件的目录.</dd>
<dt>org-attach-dir-relative</dt><dd>当使用 <code>C-c C-a s</code> &#x2013; (org-attach-set-directory) 为一
个节点设置 <code>DIR</code> 属性时,默认键入绝对路径链接.这个选项将其更改为相对路径链接.</dd>
<dt>org-attach-use-inheritance</dt><dd><p>
默认情况下,附加到大纲节点的目录是根据
<code>org-use-property-inheritance</code> 定义的值继承来的.如果你想要专门设置Org attach 的
继承,可以使用 <code>org-attach-use-inheritance</code> 来完成这一设置.大多数情况下,通过节点
层级结构继承文档是非常有意义的.特别是当使用附件链接的时候,请参见
<a href="#org7b0a556">附件链接(Attachment links)</a>. 下面的例子展示了一个附件继承的用例:
</p>
<pre class="example">
* Chapter A ...
  :PROPERTIES:
  :DIR: Chapter A/
  :END:
** Introduction
Some text

#+NAME: Image 1
[[attachment:image 1.jpg]]
</pre>
<p>
若不使用继承,则不能解析图片 'image 1.jpg' 的链接,因为该链接是位于 'Chapter A'
的子标题里的.
继承对 <code>ID</code> 和 <code>DIR</code> 属性的作用方式相同.如果两种属性都在同一个标题中定义了,那么
<code>DIR</code> 优先级较高.这在启用了继承功能时也生效.如果 <code>DIR</code> 是从大纲里的父级节点继承来
的,该属性仍然有比节点自身定义的 <code>ID</code> 属性高的优先级.
</p></dd>
<dt>org-attach-method</dt><dd>当使用调度器 <code>C-c C-a</code> 附加文件时,它的默认方式是复制文件.该
行为可以通过自定义 <code>org-attach-method</code> 来修改.可用选项是 cp,mv,ln 和 lns. 具体作
用请参考该变量(选项)的文档字符串.</dd>
<dt>org-attach-preferred-new-method</dt><dd>这个自定义让你选择在没有 <code>ID</code> 和 <code>DIR</code> 属性时附
加到节点的默认方式.它的默认值是 id, 但是也可以被设置为 dir, ask 或 nil.</dd>
<dt>org-attach-archive-delete</dt><dd>配置该选项来决定在存档包含附件的子树时是否应该删
除附件.</dd>
<dt>org-attach-auto-tag</dt><dd>当附加文件到一个标签时,根据这个选项设置的标签值为该标题
设置一个标签.</dd>
<dt>org-attach-id-to-path-function-list</dt><dd>当附件使用 <code>ID</code> 时, ID 将会被解析为目录路
径的一部分.默认的方法请查看 <code>org-attach-id-uuid-folder-format</code>. 如果你想要另一种
文件夹结构,请定义一个新的方法并将其添加为 <code>org-attach-id-to-path-function-list</code>
的第一个元素.将现有 ID 解析为路径时,将尝试此列表中的所有函数,以保持与系统中现
有文件夹的向后兼容.</dd>
<dt>org-attach-store-link-p</dt><dd>保存一个正在被附加的文件的链接.该链接被保存到
<code>org-store-links</code> 里,以便随后使用 <code>C-c C-l</code> 插入(参见<a href="#org78b3dfa">处理链接(Handling Links)</a>). 根据 <code>org-attach-store-link-p</code> 里设置的值,该链接会是指向原位置的文件链
接,一个指向附件位置的附件链接或者是一个指向附件位置的文件链接.</dd>
<dt>org-attach-commands</dt><dd>附件调度器里使用的所有命令的列表.</dd>
<dt>org-attach-expert</dt><dd>当 <code>org-attach-expert</code> 被设置为非 <code>nil</code> 时,不会显示附件调度器
的界面缓冲区.就是你不需要使用调度器界面来帮助你使用这些命令.</dd>
</dl>


<p>
如果你想修改默认的设置,参见自定义组 <code>Org Attach</code>.
</p>
</div>
</div>

<div id="outline-container-org7b0a556" class="outline-4">
<h4 id="org7b0a556">附件链接(Attachment links)</h4>
<div class="outline-text-4" id="text-org7b0a556">
<p>
附件的超链接访问
</p>

<p>
可以使用附件链接来引用附件文件和文件夹.这样可以很容易引用添加到大纲节点里的材料.尤
其是当它使用的是条目的唯一 ID 进行附加时.
</p>
<pre class="example">
* TODO Some task
  :PROPERTIES:
  :ID:       95d50008-c12e-479f-a4f2-cc0238205319
  :END:
See attached document for more information: [[attachment:info.org]]
</pre>
<p>
关于这些链接的更多信息请参阅 <a href="#orgf0a99bf">外部链接(External Links)</a>.
</p>
</div>
</div>
<div id="outline-container-org9b29fbd" class="outline-4">
<h4 id="org9b29fbd">使用 Git 进行自动版本控制(Automatic version-control with Git)</h4>
<div class="outline-text-4" id="text-org9b29fbd">
<p>
所有内容都安全存储起来.
</p>

<p>
如果附加到大纲节点的目录是一个 Git 仓库, Org 能配置成当检测到修改时自动提交修改
到该仓库.
</p>

<p>
要让 Org mode 替你管理附件的版本控制,请将下面配置添加到 Emacs 配置里:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">require</span> '<span style="font-weight: bold; text-decoration: underline;">org-attach-git</span>)
</pre>
</div>
</div>
</div>


<div id="outline-container-orgf748518" class="outline-4">
<h4 id="orgf748518">从 Dired 附加(Attach from Dired)</h4>
<div class="outline-text-4" id="text-orgf748518">
<p>
使用 dired 来选择附件.
</p>

<p>
可以将文件从一个 Dired 缓冲区里附加到子树.要使用这个特性,打开一个包含要附加文件
的 Dired mode 的窗口和另一个光标位于要添加附件的子树上的窗口. 在 Dired 窗口里,将
光标放置到文件上, <code>M-x org-attach-dired-to-subtree</code> 使用 <code>org-attach-method</code> 里定义
的方法将文件附加到子树. 当 Dired 窗口里的文件被标记时,所有标记的文件都会被附加到
子树.
</p>

<p>
将下面的行添加到 Emacs 初始化文件中来让 <code>C-c C-x a</code> 在 Dired 缓冲区里附加文件:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-hook 'dired-mode-hook
          (<span style="font-weight: bold;">lambda</span> ()
            (define-key dired-mode-map
              (kbd <span style="font-style: italic;">"C-c C-x a"</span>)
              #'org-attach-dired-to-subtree)))
</pre>
</div>

<p>
下面的代码展示了如何将上一个命令与特定附件方法绑定:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-hook 'dired-mode-hook
          (<span style="font-weight: bold;">lambda</span> ()
            (define-key dired-mode-map (kbd <span style="font-style: italic;">"C-c C-x c"</span>)
              (<span style="font-weight: bold;">lambda</span> ()
                (<span style="font-weight: bold;">interactive</span>)
                (<span style="font-weight: bold;">let</span> ((org-attach-method 'cp))
                  (call-interactively #'org-attach-dired-to-subtree))))))

</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orga17c781" class="outline-3">
<h3 id="orga17c781">RSS 订阅(RSS Feads)</h3>
<div class="outline-text-3" id="text-orga17c781">
<p>
从 RSS 提要中获得输入.
</p>

<p>
Org 可以基于 RSS 订阅和 Atom 订阅里找到的信息添加和改变条目.你可以使用它在播客提
要里为每一个新播客创建任务.或者,你可以使用基于收集的 Web 笔记创建服务将任务导入
到 Org 中.要访问订阅,请配置变量 <code>org-feed-alist</code>. 这个变量的文档字符串有详细的信息.使
用下面配置:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">setq</span> org-feed-alist
      '((<span style="font-style: italic;">"Slashdot"</span>
         <span style="font-style: italic;">"https://rss.slashdot.org/Slashdot/slashdot"</span>
         <span style="font-style: italic;">"~/txt/org/feeds.org"</span> <span style="font-style: italic;">"Slashdot Entries"</span>)))
</pre>
</div>
<p>
每当使用下面命令时,由 <code>rrs.slashdot.org</code> 提供的订阅里的新条目会生成文件
<code>~/org/feeds.org</code> 里 <code>Slashdot Entries</code> 标题下的新条目:
</p>
<dl class="org-dl">
<dt>C-c C-x g &#x2013; (org-feed-update-all)</dt><dd>从 <code>org-feed-alist</code> 中配置的订阅里收集条目
并进行操作.</dd>
<dt>C-c C-x G &#x2013; (org-feed-goto-inbox)</dt><dd>提示输入订阅名并跳转到这个订阅配置的收件
夹.</dd>
</dl>


<p>
在相同标题之下,Org 会创建一个 <code>FEEDSTATUS</code> 抽屉,其中存储了关于订阅的条目状态的信息,以
避免多次添加相同的条目.
</p>

<p>
关于如何阅读 Atom 订阅的更多信息,请查阅 <code>org-feed.el</code> 包和 <code>org-feed-alist</code> 的文档字符
串.
</p>
</div>
<div id="outline-container-org43e805e" class="outline-4">
<h4 id="org43e805e">测试</h4>
<div class="outline-text-4" id="text-org43e805e">
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">setq</span> org-feed-alist
      '((<span style="font-style: italic;">"ReadingWorldMagazine"</span>
         <span style="font-style: italic;">"https://readingworldmagazine.com/index.xml"</span>
         <span style="font-style: italic;">"~/MyLife/org/feeds.org"</span> <span style="font-style: italic;">"ReadingWorld Entries"</span>)))
</pre>
</div>

<p>
使用 <code>C-c C-x G</code> 可以跳转到 feeds.org 文件的 ReadingWorld Entries 标题, 再使用  <code>C-c
C-x g</code> 可以从网站的 RSS 接口里读取摘要到该条目里.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org7296ea5" class="outline-2">
<h2 id="org7296ea5"><span class="todo TODO">TODO</span> Agenda Views</h2>
<div class="outline-text-2" id="text-org7296ea5">
<p>
由于 Org 运行的方式, TODO 条目,有时间戳的条目和有标签的标题可以分散在整个文件中
或者分散在若干文件中. 要获取打开的行动项目或是特定日期的重要事件的概述,这些信息
必须要以有组织的方式进行收集,排序和展示.
</p>

<p>
Org 可以基于各种标准选择条目并将他们展示在一个单独的缓冲区. Org 提供六个不同的视
图类型:
</p>
<ul class="org-ul">
<li>agenda: 类似于日历,并且显示特定日期的信息.</li>
<li>TODO 列表: 包括所有未完成的行动项目.</li>
<li>match view: 基于标签,属性和相关的TODO状态显示标题.</li>
<li>text search view: 该视图显示多个文件中包含特定关键字的所有条目.</li>
<li>stuck projctse view: 显示当前并未进行的项目.</li>
<li>custom views: 特殊的查询和不同视图的组合.</li>
</ul>


<p>
提取的信息会展示在一个特殊的 agenda 缓冲区里. 这个缓冲区是只读的,但是提供了在原
始Org 文件里访问相应的位置的命令,甚至是远程编辑他们的命令.
</p>

<p>
默认设置下,这些视图忽略注释(<a href="#org63f66ca">注释行(Comment Lines)</a>)和存档条目(<a href="#orgdbef97d">内部存档(Internal archiving)</a>). 你可以通过设置 <code>org-agenda-skip-comment-trees</code> 和
<code>org-agenda-skip-archived-trees</code> 为 <code>nil</code> 来覆盖这一行为.
</p>

<p>
这两个变量控制 agenda 缓冲区是如何显示的,以及当 agenda 存在时是否恢复窗口配置:
<code>org-agenda-window-setup</code>  和 <code>org-agenda-restore-windows-after-quit</code>.
</p>
</div>

<div id="outline-container-org8eeff9b" class="outline-3">
<h3 id="org8eeff9b">Agenda Files</h3>
<div class="outline-text-3" id="text-org8eeff9b">
<p>
视图文件,用来搜索 agenda 信息的文件.
</p>

<p>
用来展示的信息通常都是从所有 agenda (议程)文件中搜集来的, agenda 文件就是变量
<code>org-agenda-files</code> <sup><a id="fnr.58" class="footref" href="#fn.58">58</a></sup>中列出的文件. 如果这个列表的一部分是一个目录,这
个目录下所有带扩展名 <code>.org</code> 的文件都会是这个列表的一部分.
</p>

<p>
因此,即使你只使用一个 Org 文件,该文件应该被放入到该列表中<sup><a id="fnr.59" class="footref" href="#fn.59">59</a></sup> 你可以自定义
<code>org-agenda-files</code> ,但是最简单的维护该列表的方式还是通过下列命令:
</p>
<dl class="org-dl">
<dt><code>C-c [ -- (org-agenda-file-to-front)</code></dt><dd>将当前文件添加到 agenda 文件列表.该文件
会被添加到列表的前面. 如果它已经被添加到列表里了,它会被移动到列表最前面.加上前
缀参数使用, 该文件会被添加/移动到列表尾部.</dd>
<dt><code>C-c ] -- (org-remove-file)</code></dt><dd>将当前文件从 agenda 文件列表中移除.</dd>
<dt><code>C-' 或 C-, -- (org-cycle-agenda-files)</code></dt><dd>循环遍历 agenda 文件列表,一个接一个
访问文件.</dd>
<dt><code>M-x org-switchb</code></dt><dd>用来使用一个像 Iswitchb 界面的命令来在Org 缓冲区之间进行切
换.</dd>
</dl>


<p>
Org 菜单包含了当前的文件列表,可以用来访问其中任何一个.
</p>

<p>
如果你想要将 agenda 暂时关注于一个不在列表中的文件上,或者仅关注于列表中的一个文
件上,甚至是仅仅关注文件中的一个子树上,那么可以通过几种不同方式来完成.
对于单个 agenda 命令,你可以在调度程序中(<a href="#org2e5a35b">Agenda Dispatcher</a>)按 <code>&lt;</code> 一次或多次. 要长
时间限制调度程序的范围,请使用下面命令:
</p>
<dl class="org-dl">
<dt><code>C-c C-x &lt; -- (org-agenda-set-restriction-lock)</code></dt><dd>将 agenda 限制到当前子树.如
果该位置已经有一个限制了,则会移除该限制.当带上一个通用前缀参数一起调用或者是在
文件的第一个标题之前调用时,会将 agenda 范围设置为整个文件.这个限制会保持有效,
直到使用 <code>C-c C-x &gt;</code> 移除该限制,或者在 agenda 调度程序里使用了 <code>&lt;</code> 或 <code>&gt;</code>. 如果有窗
口正在显示 agenda 视图,那么新的限制会立即生效.</dd>
<dt><code>C-c C-x &gt; -- (org-agenda-remove-restriction-lock)</code></dt><dd>移除通过 <code>C-c C-x &lt;</code> 创建的
限制.</dd>
</dl>


<p>
当使用 Speedbar (<a href="https://www.gnu.org/software/emacs/manual/html_mono/speedbar.html">Speedbar</a>)时,你可以在 Speedbar 框架中使用下列命令:
</p>

<dl class="org-dl">
<dt><code>&lt; -- (org-speedbar-set-agenda-restriction)</code></dt><dd>将 agenda 限制在 Speedbar 框架光
标处的条目,或是Org 文件又或者是子树上. 如果 agenda 已经限制在该处,则移除限制,
如果有一个窗口正在显示 agenda 视图,则新的限制会立即生效.</dd>
<dt><code>&gt; -- (org-agenda-remove-restriction-lock)</code></dt><dd>移除限制.</dd>
</dl>
</div>
</div>
<div id="outline-container-org2e5a35b" class="outline-3">
<h3 id="org2e5a35b">Agenda Dispatcher</h3>
<div class="outline-text-3" id="text-org2e5a35b">
<p>
用键盘访问 agenda 视图.
</p>

<p>
agenda 视图是通过一个调度程序生成,可以使用 <code>M-x org-agenda</code> 命令访问该调度程序,或
者更好的方法,将其绑定为一个全局快捷键(参见 <a href="#org0cf7316">激活(Activation)</a>). 该调度程序会显示
一个菜单,从中执行命令需要额外的字母按键:
</p>
<dl class="org-dl">
<dt><code>a</code></dt><dd>创建类似日历的 agenda (参见<a href="#org3479471">Weekly/daily agenda</a>).</dd>
<dt><code>t</code> 或 <code>T</code></dt><dd>创建一个所有代办事项的列表(参见 <a href="#org82a7186">Global TODO list</a>).</dd>
<dt><code>m</code> 或 <code>M</code></dt><dd>创建一个匹配给定表达式的标题列表(参见 <a href="#org74ac745">匹配标签和属性(Matching tags and properties)</a>).</dd>
<dt><code>s</code></dt><dd>创建一个条目列表,这些条目由关键词 and/or 正则表达式组成的布尔表达式选择,
条目必须有或必须没有表达式的匹配项.</dd>
<dt><code>/</code></dt><dd>在所有 agenda 文件中和 <code>org-agenda-text-search-extra-files</code> 变量里列出的额
外文件里查询一个正则表达式.这使用了 Emacs 的 <code>multi-occur</code> 命令. 一个前缀参数可
以用来指定每个匹配的内容行的数量,默认值为1.</dd>
<dt><code>#</code></dt><dd>创建一个停滞项目的列表(参见 <a href="#org584ae78">Stuck projects</a>).</dd>
<dt><code>!</code></dt><dd>配置停滞项目列表(参见 <a href="#org584ae78">Stuck projects</a>).</dd>
<dt><code>&lt;</code></dt><dd>将一个 agenda 命令限制到当前缓冲区<sup><a id="fnr.60" class="footref" href="#fn.60">60</a></sup>.如果收缩编辑正在生效,那么限制到缓冲区中收缩的部分.在按 <code>&lt;</code> 之后,
你仍然需要按字母来选择命令.</dd>
<dt><code>&lt; &lt;</code></dt><dd>如果有选中区域,将限制下一个 agenda 命令到选中区域将.否则,限制到当前子树
<sup><a id="fnr.61" class="footref" href="#fn.61">61</a></sup>.在按 <code>&lt; &lt;</code> 之后,你仍然需
要按字母来选择命令.</dd>
<dt><code>*</code></dt><dd>开关持久 agenda 视图. 默认设置下, Org 只保持单个 agenda 缓冲区,并在你每次改变视图时重建该
缓冲区,以保证所有东西总是最新的.如果你经常在视图间切换,而且构建视图的时间令你
困扰,你可以开启持久 agenda 缓冲区(通过自定义变量 <code>org-agenda-sticky</code> 变量将其设
为默认). 使用持久 agenda ,调度程序只会切换到选择的视图,你需要按 <code>r</code> 或 <code>g</code> 手动更
新视图.你可以随时通过命令 <code>org-toggle-sticky-agenda</code> 开关持久 agenda 视图.</dd>
</dl>


<p>
你也可以定义可以通过调度程序访问的自定义命令,就像默认命令一样.该特定包含了创建扩
展 agenda 缓冲区的可能性,该缓冲区同时包含几个模块,例如, weekly agenda, 全局待办
列表和一些特殊标记的匹配. 参见 <a href="#org6712e4a">Custom Agenda Views</a>
</p>
</div>
</div>
<div id="outline-container-org19296e3" class="outline-3">
<h3 id="org19296e3">Built-in Agenda Views</h3>
<div class="outline-text-3" id="text-org19296e3">
<p>
哪些功能是开箱即用的.
</p>

<p>
在这一节里讨论内置 agenda 视图.
</p>
</div>
<div id="outline-container-org3479471" class="outline-4">
<h4 id="org3479471">Weekly/daily agenda</h4>
<div class="outline-text-4" id="text-org3479471">
<p>
带当前任务的日历页.
</p>

<p>
周/日议程视图的目的是充当一页纸质议程,显示当前星期或天的所有任务.
</p>

<dl class="org-dl">
<dt><code>M-x org-agenda a -- (org-agenda-list)</code></dt><dd>从一个 Org 文件列表里汇编当前星期的议
程. 该议程显示每天的条目. 带一个数字前缀参数<sup><a id="fnr.62" class="footref" href="#fn.62">62</a></sup>, 例如 <code>C-u 2 1 M-x org-agenda a</code> 你可以设置要显示的天数.</dd>
</dl>


<p>
默认的显示在议程里的天数是通过便来能够 <code>org-agenda-span</code> 设置的.该变量可以设置为你
想在议程里默认看见的任意天数,或者是一个如 <code>day</code> , <code>week</code> , <code>month</code> 或 <code>year</code> 的时间跨度
名称.对于周议程,默认是从上一个星期一开始的(参见变量 <code>org-agenda-start-on-weekday</code>
的文档).你也可以通过使用一个日期偏移来设置开始日期: <code>(setq org-agenda-start-day
"+10d")</code>, 该设置会从今天之后的未来10天开始议程.
</p>

<p>
从议程缓冲区远程编辑的意思是,例如,你可以从议程缓冲区修改约会的日期和截止日期.在
议程缓冲区里可用的命令都在 <a href="#orgde0d47e">Agenda Commands</a> 里列出.
</p>


<p>
<b>Calendar/Diary integration</b>
</p>
<hr />
<p>
Emacs 包含的日历和日程簿功能出自 Edward M. Reingold. 日历功能显示一个三个月的日
历,带有不同国家和文化的节日. 日程簿功能可让你记录周年纪念日,月相,日出日落,周期性
的约会(每周,每月)等等. 这样,它就和 Org 互补了. 将 Org 的输出和日程簿结合会非常有
用.
</p>

<p>
要将 Emacs 日程簿里的条目包含到 Org mode 的议程 agenda 里,你只需要自定义下面的变
量:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">setq</span> org-agenda-include-diary t)
</pre>
</div>
<p>
之后,所有事情会自动完成.所有的日程簿条目,包括节日,周年纪念日等等,都会包括进 Org
mode 创建的 agenda 缓冲区里.在 agenda 缓冲区里 <code>&lt;SPC&gt;</code> , <code>&lt;TAB&gt;</code>, 和 <code>&lt;RET&gt;</code> 可
以用来跳转到日程簿文件,以便来编辑已有的日程簿条目. <code>i</code> 命令用于插入当前日期的新
条目,以及 <code>S</code> , <code>M</code> 和 <code>C</code> 命令分别用来显示日出日落时间,月相和转化为其他日历. <code>c</code>
命令可用来日历和议程之间来回切换.
</p>

<p>
如果你只将日程簿用于表达式条目和假日,则不使用上述设置,而是将条目复制甚至是移动到
Org 文件中会更快. Org mode 会计算日程簿样式的表达式条目,并且更快,因为没有先创建
日程簿显示的开销. 注意,表达式条目必须从左边沿开始,前面不允许有空格,如下列 Org 文
件的片段所示:<sup><a id="fnr.63" class="footref" href="#fn.63">63</a></sup>
</p>
<pre class="example">
* Holidays
   :PROPERTIES:
   :CATEGORY: Holiday
   :END:
 %%(org-calendar-holiday)   ; special function for holiday names

 * Birthdays
   :PROPERTIES:
   :CATEGORY: Ann
   :END:
 %%(org-anniversary 1956  5 14) Arthur Dent is %d years old
 %%(org-anniversary 1869 10  2) Mahatma Gandhi would be %d years old
</pre>

<p>
<b>Anniversaries from BBDB</b>
</p>
<hr />
<p>
如果你在用 Insidious Big Brother Database 来存储你的通讯录,你很可能想要在 BBDB
里存储周年纪念日而不是在一个单独的 Org 或者是日程簿文件里. Org 支持这杨左,并且可
以将 BBDB 的周年纪念日作为 agenda 的一部分. 你只需要将下列内容添加到你的 agenda
文件中:
</p>
<pre class="example">
* Anniversaries
  :PROPERTIES:
  :CATEGORY: Anniv
  :END:
%%(org-bbdb-anniversaries)
</pre>
<p>
然后你就可以继续为 BBDB 记录定义周年纪念日了.基本上,BBDB 记录需要一个字段命名为
<code>anniversary</code> ,其包含了格式为 <code>YYYY-MM-DD</code> 或 <code>MM-DD</code> 的日期, 随后是空格加上周年
纪念日的类别(<code>birthday</code>, <code>wedding</code>, 或是一个格式字符串).如果你省略了类别,其默认
为 <code>birthday</code>. 下面有几个例子, <code>ol-bbdb.el</code> 文件的头信息含有更多详细的信息.
</p>
<pre class="example">
1973-06-22
06-22
1955-08-02 wedding
2008-04-14 %s released version 6.01 of Org mode, %d years ago
</pre>
<p>
在修改了 BBDB 之后,或者是在一个 Emacs 会话期间第一次显示 agenda 视图时,由于 Org
会因为周年纪念日更新其哈希值,所以 agenda 显示会出现短暂延迟. 然而,从那时起,事情
会变得非常快速,事实上比 Org 或日程簿文件中长长的 <code>%%(diary-anniversary)</code> 列表要
快的多.
</p>

<p>
如果你想要看到即将到来的周年纪念日有一些预警,你可以使用下面的内容:
</p>
<pre class="example">
* Anniversaries
   :PROPERTIES:
   :CATEGORY: Anniv
   :END:
 %%(org-bbdb-anniversaries-future 3)

</pre>
<p>
这会给你一个3天的警告: 在周年纪念日当天和前两天. 天数参数是可选的:如果省略,则默
认为7.
</p>


<p>
<b>Appointment reminders</b>
</p>
<hr />
<p>
Org 能与 Emacs 预约通知功能交互. 要将一个预约添加到你的议程文件,请使用
<code>org-agenda-to-appt</code> 命令. 该命令能让你筛选预约列表,并只添加输入特定类别或匹配正
则表达式的预约.它也会读取预约的 <code>APPT_WARNTIME</code> 属性的值,并覆盖
<code>appt-message-warning-time</code> 变量的值. 详情参考文档字符串.
</p>
</div>
</div>
<div id="outline-container-org82a7186" class="outline-4">
<h4 id="org82a7186">Global TODO list</h4>
<div class="outline-text-4" id="text-org82a7186">
<p>
所有未完成的行动项.
</p>

<p>
全局待办列表包含格式化并收集到同一个地方的所有未完成的待办项.
</p>

<dl class="org-dl">
<dt><code>M-x org-agendat t -- (org-todo-list)</code></dt><dd>显示全局待办列表.该命令会从所有
agenda 文件(参见 <a href="#org7296ea5">Agenda Views</a>)里收集待办项到单个缓冲区里.默认情况下,会列出状
态为未完成状态的项.这个缓冲区是在 Agenda mode 下,所以有命令来直接从该缓冲区里
检查和操作待办项(参见 <a href="#orgde0d47e">Agenda Commands</a>).</dd>
<dt>~M-x org-agenda T &#x2013; (org-todo-list)</dt><dd>和上面命令类似,但是允许选择特定的 TODO
关键字.你也可以通过带前缀参数使用上面的 <code>t</code> 命令来实现这一点. 改名令会提示你输
入一个关键字,你也可以通过将关键字用 <code>|</code> 分隔来指定多个关键字,就像布尔操作符 OR
一样.带一个数字前缀使用, <code>org-todo-keywords</code> 的第 N 个关键字会被选择.</dd>
</dl>


<p>
agenda 缓冲区里的 <code>r</code> 键会重新生成 agenda, 你可以给一个前缀参数到这个命令来改变
所选择的关键字,例如 <code>3 r</code>. 如果你经常需要搜索特定的关键字,请为其定义一个自定义命
令(参见 <a href="#org2e5a35b">Agenda Dispatcher</a>).
</p>

<p>
匹配特定 TODO 关键字也可以作为标签搜索的一部分来完成(参见 <a href="#org4c0e9a9">标签搜索(Tag Searches)</a>).
</p>

<p>
远程编辑待办项意味着你可以用一次按键改变待办项的状态.在 TODO 列表中可用的命令在
<a href="#orgde0d47e">Agenda Commands</a> 里有描述.
</p>

<p>
通常全局 TODO 列表只是简单的展示所有带 TODO 关键字的标题. 这个列表会变得非常长.有
两种方法能让它更紧凑:
</p>
<ul class="org-ul">
<li>有人查看已经计划执行的待办项,或是有截止日期(参见 <a href="#org1d92752">时间戳(Timestamps)</a>)视为不再
打开的待办项.配置变量 <code>org-agenda-todo-ignore-scheduled</code> 来从全局待办列表里排
除一些或所有计划项,配置 <code>org-agenda-todo-ignore-deadlines</code> 来排除一些或所有设
置了截止日期的项,配置 <code>org-agenda-todo-ignore-timestamp</code> 来排除一些或所有带有
一个有效时间戳而不是截止日期或计划日期时间戳的项,或者是配置
<code>org-agenda-todo-ignore-with-date</code> 来排除至少有一个有效时间戳的项.</li>
<li>待办项可能有分级,用来将任务拆分成子任务.这种情况下,在全局列表里只列出最高层级
的 TODO 标题,并忽略分级就够了.请配置 <code>org-agenda-todo-list-sublevels</code> 来获取此
行为.</li>
</ul>
</div>
</div>
<div id="outline-container-org74ac745" class="outline-4">
<h4 id="org74ac745">匹配标签和属性(Matching tags and properties)</h4>
<div class="outline-text-4" id="text-org74ac745">
<p>
具有微调搜索功能的结构化信息.
</p>
</div>
</div>

<div id="outline-container-orga26751c" class="outline-4">
<h4 id="orga26751c">Search view</h4>
<div class="outline-text-4" id="text-orga26751c">
<p>
通过搜索文本查找条目.
</p>
</div>
</div>
<div id="outline-container-org584ae78" class="outline-4">
<h4 id="org584ae78">Stuck projects</h4>
<div class="outline-text-4" id="text-org584ae78">
<p>
查找需要回顾的项目.
</p>
</div>
</div>
</div>
<div id="outline-container-org23ba51a" class="outline-3">
<h3 id="org23ba51a">Presentation and Sorting</h3>
<div class="outline-text-3" id="text-org23ba51a">
<p>
agenda 条目是如何准备显示的.
</p>
</div>
<div id="outline-container-orge043afd" class="outline-4">
<h4 id="orge043afd">种类(Categories)</h4>
</div>
<div id="outline-container-org7e3bd28" class="outline-4">
<h4 id="org7e3bd28">Time-of-day specifications</h4>
</div>
<div id="outline-container-orgc645780" class="outline-4">
<h4 id="orgc645780">agenda 条目排序(Sorting og agenda items)</h4>
</div>
<div id="outline-container-org22b8738" class="outline-4">
<h4 id="org22b8738">过滤/限制 agenda 条目(Filtering/limiting agenda items)</h4>
</div>
</div>

<div id="outline-container-orgde0d47e" class="outline-3">
<h3 id="orgde0d47e">Agenda Commands</h3>
<div class="outline-text-3" id="text-orgde0d47e">
<p>
远程编辑 Org 树.
</p>
</div>
</div>

<div id="outline-container-org6712e4a" class="outline-3">
<h3 id="org6712e4a">Custom Agenda Views</h3>
<div class="outline-text-3" id="text-org6712e4a">
<p>
定义特殊查询和视图.
</p>
</div>

<div id="outline-container-orgb4466c4" class="outline-4">
<h4 id="orgb4466c4">保存搜索(Storing searches)</h4>
</div>

<div id="outline-container-org10752d8" class="outline-4">
<h4 id="org10752d8">Block agenda</h4>
</div>

<div id="outline-container-org6aac2ca" class="outline-4">
<h4 id="org6aac2ca">设置选项(Setting options)</h4>
</div>
</div>

<div id="outline-container-org16cef59" class="outline-3">
<h3 id="org16cef59">Exporting Agenda Views</h3>
<div class="outline-text-3" id="text-org16cef59">
<p>
将视图写入到文件中.
</p>
</div>
</div>
<div id="outline-container-org5423901" class="outline-3">
<h3 id="org5423901">Agenda Column View</h3>
<div class="outline-text-3" id="text-org5423901">
<p>
为收集的条目使用列视图.
</p>
</div>
</div>
</div>

<div id="outline-container-org9fbde8c" class="outline-2">
<h2 id="org9fbde8c"><span class="done DONE">DONE</span> 富文本的标记(Markup for Rich Contents)</h2>
<div class="outline-text-2" id="text-org9fbde8c">
<p>
Org 主要是组织和搜索纯文本笔记的.然而,它也为符文本格式化以及其他内容提供了轻量但
是健壮的标记语言.例如,你可能想要强调或居中文本.或者你可能需要在写作中插入公式或
图片. Org 为所有的这些或者其他更多提供了语法.与导出框架(参见 <a href="#org9c28439">导出(Exporting)</a>)
结合使用,你可以在 Org 里写出漂亮的文档,就像你正在阅读的精巧手册一样.
</p>
</div>

<div id="outline-container-org22ce809" class="outline-3">
<h3 id="org22ce809"><span class="done DONE">DONE</span> 段落(Paragraphs)</h3>
<div class="outline-text-3" id="text-org22ce809">
<p>
文本的基本单位.
</p>

<p>
段落由至少一个空白行分隔.如果你需要在一个段落里强制换行,请在行尾使用 <code>\\</code>.
</p>

<p>
要在一个区域里保留换行,缩进和空白行,但是要使用正常格式,你可以使用下面这个结构,它
也可以用来格式化诗歌.
</p>
<pre class="example">
#+BEGIN_VERSE
 Great clouds overhead
 Tiny black birds rise and fall
 Snow covers Emacs

    ---AlexSchroeder
#+END_VERSE
</pre>
<p>
效果
</p>

<p class="verse">
Great clouds overhead<br />
Tiny black birds rise and fall<br />
Snow covers Emacs<br />
<br />
&#xa0;&#xa0;&#xa0;&#x2014;AlexSchroeder<br />
</p>

<p>
引用另一份文档中的一段话时,通常将其格式设置为左右两边都缩进的段落.你可以在 Org
中像这样使用引用:
</p>
<pre class="example">

#+BEGIN_QUOTE
Everything should be made as simple as possible,
but not any simpler ---Albert Einstein
#+END_QUOTE

</pre>
<p>
效果:
</p>

<blockquote>
<p>
Everything should be made as simple as possible,
but not any simpler &#x2014;Albert Einstein
</p>
</blockquote>

<p>
如果你想要将某些文本居中,可以这样:
</p>
<pre class="example">

#+BEGIN_CENTER
Everything should be made as simple as possible, \\
but not any simpler
#+END_CENTER

</pre>
<p>
效果:
</p>
<div class="org-center">
<p>
Everything should be made as simple as possible, <br />
but not any simpler
</p>
</div>
</div>
</div>

<div id="outline-container-org5e823db" class="outline-3">
<h3 id="org5e823db"><span class="done DONE">DONE</span> 强调和Mono空格(Emphasis and Monospace)</h3>
<div class="outline-text-3" id="text-org5e823db">
<p>
斜体,加粗等等.
</p>

<p>
你可以设置文本 <code>*加粗*</code>, <code>/斜体/</code>, <code>_下划线_</code>, <code>=原义字符串=</code> 和 <code>~代码~</code>, 如果
需要的话,还可以使用 <code>+删除线+</code>.效果: <b>bold</b> , <i>italic</i>, <span class="underline">underlined</span> ,
<code>verbatim</code>, <code>code</code>. 在代码和原义字符串里的字符串不会被 Org 的特定语法处理,它们会
按照原义导出.
</p>

<p>
要关闭标记文本的字体设置,可以将 <code>org-fontify-emphasized-text</code> 设置为 <code>nil</code>. 要缩
减可用的标记语法列表的范围,你可以自定义 <code>org-emphasis-alist</code>.
</p>

<p>
有时候,当标记文本也含有标记字符本身时,结果可能令人不安,例如:
</p>
<pre class="example">
/One may expect this whole sentence to be italicized, but the
following ~user/?variable~ contains =/= character, which effectively
stops emphasis there./
</pre>
<p>
效果:
<i>One may expect this whole sentence to be italicized, but the
following ~user</i>?variable~ contains <code>/</code> character, which effectively
stops emphasis there./
</p>

<p>
你可以使用0宽度空格来帮助 Org 处理歧义问题. 更多细节请查看 <a href="#org89bb441">转义字符(Escape Character)</a>.
</p>
</div>
</div>

<div id="outline-container-orga4b2260" class="outline-3">
<h3 id="orga4b2260"><span class="done DONE">DONE</span> 下标和上标(Subscripts and Superscripts)</h3>
<div class="outline-text-3" id="text-orga4b2260">
<p>
降低或升高文本的简单语法.
</p>

<p>
<code>^</code> 和 <code>_</code> 用来表示上标和下标. 为了增加 ASCII 文本的可读性,虽然没有必要,但是可以
用花括号括住多字符的上标和下标. 例如:
</p>
<pre class="example">
The radius of the sun is R_sun = 6.96 x 10^8 m.  On the other hand,
the radius of Alpha Centauri is R_{Alpha Centauri} = 1.28 x R_{sun}.
</pre>

<p>
如果你写的文本中下划线经常在上下文里使用, Org 将下划线解释为下标的惯例会阻碍你的
写作.配置 <code>org-use-sub-superscripts</code> 可以改变这一惯例.例如,当将这个变量设置为
<code>{}</code> 时, <code>a_b</code> 就不会被解释为下标,但是 <code>a_{b}</code> 会.
</p>

<p>
你可以在文件里使用导出选项 <code>^</code> (参见 <a href="#org53ffc01">导出设置(Export Settings)</a>)来设置变量
<code>org-use-sub-superscripts</code> .例如, <code>#+OPTIONS: ^:{}</code> 会将
<code>org-use-sub-superscripts</code> 设置为 <code>{}</code> 并将上标和下标限制为花括号表示法.
</p>

<p>
你也可以开关上下标的可视化显示:
</p>
<dl class="org-dl">
<dt><code>C-c C-x \ -- (org-toggle-pretty-entities)</code></dt><dd>该命令以所见即所得的方式格式化
上下标.</dd>
</dl>


<p>
将 <code>org-pretty-entities</code> 和 <code>org-pretty-entities-include-sub-superscripts</code> 设置
为 <code>t</code> 来让上下标初始按选项 <code>org-use-sub-superscripts</code> 指定的设置来进行可视化解
释.
</p>
</div>
</div>
<div id="outline-container-orge333afc" class="outline-3">
<h3 id="orge333afc"><span class="done DONE">DONE</span> 特殊符号(Special Symbols)</h3>
<div class="outline-text-3" id="text-orge333afc">
<p>
希腊字母和其他符号.
</p>

<p>
你可以使用类似 LaTex 的语法来插入命名实体的特殊符号,例如 <code>\alpha</code> 表示希腊字母,
或是 <code>\to</code> 表示一个箭头. 这些符号也可以使用补全功能,只需要键入 <code>\</code> 和几个字母,然
后按 <code>M-&lt;TAB&gt;</code> 就可以看见可能的补全了. 如果你需要在单词中使用这样的符号,请用一对
花括号将其终止.例如:
</p>
<pre class="example">
Pro tip: Given a circle \Gamma of diameter d, the length of its
circumference is \pi{}d.
</pre>
<p>
效果:
</p>

<p>
Pro tip: Given a circle &Gamma; of diameter d, the length of its
circumference is &pi;d.
</p>

<p>
Org 提供了大量这样的实体,其名称取自 HTML 和 LaTex; 你可以使用命令
<code>org-entities-help</code> 从一个专用缓冲区里轻松浏览完整列表.还可以在变量
<code>org-entities-user</code> 中提供你自己的特殊符号.
</p>

<p>
在导出期间,这些符号会被转化成导出器后端的本地格式.在 HTML 输出中,像 <code>\alpha</code> 的
字符串会被导出为 <code>&amp;alpha;</code>, 在 LaTex 输出中,会被导出为 <code>\(\alpha\)</code>. 类似的,
<code>\nbsp</code> 在 HTML 里变成 <code>&amp;nbsp;</code> ,在 LaTex 里变成 <code>~</code>
</p>

<p>
如果你想要看这些实体显示为 UTF-8 字符,请使用下列的命令<sup><a id="fnr.64" class="footref" href="#fn.64">64</a></sup>:
</p>
<dl class="org-dl">
<dt><code>C-c C-x \ -- (org-toggle-pretty-entities)</code> </dt><dd>开关实体的 UTF-8 字符显示. 该
行为不会改变缓冲区内容,它们仍然保持纯 ASCII 格式,但是出于显示的目的只覆盖
UTF-8 字符的显示.</dd>
</dl>


<p>
除了上面定义的常规实体外, Org 会以一中特殊的方式<sup><a id="fnr.65" class="footref" href="#fn.65">65</a></sup> 导出下面常用的字符组合: <code>\-</code> 会被视为
连字符, <code>--</code> 和 <code>---</code> 被转换为破折号, <code>...</code> 被成为一组紧凑的点.
效果:
<code>\-</code> : 1 &#x00ad; 2
</p>

<p>
<code>--</code>: 1 &#x2013; 2
</p>

<p>
<code>---</code>: 1 &#x2014; 2
</p>

<p>
<code>...</code>: 1 &#x2026; 2
</p>
</div>
</div>

<div id="outline-container-org2ee3576" class="outline-3">
<h3 id="org2ee3576"><span class="done DONE">DONE</span> 嵌入式 LaTex(Embeded LaTex)</h3>
<div class="outline-text-3" id="text-org2ee3576">
<p>
Latex 可以在 Org 文档内部自由使用.
</p>

<p>
纯 ASCII 通常足以用于几乎所有的笔记记录.例外情况包括科学笔记,它通常需要数学符号
和特殊公式. LaTex<sup><a id="fnr.66" class="footref" href="#fn.66">66</a></sup> 被广泛用来排版科学报告文档. Org mode 支持将 LaTeX 代码嵌入到 Org 文件中,因
为许多学者习惯与编写和读取 LaTeX 源代码,而且它可以很容易地进行处理,为许多导出后
端生成相当好的输出.
</p>
</div>


<div id="outline-container-org584dcbd" class="outline-4">
<h4 id="org584dcbd">LaTex 片段(LaTex fragments)</h4>
<div class="outline-text-4" id="text-org584dcbd">
<p>
复杂公式变得简单.
</p>

<p>
Org mode 可以包含 LaTeX 数学片段,并且它还支持为多个导出后端处理这些片段的方法.
当导出为 LaTeX 时,这些代码会保留原样.当导出为 HTML 时, Org 能使用 MathJax
(<a href="https://www.mathjax.org">https://www.mathjax.org</a>) (参见 <a href="#org063f591">HTML 导出的数学格式(Math formatting in HTML export)</a>) 或是将数学片段转码成图片(参见 <a href="#orgff60a9b">预览 LaTex 片段(Previewing LaTex fragments)</a>).
</p>

<p>
LaTeX 片段完全不需要任何特殊标记符号. 下面的片段被标识为 LaTeX 源代码:
</p>
<pre class="example">
• Environments of any kind(1).  The only requirement is that the
  ‘\begin’ statement appears on a new line, preceded by only
  whitespace.

• Text within the usual LaTeX math delimiters.  To avoid conflicts
  with currency specifications, single ‘$’ characters are only
  recognized as math delimiters if the enclosed text contains at most
  two line breaks, is directly attached to the ‘$’ characters with no
  whitespace in between, and if the closing ‘$’ is followed by
  whitespace, punctuation or a dash.  For the other delimiters, there
  is no such restriction, so when in doubt, use ‘\(...\)’ as inline
  math delimiters.
</pre>
<hr />
<p>
效果:
</p>

<p>
• Environments of any kind<sup><a id="fnr.67" class="footref" href="#fn.67">67</a></sup>.  The only requirement is that the
  ‘\begin’ statement appears on a new line, preceded by only
  whitespace.
</p>

<p>
• Text within the usual LaTeX math delimiters.  To avoid conflicts
  with currency specifications, single ‘\(’ characters are only
     recognized as math delimiters if the enclosed text contains at most
     two line breaks, is directly attached to the ‘\)’ characters with no
  whitespace in between, and if the closing ‘$’ is followed by
  whitespace, punctuation or a dash.  For the other delimiters, there
  is no such restriction, so when in doubt, use ‘\(...\)’ as inline
  math delimiters.
</p>
<hr />


<p>
例如:
</p>

<pre class="example">

\begin{equation}                        % arbitrary environments,
x=\sqrt{b}                              % even tables, figures
\end{equation}                          % etc

If $a^2=b$ and \( b=2 \), then the solution must be
either $$ a=+\sqrt{2} $$ or \[ a=-\sqrt{2} \].
</pre>

<p>
效果:
</p>

<p>
\begin{equation}                        % arbitrary environments,
x=\sqrt{b}                              % even tables, figures
\end{equation}                          % etc
</p>

<p>
If \(a^2=b\) and \( b=2 \), then the solution must be
either \[ a=+\sqrt{2} \] or \[ a=-\sqrt{2} \].
</p>

<hr />

<p>
LaTeX 处理过程可以用 <code>org-export-with-latex</code> 变量来配置. 默认设置是 <code>t</code> ,意味着
HTML 使用 MathJax, ASCII 和 LaTeX 后端不进行处理. 你也可以使用下面几行之一来按文
件设置此变量:
</p>
<pre class="example">
‘#+OPTIONS: tex:t’          Do the right thing automatically (MathJax)
‘#+OPTIONS: tex:nil’        Do not process LaTeX fragments at all
‘#+OPTIONS: tex:verbatim’   Verbatim export, for jsMath or so
</pre>
</div>
</div>


<div id="outline-container-orgff60a9b" class="outline-4">
<h4 id="orgff60a9b">预览 LaTex 片段(Previewing LaTex fragments)</h4>
<div class="outline-text-4" id="text-orgff60a9b">
<p>
这个片段看起来会是怎样?
</p>

<p>
如果你有一个正在运行的 LaTeX 安装,并且安装了 <code>dvipng</code> , <code>dvisvgm</code> 或 <code>convert</code>
<sup><a id="fnr.68" class="footref" href="#fn.68">68</a></sup>, LaTeX 片段可以处理生成图像,
以便在导出到 HTML 时用于包含排版表达式(参见 <a href="#org584dcbd">LaTex 片段(LaTex fragments)</a>),或是在
Org 模式里内联预览.
</p>

<p>
你可以自定义变量 <code>org-format-latex-options</code> 和 <code>org-format-latex-header</code> 来影响
预览的某些方面. 特别的,前一个变量的 <code>:scale</code> (对应 HTML 导出,则是 <code>:html-scale</code>)
属性可以用来调整预览图片的大小.
</p>

<dl class="org-dl">
<dt><code>C-c C-x C-l -- (org-latex-preview)</code></dt><dd><p>
生成光标处 LaTeX 片段的预览图像,并将其
覆盖在源代码上显示. 如果光标位置处没有片段,则处理当前条目(两个标题之间)下的所
有片段.
</p>

<p>
当带上一个前缀参数调用时,清除当前条目的所有图片. 带上两个前缀参数调用,会为缓冲
区里所有片段生成预览图片,带上三个前缀参数时,清除缓冲区里所有的预览图片.
</p></dd>
</dl>


<p>
你可以在文件里开启所有 LaTeX 片段的预览:
</p>
<pre class="example">
#+STARTUP: latexpreview
</pre>
<p>
要关闭预览:
</p>
<pre class="example">
#+STARTUP: nolatexpreview
</pre>
</div>
</div>

<div id="outline-container-org0dfa678" class="outline-4">
<h4 id="org0dfa678">CDLaTex 模式(CDLaTex mode)</h4>
<div class="outline-text-4" id="text-org0dfa678">
<p>
加速输入公式.
</p>

<p>
CDLaTeX 模式是一个副模式,通常用来和 AUCTeX 等 LaTeX 主模式结合使用,主要是为了加
速环境和数学模板的插入. 在 Org 模式中,你可以使用一些 CDLaTeX 模式的功能. 你需要
安装 <code>cdlatex.el</code> 和 <code>texmathp.el</code> (后者 ACUTeX 自带), 可以使用 MELPA
(<a href="https://melpa.org/">https://melpa.org/</a>) 和 Emacs 的包管理系统
(<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Package-Installation.html">https://www.gnu.org/software/emacs/manual/html_node/emacs/Package-Installation.html</a>)
安装或者是从 <a href="https://staff.fnwi.uva.nl/c.dominik/Tools/cdlatex/">https://staff.fnwi.uva.nl/c.dominik/Tools/cdlatex/</a> 里安装.
</p>

<p>
请不要在 Org 模式下使用 CDLaTeX 模式本身,而是使用作为 Org 的一部分的特殊版本的
Org CDLaTeX 副模式. 使用 <code>M-x org-cdlatex-mode</code> 命令为当前缓冲区开启它,或者是使
用下面代码为所有 Org 文件开启该副模式:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-hook 'org-mode-hook #'turn-on-org-cdlatex)
</pre>
</div>

<p>
当该模式启用时,将存在一下功能(更多细节请查阅 CDLaTeX 模式的文档):
</p>
<dl class="org-dl">
<dt><code>C-c {</code></dt><dd>插入一个环境模板.</dd>
<dt><code>&lt;TAB&gt;</code></dt><dd><p>
如果光标位于一个 LaTeX 片段中, <code>&lt;TAB&gt;</code> 键会扩展模板<sup><a id="fnr.69" class="footref" href="#fn.69">69</a></sup>. 例如, <code>&lt;TAB&gt;</code> 会将 <code>fr</code> 扩展成
<code>\frac{}{}</code> 并将光标正确放置在第一个花括号内. 再按一次 <code>&lt;TAB&gt;</code> 会将光标放置到
第二个花括号内.
</p>

<p>
即使在片段外面, <code>&lt;TAB&gt;</code> 会在行首扩展环境的缩写. 例如, 如果你在行首写下 <code>equ</code>
然后按 <code>&lt;TAB&gt;</code> ,这个缩写就会被扩展成 <code>equation</code> 环境. 想获取所有缩写的列表,请
按下 <code>M-x cdlatex-command-help</code>.
</p></dd>
<dt><code>^ 和 _</code></dt><dd>在一个 LaTeX 片段里按 <code>_</code> 和 <code>^</code> 会将这些字符带这大括号一起插入.
如果你使用 <code>&lt;TAB&gt;</code> 移动到了括号外,或者如果括号只包围了一个字符或宏,这些括号会
被再次移除(该行为取决于变量 <code>cdlatex-simplify-sub-super-scripts</code>).</dd>
<dt><code>`</code></dt><dd>反引号加一个字符会插入数学宏,在 LaTeX 片段外部也是. 如果你在反引号后等
待了超过1.5秒,则会弹出一个帮助窗口.</dd>
<dt><code>'</code></dt><dd>单引号加另一个字符可以用会用字体或强调修饰光标前的符号.如果你在单引号后
等待超过1.5秒,一个帮助窗口会弹出. 字符修饰只在 LaTeX 片段内部生效,在片段外表现
为正常引号.</dd>
</dl>
</div>
</div>
</div>


<div id="outline-container-orge51ce3a" class="outline-3">
<h3 id="orge51ce3a"><span class="done DONE">DONE</span> 文字示例(Literal Examples)</h3>
<div class="outline-text-3" id="text-orge51ce3a">
<p>
带特殊格式的源代码示例.
</p>

<p>
你可以包含不受标记影响的文字示例.<br />
这样的例子是用 monospace 排版的,所以非常适合源代码和类似示例.
</p>
<pre class="example">
#+BEGIN_EXAMPLE
  Some example from a text file.
#+END_EXAMPLE
</pre>
<p>
然而,这里有一个限制.你必须在以 <code>*</code> , <code>,*</code>, <code>#+</code> 或 <code>,#+</code> 开头的行之前插入逗号,因
为这些行可能被解释为大纲节点或是一些其他的特殊语法. Org 在访问块内容时会透明的去
掉这些额外逗号.
</p>

<p>
例子:
</p>

<pre class="example">
#+BEGIN_EXAMPLE
,* I am no real headline
#+END_EXAMPLE
</pre>

<p>
效果:
</p>

<pre class="example">
* I am no real headline
</pre>

<p>
当使用小的例子时,出于简化考虑,你也可以用一个冒号加空格开始一个示例行.冒号前也可
能有额外的空格:
</p>

<p>
示例:
</p>
<pre class="example">
Here is an example
   : Some example from a text file.
</pre>

<p>
效果:
</p>

<p>
Here is an example
</p>
<pre class="example">
Some example from a text file.
</pre>


<p>
如果示例是来自编程语言的源代码,或者时任何其它可以用 Emacs 的 Font Lock 标记的其
他文本,你可以让示例看起来像是Emacs 美化后的缓冲区<sup><a id="fnr.70" class="footref" href="#fn.70">70</a></sup>. 该功能是通过代码块来完成的,在代码块里,你还需要指定应用于示例进行美化的主
模式的名称<sup><a id="fnr.71" class="footref" href="#fn.71">71</a></sup>, 有关便携的插入代码块的快捷方式,请
查阅 <a href="#org5bcee50">结构模板(Structure Templates)</a> .
</p>

<p>
示例:
</p>
<pre class="example">
#+BEGIN_SRC emacs-lisp
  (defun org-xor (a b)
    "Exclusive or."
    (if a (not b) b))
 #+END_SRC
</pre>
<p>
效果:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">org-xor</span> (a b)
    <span style="font-style: italic;">"Exclusive or."</span>
    (<span style="font-weight: bold;">if</span> a (not b) b))
</pre>
</div>

<p>
在 <code>example</code> 和 <code>src</code> 片段里,你可以在 <code>#+BEGIN</code> 行的末尾添加一个 <code>-n</code> 开关,用来
让示例行被编号. <code>-n</code> 接受一个可选的数字参数来指定块的开始行号.<br />
如果你使用一个 <code>+n</code> 开关,则行号从上一个编号了的代码块的编号开始. <code>+n</code> 开关也接受
一个数字参数.该参数的值将添加到上一个编号了的代码块的最后一个行号上,用来决定起始
行号.
</p>

<p>
示例:
</p>
<pre class="example">
#+BEGIN_SRC emacs-lisp -n 20
  ;; This exports with line number 20.
  (message "This is line 21")
#+END_SRC

#+BEGIN_SRC emacs-lisp +n 10
  ;; This is listed as line 31.
  (message "This is line 32")
#+END_SRC
</pre>
<p>
效果:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="linenr">20: </span><span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">This exports with line number 20.</span>
<span class="linenr">21: </span>(message <span style="font-style: italic;">"This is line 21"</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="linenr">31: </span><span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">This is listed as line 31.</span>
<span class="linenr">32: </span>(message <span style="font-style: italic;">"This is line 32"</span>)
</pre>
</div>

<p>
在文字示例中, Org 将类似 <code>(ref:name)</code> 的字符串解释为标签,并将他们作为
<code>[[(name)]]</code> 之类的特殊超链接(即用单括号括起来的引用名称)的目标. 在 HTML 里,将鼠
标悬停在这样的一个链接上,会远程高亮相应的代码行(这很酷).
</p>

<p>
你也可以添加一个 <code>-r</code> 开关来从源代码里移除这些标签<sup><a id="fnr.72" class="footref" href="#fn.72">72</a></sup>. 使用 <code>-n</code> 开关,这些引用的链接会从代码展示里按行号标记. 不然的话链接就
会使用不带括号的标签标记.下面就是一个例子:
</p>

<p>
示例:
</p>
<pre class="example">
#+BEGIN_SRC emacs-lisp -n -r
<span id="coderef-sc" class="coderef-off">(save-excursion (sc)</span>
<span id="coderef-jump" class="coderef-off">    (goto-char (point-min)) (jump)</span>
#+END_SRC
In line [[(sc)]] we remember the current position. [[(jump)][Line (jump)]]
jumps to point-min.
</pre>

<p>
效果:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span id="coderef-sc" class="coderef-off"><span class="linenr">1: </span>(<span style="font-weight: bold;">save-excursion</span></span>
<span id="coderef-jump" class="coderef-off"><span class="linenr">2: </span>    (goto-char (point-min))</span>
</pre>
</div>
<p>
In line <a href="#coderef-sc" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-sc');" onmouseout="CodeHighlightOff(this, 'coderef-sc');">sc</a> we remember the current position. <a href="#coderef-jump" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-jump');" onmouseout="CodeHighlightOff(this, 'coderef-jump');">Line jump</a>
jumps to point-min.
</p>

<p>
源代码和示例可以缩进,以便与周围的文本很好的对齐,尤其是与简单列表结构对齐(请查阅
<a href="#org7083e39">简单列表(Plain Lists)</a>). 默认情况下, Org 只保持两行之间的相对缩进, 例如, 当导出
块的内容时. 然而,你也可以使用 <code>-i</code> 开关来保留全局缩进,如果这样做有意义的话.参考
<a href="#org4c2c13b">编辑源代码(Editing Source Code)</a>.
</p>

<p>
如果标签格式的语法跟语言的语法冲突了,请使用 <code>-l</code> 开关来改变格式.例如:
</p>
<pre class="example">
#+BEGIN_SRC pascal -n -r -l "((%s))"
</pre>

<p>
另外请参阅变量 <code>org-coderen-label-format</code> 的文档.
</p>

<p>
HTML 导出也允许示例作为文本区域发布(参阅 <a href="#org43d5273">HTML 导出的文本区域(Text areas in HTML export)</a>).
</p>

<p>
因为 <code>#+BEGIN ... #+END</code> 模式经常需要被添加,因此提供了一个快捷方式.
(参见 <a href="#org5bcee50">结构模板(Structure Templates)</a>)
</p>

<dl class="org-dl">
<dt><code>C-c ' -- (org-edit-special)</code></dt><dd>用其本身的模式来编辑光标处的源代码示例. 该命
令通过切换到一个装有源代码的暂时缓冲区中实现. 你需要再一次按 <code>C-c '</code> 来退出该
缓冲区. 编辑后的版本会替换掉 Org 缓冲区里的旧的版本. 固定宽度的区域(每一行都由
一个冒号加空格开始的区域)使用 Artist 模式编辑<sup><a id="fnr.73" class="footref" href="#fn.73">73</a></sup>,以便能轻松创建 ASCII 图形.在
空白行使用该命令会创建一个新的固定宽度区域(经过测试好像并不能-Emacs 28.2 on
windows7).</dd>
</dl>


<p>
在 <code>C-c '</code> 创建的暂时缓冲区里编辑源代码示例时,调用 <code>org-store-link</code>
(参见<a href="#org78b3dfa">处理链接(Handling Links)</a> 会提示输入一个标签. 请确保该标签在当前缓冲区里是
唯一的,然后它以正确的格式(例如 <code>(ref:label)</code>) 插入到当前行的末尾. 然后该标签会做
为一个链接 <code>(label)</code> 存储,以便 <code>C-c C-l</code> 进行检索.
</p>
</div>
</div>

<div id="outline-container-org757807d" class="outline-3">
<h3 id="org757807d"><span class="done DONE">DONE</span> 图片(Images)</h3>
<div class="outline-text-3" id="text-org757807d">
<p>
展示一张图片.
</p>

<p>
一张图片是一个连接到一个图片文件<sup><a id="fnr.74" class="footref" href="#fn.74">74</a></sup>且没有描述部分的
链接, 比如说:
</p>
<pre class="example">
./img/cat.jpg
</pre>

<p>
如果你要为图片定义一个说明(请参阅 <a href="#org5ee64e3">说明(Captions)</a>), 或者是为交叉引用定义一个标签
(参阅 <a href="#orgc3efa52">内部链接(Internal Links)</a> ,请确保链接本身占用一行,并在其前面加上 <code>CAPTION</code>
和 <code>NAME</code> 关键字, 如下所示:
</p>
<pre class="example">

#+CAPTION: This is the caption for the next figure link (or table)
#+NAME:   fig:SED-HR4049
[[./img/a.jpg]]
</pre>
<p>
效果:
</p>



<div id="org5b02859" class="figure">
<p><img src="./img/a.jpg" alt="a.jpg" />
</p>
<p><span class="figure-number">Figure 1: </span>This is the caption for the next figure link (or table)</p>
</div>

<p>
这样的图片可以使用下面命令在缓冲区中展示:
</p>
<dl class="org-dl">
<dt><code>C-c C-x C－ -- (org-toggle-inline-images)</code></dt><dd>开关链接图片的内联显示. 当使用
一个前缀参数调用时,也会显示没有链接描述的图片. 你可以通过配置变量
<code>org-startup-with-inline-images</code> <sup><a id="fnr.75" class="footref" href="#fn.75">75</a></sup>来让内联图片在初始就显示.</dd>
</dl>
</div>
</div>

<div id="outline-container-org5ee64e3" class="outline-3">
<h3 id="org5ee64e3"><span class="done DONE">DONE</span> 说明(Captions)</h3>
<div class="outline-text-3" id="text-org5ee64e3">
<p>
描述表格,图片&#x2026;
</p>

<p>
你可以通过在文档的指定部分前面紧挨着插入一个 <code>CAPTION</code> 关键字来为该部分分配一个说
明:
</p>
<pre class="example">
#+CAPTION: This is the caption for the next table (or link)
| ... | ... |
|-----+-----|
</pre>

<p>
根据需要,说明也可以从下面格式中获取:
</p>
<pre class="example">
#+CAPTION[Short caption]: Longer caption.
</pre>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> Longer caption.</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
<td class="org-right">4</td>
<td class="org-right">5</td>
<td class="org-right">6</td>
<td class="org-right">7</td>
<td class="org-right">8</td>
<td class="org-right">9</td>
<td class="org-right">10</td>
</tr>

<tr>
<td class="org-right">a</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
尽管图像和表格是Caption结构的典型示例,但相同的说明机制也可以应用于其他许多示例,
例如,LaTeX方程,源代码块.根据导出后端的不同,这些其他例子可能会进行处理,也可能不会
进行处理.
</p>
</div>
</div>
<div id="outline-container-orgb382a5c" class="outline-3">
<h3 id="orgb382a5c"><span class="done DONE">DONE</span> 水平线(Horizontal Rules)</h3>
<div class="outline-text-3" id="text-orgb382a5c">
<p>
划一条线.
</p>

<p>
只由破折号(<code>-</code>)组成的一行,并且破折号至少有5个,会被导出为一条水平线.
</p>

<pre class="example">
-----
</pre>
<p>
效果:
</p>
<hr />
</div>
</div>
<div id="outline-container-org5b36282" class="outline-3">
<h3 id="org5b36282"><span class="done DONE">DONE</span> 创建脚注(Creating Footnotes)</h3>
<div class="outline-text-3" id="text-org5b36282">
<p>
编辑和读取脚注.
</p>

<p>
脚注从第0列方括号中的脚注标记开始,不允许由缩进,到下一个脚注的定义,下一个
标题或连续两个空白行后结束.脚注引用只是文本里方括号中的标记.标记总是以 <code>fn:</code> 开
头,例如:
</p>
<pre class="example">
The Org homepage[fn:1] now looks a lot better than it used to.
...
[fn:1] The link is: https://orgmode.org
</pre>

<p>
Org 模式将基于数字的语法扩展到命名脚注和可选的内联定义.以下是有效的参考资料:
</p>

<dl class="org-dl">
<dt><code>[fn:NAME]</code></dt><dd>一种命名脚注引用. 其中 NAME 是一个唯一的标签词,或者为了便于自
动创建,是一个数字.</dd>

<dt><code>[fn:: This is the inline definition of this footnote]</code></dt><dd>一个直接在引用处给
出定义的脚注.</dd>

<dt><code>[fn:NAME: a definition]</code></dt><dd>一个脚注的内联定义,同时也指定注释的名称.因为 Org
允许多个引用指向同一个注释,所以,你可以使用 <code>[fn:NAME]</code> 来创建额外的引用.</dd>
</dl>


<p>
脚注标签可以自动创建,你也可以自己创建名称.这一行为是由变量
<code>org-footnote-auto-label</code> <sup><a id="fnr.76" class="footref" href="#fn.76">76</a></sup>.和其对应的 <code>STARTUP</code> 关键字处理.查看该变量的文档字符串
来获取详细信息.
</p>

<p>
下面的命令用来处理脚注:
</p>

<dl class="org-dl">
<dt><code>C-c C-x f</code></dt><dd>脚注操作命令.当光标在脚注引用上时,跳转到定义.当在定义上时,跳转
到第一个引用的位置 <code>[fn:2]</code>. 既不在脚注的引用,也不在其定义上时,就创建一个新的
脚注.取决于变量 <code>org-footnote-define-inline</code> 的值,脚注的定义会被放在文本里作
为引用的一部分.或者单独放置在变量 <code>org-footnote-section</code> 决定的位置上.
当这个命令加上前缀参数一起调用时,将提供一个附加选项的菜单:
<code>s</code> : 根据引用序列排序脚注.
<code>r</code> : 重新编码简单的 <code>fn:N</code> 脚注.
<code>S</code> : 先 <code>r</code> 重编码,后 <code>s</code> 排序的操作的简写.
<code>n</code> : 重命名所有脚注到 <code>fn:1</code> .. <code>fn:n</code> 的序列.
<code>d</code> : 删除当前脚注,包括定义和引用.
根据变量 <code>org-footnote-auto-adjust</code> <sup><a id="fnr.77" class="footref" href="#fn.77">77</a></sup> 的值,重排序和重编号可以在插入和删除脚注之
后自动进行.</dd>

<dt><code>C-c C-c</code></dt><dd>当光标位于一个脚注引用位置时,跳转到定义位置.如果光标在定义位置,
跳转回到引用位置.当在脚注位置时加上前缀参数调用,会提供和 <code>C-c C-x f</code> 一样的菜
单.</dd>

<dt><code>C-c C-o</code> 或 <code>mouse-1/2</code></dt><dd>脚注标签也是指向相应定义或引用的链接,你也可以使用普
通的命令打开这些链接.</dd>
</dl>
</div>
</div>
</div>


<div id="outline-container-org9c28439" class="outline-2">
<h2 id="org9c28439"><span class="todo TODO">TODO</span> 导出(Exporting)</h2>
<div class="outline-text-2" id="text-org9c28439">
<p>
当需要将自己的 org 笔记打印出来,发布到网上,或是分享给不用 Org 的人.Org 可以将
文档转化并导出为各种其他的格式,同时尽可能的保持文档结构和markup
(参见<a href="#org9fbde8c">富文本的标记(Markup for Rich Contents)</a> 和 <a href="#org16a5104">文件结构(document structure)</a>).
负责将 org 文件转换成其他格式的库叫做 <code>back-ends</code>.
Org 自带对这些 <code>back-ends</code> 支持:
</p>
<ul class="org-ul">
<li>ascii (ASCII format)</li>
<li>beamer (LaTeX Beamer format)</li>
<li>html (HTML format)</li>
<li>icalendar (iCalendar format)</li>
<li>latex (LaTeX format)</li>
<li>md (Markdown format)</li>
<li>odt (OpenDocument Text format)</li>
<li>org (Org format)</li>
<li>texinfo (Texinfo format)</li>
<li>man (Man page format)</li>
</ul>
<p>
我们还可以从 Emacs 包系统里安装导出为其他格式的库, 为了方便查找,这些包有通用的
命名模式: <code>ox-NAME</code> , 例如 <code>ox-koma-letter</code> 就是 <code>koma-letter</code> 的 back-end. 更多的
back-end 可以在 <code>org-contrib</code> 仓库中找到(参见 <a href="#orgd375552">安装(Installation)</a>).
</p>

<p>
Org 默认只加载这些 back-ends: ASCII, HTML, iCalendar, LaTeX, 和 ODT. 额外的
back-ends 可以通过两种方式加载:
</p>
<ul class="org-ul">
<li>修改 <code>org-export-backends</code></li>
<li>在 Emacs Init 文件里请求相应的库:
加载 Markdown 格式的 back-end, 在 Eamcs 配置文件里添加 <code>(require 'ox-md)</code></li>
</ul>
</div>

<div id="outline-container-org6e6f372" class="outline-3">
<h3 id="org6e6f372"><span class="todo TODO">TODO</span> 导出调度器(The Export Dispatcher) 主界面(接口).</h3>
</div>
<div id="outline-container-org53ffc01" class="outline-3">
<h3 id="org53ffc01"><span class="todo TODO">TODO</span> 导出设置(Export Settings)</h3>
<div class="outline-text-3" id="text-org53ffc01">
<p>
通用导出设置.
</p>
</div>

<div id="outline-container-orgd653688" class="outline-4">
<h4 id="orgd653688">test</h4>
<div class="outline-text-4" id="text-orgd653688">
<p>
1234
</p>
</div>
</div>
</div>

<div id="outline-container-orgef922d9" class="outline-3">
<h3 id="orgef922d9"><span class="todo TODO">TODO</span> 目录(Table of Contents)</h3>
<div class="outline-text-3" id="text-orgef922d9">
<p>
The if and where of the table of contents.
</p>
</div>
</div>

<div id="outline-container-org3caa2c8" class="outline-3">
<h3 id="org3caa2c8"><span class="todo TODO">TODO</span> 包含文件(Include File)</h3>
<div class="outline-text-3" id="text-org3caa2c8">
<p>
包含额外文件到文档.
</p>
</div>
</div>

<div id="outline-container-org77b49df" class="outline-3">
<h3 id="org77b49df">宏替换(Macro Replacement)</h3>
<div class="outline-text-3" id="text-org77b49df">
<p>
使用宏来创建模版.
</p>

<p>
宏(宏指令)在导出起见替换文本片段.宏在 <code>org-export-global-macros</code> 里全局定义,或者使
用下面语法在文档中定义:
</p>
<pre class="example">
#+MACRO: name   replacement text; $1, $2 are arguments
</pre>
<p>
上面定义的宏可以用 <code>{{{name(arg1, arg2)}}}</code> 来引用<sup><a id="fnr.78" class="footref" href="#fn.78">78</a></sup>.例如:
</p>
<pre class="example">
#+MACRO: poem Rose is $1, violet's $2. Life's ordered: Org assists you.
{{{poem(red,blue)}}}
</pre>
<p>
会变成:
</p>
<pre class="example">
Rose is red, violet's blue.  Life's ordered: Org assists you.
</pre>
<p>
作为一个特例,Org 解析每个 <code>(eval</code> 开头的替换文本为一个 Emacs Lisp 表达式并相应地执
行它们.在这样的模版中,参数成了字符串.因此,下面的宏:
</p>
<pre class="example">
#+MACRO: gnustamp (eval (concat "GNU/" (capitalize $1)))
</pre>
<p>
在导出期间会将 <code>{{{gnustamp(linux)}}}</code> 替换成 <code>GNU/Linux</code>.
</p>

<p>
Org 在以下标记区域里识别宏引用: 段落,标题,节块,表格单元格和列表. Org 也在关键字
里识别宏引用,例如 <code>CAPTION</code>, <code>TITLE</code> , <code>AUTHOR</code>, <code>DATE</code>, 和一些特定 back-end 导出选项.
</p>

<p>
Org 自带下列预定义的宏:
</p>
<dl class="org-dl">
<dt><code>{{{keyword(NAME)}}}</code></dt><dd><code>keyword</code> 宏从整个缓冲区中搜集所有 NAME 关键字的值,并用空
格分隔.</dd>
<dt><code>{{{title}}}</code></dt><dd><code>title</code> 宏是 <code>{{{keyword(TITLE)}}}</code> 的简写形式.</dd>
<dt><code>{{{author}}}</code></dt><dd><code>author</code> 宏是 <code>{{{keyword(AUTHOR)}}}</code> 的简写形式.</dd>
<dt><code>{{{email}}}</code></dt><dd><code>email</code> 宏是 <code>{{{keyword(EMAIL)}}}</code> 的简写形式.</dd>
<dt><code>{{{date}}}</code> , <code>{{{date(FORMAT)}}}</code></dt><dd>该宏引用 <code>DATE</code> 关键字. FORMAT 是 <code>date</code> 宏的可
选参数,只有在 <code>DATE</code> 是单个时间戳时使用. FORMAT 应该是一个能被
<code>format-time-string</code> 方法解析的格式字符串.</dd>
<dt><code>{{{time(FORMAT)}}}</code> , <code>{{{modification-time(FORMAT, VC)}}}</code></dt><dd>这些宏引用文档导出
的日期时间和文档修改的日期时间. FORMAT 是一个能被 <code>format-time-string</code> 解析的字
符串.如果 <code>modification-time</code> 宏的第二个参数非 <code>nil</code>, Org 会使用 <code>vc.el</code> 来从版本控
制系统里获取文档的修改时间.否则,Org 会读取文件属性来获取时间.</dd>
<dt><code>{{{input-file}}}</code></dt><dd>该宏引用导出文件的文件名.</dd>
<dt><code>{{{property(PROPERTY-NAME)}}}</code>, <code>{{{property(PROPERTY-NAME, SEARCH OPTION)}}}</code></dt><dd>该宏返回当前条目中 PROPERTY-NAME 属性的值. 如果 SEARCH-OPTION 指向一个"远程"条
目,则使用该条目中的属性/值.</dd>
<dt><code>{{{n}}}</code> , <code>{{{n(NAME)}}}</code> , <code>{{{n(NAME, ACTION)}}}</code></dt><dd>该宏实现了一个自定义的计数
器,用来返回在导出缓冲区时目前为止宏被扩展的次数.你可以使用不同的 NAME 值来创建
多个计数器.如果 ACTION 是 <code>-</code> ,计数器的前一个值被保留,也就是说,指定的计数器不会
在增加计数了.如果值为一个数字,指定的计数器会被设定为该数值.如果是任何其他非空
字符串,指定的计数器会被重置为1.你也可以将 NAME 留空来重置默认计数器.</dd>
</dl>


<p>
此外,行内代码块(参见<a href="#orgf2f7b6e">代码块的结构(Structure of Code Blocks)</a>) 使用特殊的 <code>results</code>
宏来标记他们的输出.因此,除非你知道你在做什么,否则不建议你将其重新定义.
</p>

<p>
包裹的括号可以通过将 <code>org-hide-macro-markers</code> 设置为非 <code>nil</code> 的值来隐藏.
</p>

<p>
Org 会在导出过程的开始就扩展宏.
</p>
</div>
</div>

<div id="outline-container-org63f66ca" class="outline-3">
<h3 id="org63f66ca"><span class="todo TODO">TODO</span> 注释行(Comment Lines)</h3>
<div class="outline-text-3" id="text-org63f66ca">
<p>
不会被导出的内容.
</p>
</div>
</div>

<div id="outline-container-org98dd6be" class="outline-3">
<h3 id="org98dd6be"><span class="todo TODO">TODO</span> ASCII/Latin-1/UTF-8 export</h3>
<div class="outline-text-3" id="text-org98dd6be">
<p>
Exporting to flat files with encoding.
</p>
</div>
</div>

<div id="outline-container-org567c68e" class="outline-3">
<h3 id="org567c68e"><span class="todo TODO">TODO</span> 幻灯片导出(Beamer Export)</h3>
<div class="outline-text-3" id="text-org567c68e">
<p>
制作演示文档和幻灯片.
</p>
</div>
</div>
<div id="outline-container-org7b70547" class="outline-3">
<h3 id="org7b70547">HTML 导出(HTML Export)</h3>
<div class="outline-text-3" id="text-org7b70547">
<p>
导出为 HTML.
</p>

<p>
Org mode 包含一个 HTML 导出器,它具有与 XHTML 1.0 严格标准兼容的广泛的 HTML 格式.
</p>
</div>
<div id="outline-container-orga8b6477" class="outline-4">
<h4 id="orga8b6477">HTML 导出命令(HTML export commands)</h4>
<div class="outline-text-4" id="text-orga8b6477">
<p>
唤起 HTML 导出.
</p>

<dl class="org-dl">
<dt><code>C-c C-e h h</code> &#x2013; (org-html-export-to-html)</dt><dd>导出为带 <code>.html</code> 扩展的 HTML 文件.对
于 <code>myfile.org</code> 文件,Org 将其导出为 <code>myfile.html</code> 覆盖文件不会警告. <code>C-c C-e h o</code> 导
出为 HTML 文件并在网页浏览器里打开.</dd>
<dt><code>C-c C-e h H</code> &#x2013; (org-html-export-as-html)</dt><dd>导出到一个暂时的缓冲区.不创建文件.</dd>
</dl>
</div>
</div>

<div id="outline-container-org6648330" class="outline-4">
<h4 id="org6648330">HTML 特定的导出设置(HTML specific export settings)</h4>
<div class="outline-text-4" id="text-org6648330">
<p>
HTML 导出的设置.
</p>

<p>
HTML 导出有许多关键字,和 <a href="#org53ffc01">导出设置(Export Settings)</a> 里描述的通用选项设置类似.
</p>

<dl class="org-dl">
<dt>DESCRIPTION</dt><dd>这是文档的描述,HTML 导出器将其作为 HTML 元标签(meta tags)插入到
HTML 文件中. 对于长描述,使用多个 DESCRIPTION 行. 导出器会负责正确包装行.
导出器包括许多其他元标签,可以通过修改 <code>org-html-meta-tags</code> 来自定义.</dd>
<dt>HTML_DOCTYPE</dt><dd>指定文档类型,例如: HTML5 <code>(org-html-doctype)</code>.</dd>
<dt>HTML_CONTAINER</dt><dd>指定 HTML 容器(container), 例如 <code>div</code> 用来包裹元素和小节
<code>(org-html-container-element)</code>.</dd>
<dt>HTML_LINK_HOME</dt><dd>首页链接的 URL <code>(org-html-link-home)</code>.</dd>
<dt>HTML_LINK_UP</dt><dd>导出的 HTML 页面的上级链接的 URL <code>(org-html-link-up)</code></dd>
<dt>HTML_MATHJAX</dt><dd>MathJax <code>(org-html-mathjax-options)</code> 的选项. MathJax 是用来在
HTML 文档里排版 LaTex 数学公式的. 具体例子请参考 <a href="#org063f591">HTML 导出的数学格式(Math formatting in HTML export)</a>.</dd>
<dt>HTML_HEAD</dt><dd>添加到 HTML 文档的头(head)的任意行 <code>(org-html-head)</code>.</dd>
<dt>HTML_HEAD_EXTRA</dt><dd>更多的添加到 HTML 文档头的任意行 <code>(org-html-head-extra)</code>.</dd>
<dt>KEYWORDS</dt><dd>用来描述文档内容的关键字.HTML 导出器将这些关键字作为 HTML 元标签插
入.对于长的关键字,请使用多个 <code>KEYWORDS</code> 行.</dd>
<dt>LATEX_HEADER</dt><dd>添加在 premble 之后的任意行;HTML 导出器在将 LaTex 片段转换成图
片时将其插入.请参见 <a href="#org063f591">HTML 导出的数学格式(Math formatting in HTML export)</a>.</dd>
<dt>SUBTITLE</dt><dd>文档的副标题.如果文档类型是 <code>HTML5</code> 并且 CSS 有 <code>subtitle</code> 类,那么HTML
导出器会格式化副标题.</dd>
</dl>


<p>
这里的某些关键字会在手册的下面几节有详细解释.
</p>
</div>
</div>
<div id="outline-container-orgb33fa7f" class="outline-4">
<h4 id="orgb33fa7f">HTML 文档类型(HTML doctypes)</h4>
<div class="outline-text-4" id="text-orgb33fa7f">
<p>
导出为各种 (X)HTML 格式.
</p>

<p>
Org 可以导出为各种 (X)HTML 格式.
</p>

<p>
设置 <code>org-html-doctype</code> 变量来设置不同的 (X)HTML 变种.取决于变种类型,HTML 导出器将
对应调整 HTML 转换的语法.Org 包括下列现成的变种:
</p>
<ul class="org-ul">
<li>‘"html4-strict"’</li>
<li>‘"html4-transitional"’</li>
<li>‘"html4-frameset"’</li>
<li>‘"xhtml-strict"’</li>
<li>‘"xhtml-transitional"’</li>
<li>‘"xhtml-frameset"’</li>
<li>‘"xhtml-11"’</li>
<li>‘"html5"’</li>
<li>‘"xhtml5"’</li>
</ul>


<p>
更多细节请查看变量 <code>org-html-doctype-alist</code>. 默认导出类型为 <code>xhtml-strict</code>.
</p>

<p>
Org 的HTML 导出器默认不开启 HTML5 标准引进的块元素.要开启这些功能,请将
<code>org-html-html5-fancy</code> 设置为非 <code>nil</code>. 或者在文件里使用 <code>OPTIONS</code> 行,设置为 <code>html5-fancy</code>.
</p>

<p>
HTML5 文档现在可以有任意的 <code>#+BEGIN</code> &#x2026; <code>#+END</code> 块.例如:
</p>
<pre class="example">
#+BEGIN_aside
  Lorem ipsum
#+END_aside
</pre>
<p>
导出成:
</p>
<pre class="example">
&lt;aside&gt;
  &lt;p&gt;Lorem ipsum&lt;/p&gt;
&lt;/aside&gt;
</pre>

<p>
这个:
</p>
<pre class="example">

#+ATTR_HTML: :controls controls :width 350
#+BEGIN_video
#+HTML: &lt;source src="movie.mp4" type="video/mp4"&gt;
#+HTML: &lt;source src="movie.ogg" type="video/ogg"&gt;
Your browser does not support the video tag.
#+END_video
</pre>
<p>
导出成:
</p>
<pre class="example">
&lt;video controls="controls" width="350"&gt;
  &lt;source src="movie.mp4" type="video/mp4"&gt;
  &lt;source src="movie.ogg" type="video/ogg"&gt;
  &lt;p&gt;Your browser does not support the video tag.&lt;/p&gt;
&lt;/video&gt;
</pre>

<p>
当特殊块没有相应的 HTML5 元素时, HTML 导出器将其转换成标准转换(参见
<code>org-html-html5-elements</code>). 例如, <code>#+BEGIN_lederhosen</code> 转换成 <code>&lt;div
class="lederhosen"&gt;</code>.
</p>

<p>
特殊块不能有标题.因为 HTML 导出器将标题和其内容用 <code>&lt;section&gt;</code> 或 <code>&lt;article&gt;</code> 标签包
裹,为标签设置 <code>HTML_CONTAINER</code> 属性来选择使用的标签.
</p>
</div>
</div>
<div id="outline-container-orgf9214ad" class="outline-4">
<h4 id="orgf9214ad">HTML 前导和后导(HTML preambel and postamble)</h4>
<div class="outline-text-4" id="text-orgf9214ad">
<p>
插入前导和后导.
</p>

<p>
HTML 导出器有前导和后导的描述. <code>org-html-preambel</code> 的默认值为 <code>t</code>, 这会让 HTML 导出
器插入前导. 格式字符串请查看 <code>org-html-preamble-format</code>.
</p>

<p>
将 <code>org-html-preamble</code> 设置为字符串来重写默认的格式字符串. 如果该字符串是一个方法,
HTML 导出器预期该方法执行后返回一个字符串. HTML 导出器将这个返回的字符串插入到前
导中.如果 <code>org-html-preamble</code> 设置为 <code>nil</code> 则HTML 导出器不会插入前导.
</p>

<p>
<code>org-html-postamble</code> 的默认值是 <code>auto</code>, 会让 HTML 导出器从查找到的作者名,邮箱地址,创
建者名和日期中建立后导. 将 <code>org-html-postamble</code> 设置为 <code>t</code> 会以变量
<code>org-html-postamble-format</code> 里指定的格式插入后导.如果 <code>org-html-postamble</code> 设置为
<code>nil</code> ,则 HTML 导出器不会插入后导.
</p>
</div>
</div>
<div id="outline-container-org6595c64" class="outline-4">
<h4 id="org6595c64">引用 HTML 标签(Quoting HTML tags)</h4>
<div class="outline-text-4" id="text-org6595c64">
<p>
直接在 Org 文件里使用 HTML.
</p>

<p>
HTML 导出器 back-end 会将 <code>&lt;</code> 和 <code>&gt;</code> 转换成 <code>&amp;lt;</code> 和 <code>&amp;gt;</code>. 要在Org 文件里插入原生
HTML 代码以便 HTML 导出后端能在输出里插入 HTML 代码,请使用内嵌语法: <code>@@html:</code>
&#x2026; <code>@@</code>. 例如:
</p>
<pre class="example">
@@html:&lt;b&gt;@@bold text@@html:&lt;/b&gt;@@
</pre>
<p>
对于大的原生 HTML 代码块,请使用下面这些 HTML 导出代码块:
</p>
<pre class="example">
#+HTML: Literal HTML code for export
</pre>
<pre class="example">
#+BEGIN_EXPORT html
  All lines between these markers are exported literally
#+END_EXPORT

</pre>
</div>
</div>
<div id="outline-container-orgb0457f4" class="outline-4">
<h4 id="orgb0457f4">HTML 导出的标题(Headlines in HTML export)</h4>
<div class="outline-text-4" id="text-orgb0457f4">
<p>
格式化标题.
</p>

<p>
标题会被导出成 <code>&lt;h1&gt;</code> , <code>&lt;h2&gt;</code> 等标签.每个标题都从 <code>CUSTOM_ID</code> 属性里获取 <code>id</code>, 或者一个
唯一的生成值, 参考 <a href="#orgc3efa52">内部链接(Internal Links)</a>.
</p>

<p>
当 <code>org-html-self-link-headlines</code> 被设置为一个非 <code>nil</code> 值时,标题的文本也会用 <code>&lt;a&gt;</code> 标
签包裹.这些标签都有 <code>href</code> 属性,能让他们链接到他们自身.
</p>
</div>
</div>
<div id="outline-container-orge4a4f3a" class="outline-4">
<h4 id="orge4a4f3a">HTML 导出的链接(Links in HTML export)</h4>
<div class="outline-text-4" id="text-orge4a4f3a">
<p>
插入和格式化链接.
</p>

<p>
HTML 导出后端在输出中将 Org 的内部链接(<a href="#orgc3efa52">内部链接(Internal Links)</a>)转换成等效的
HTML 链接. 该后端对由无线电目标(参见 <a href="#orgc93661a">无线电目标(Radio Targets)</a>) 生成的自动链接
进行类似处理. 对于链接到外部文件的 Org 链接, 该后端将这些链接转换成相对路径的链
接.
</p>

<p>
对于链接到其他 <code>.org</code> 文件的链接,该后端自动将文件扩展改为 <code>.html</code> 并将文件路径转换成
相对路径. 如果在同一位置中该 <code>.org</code> 文件有一个同等的 <code>.html</code> 版本,则不需要任何进一步
手动操作,转换的链接就能正常工作.然而,想要禁止这种路径的自动转换,请将
<code>org-html-link-org-files-as-html</code> 设置为 <code>nil</code>. 当禁用后, HTML 导出后端会在 HTML 输
出里替换基于 ID 的链接.
更多关于发布到目录时链接文件的信息,请查看 <a href="#org9acefd1">发布链接(Publishing links)</a>.
</p>

<p>
Org 文件也可以对 HTML 导出后端有特殊指令. 例如,使用 <code>#+ATTR_HTML</code> 行来为 <code>&lt;a&gt;</code> 或
<code>&lt;img&gt;</code> 标签指定新的格式属性.下面这个例子展示了修改链接的标题和样式:
</p>
<pre class="example">
#+ATTR_HTML: :title The Org mode homepage :style color:red;
[[https://orgmode.org]]
</pre>
<p>
看看效果:
</p>
<p title="The Org mode homepage" style="color:red;">
<a href="https://orgmode.org" title="The Org mode homepage" style="color:red;">https://orgmode.org</a>
</p>
<p title="The Org mode homepage" style="color:#66CCFF;">
<a href="https://orgmode.org" title="The Org mode homepage" style="color:#66CCFF;">https://orgmode.org</a>
</p>
</div>
</div>
<div id="outline-container-orga703c9c" class="outline-4">
<h4 id="orga703c9c">HTML 导出的表格(Tables in HTML export)</h4>
<div class="outline-text-4" id="text-orga703c9c">
<p>
如何修改表格的格式.
</p>

<p>
当导出 Org 表格到 HTML 时, HTML 导出后端使用 <code>org-html-table-default-attributes</code>
里设置的样式. 默认设置下,导出器不会绘制框架和单元格边界. 要为表格更改此设置,请在
Org 文件的表格之前使用下列行:
</p>
<pre class="example">
#+CAPTION: This is a table with lines around and between cells
#+ATTR_HTML: :border 2 :rules all :frame border :width 500
</pre>
<p>
看看效果:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">A</td>
<td class="org-right">B</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table>
<p>
加上上面设置之后:
</p>
<blockquote>
<p>
这里要注意的是,CAPTION 说明关键字导出后的宽度取决于表格宽度,所以将表格宽度设置为
500,不然描述部分会被切分成好几行.
</p>
</blockquote>
<table border="2" cellspacing="0" cellpadding="6" rules="all" frame="border" width="500">
<caption class="t-above"><span class="table-number">Table 2:</span> This is a table with lines around and between cells</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">A</td>
<td class="org-right">B</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table>

<p>
当导出为 HTML 时,HTML 导出后端保存 Org 表格里的列组(参见 <a href="#orgaeacd64">列组(Column Groups)</a>).
</p>

<p>
用于 HTML 导出表格的其他选项:
</p>
<dl class="org-dl">
<dt>org-html-table-align-individual-fields</dt><dd>非 <code>nil</code> 时,将用于对齐的样式属性附加到
每个表格字段.</dd>
<dt>org-html-table-caption-above</dt><dd>非 <code>nil</code> 时将说明(caption) 字符串放置在表格上面.</dd>
<dt>org-html-table-data-tags</dt><dd>表格数据字段的开始和结束标签.</dd>
<dt>org-html-table-default-attributes</dt><dd>表格标签的默认属性和值.</dd>
<dt>org-html-table-header-tags</dt><dd>表头字段的开始和结束标签.</dd>
<dt>org-html-table-row-tags</dt><dd>表格行的开始和结束标签.</dd>
<dt>org-html-table-use-header-tags-for-first-column</dt><dd>非 <code>nil</code> 时格式化带表头标签的
一列.</dd>
</dl>
</div>
</div>
<div id="outline-container-orgdcf0d07" class="outline-4">
<h4 id="orgdcf0d07">HTML 导出的图片(Images in HTML export)</h4>
<div class="outline-text-4" id="text-orgdcf0d07">
<p>
如何在 HTML 输出里插入图片.
</p>

<p>
HTML 后端具有将 Org 图片链接转换为 HTML 内联图像和可点击图像链接的功能.
</p>

<p>
当 Org 文件里的链接没有描述时, HTML 导出后端默认将该图片内联.例如:
<code>[[file:myimg.jpg]]</code> 是内联的, <code>[[file:myimg.jpg][the image]]</code> 链接到文本
<code>"the image"</code> . 更多细节请查看变量 <code>org-html-inline-images</code>.
</p>

<p>
另一方面,如果 Org 链接的描述部分本身时另一个链接,例如 <code>file:</code> 或 <code>http:</code> URL 指向一
个图片,HTML 导出后端将图片内联并连接到主图片.这个 Org 语法使后端能将低分辨率缩略
图链接到图像的高分辨率版本,如下例所示:
</p>
<pre class="example">
[[file:highres.jpg][file:thumb.jpg]]
</pre>

<p>
要改变内联图片的属性,请在 Org 文件里使用 <code>#+ATTR_HTML</code> 行.下面例子展示了向右对齐,
并添加了 <code>alt</code> 和 <code>title</code> 属性以支持文本查看器和现代网页可访问标准.
</p>
<pre class="example">
#+CAPTION: A black cat stalking a spider
#+ATTR_HTML: :alt cat/spider image :title Action! :align right
[[./img/a.jpg]]
</pre>
<p>
HTML 导出后端按原样从 Org 文件里复制 <code>http</code> 链接.
</p>
</div>
</div>

<div id="outline-container-org063f591" class="outline-4">
<h4 id="org063f591">HTML 导出的数学格式(Math formatting in HTML export)</h4>
<div class="outline-text-4" id="text-org063f591">
<p>
网页上也优雅的数学公式.
</p>

<p>
LaTex 数学片段 (参见<a href="#org584dcbd">LaTex 片段(LaTex fragments)</a>) 可以在 HTML 页面上以两种不同的
方式显示.
默认是使用 MathJax(<a href="https://www.mathjax.org">https://www.mathjax.org</a>),在Org里应该可以开箱即用<sup><a id="fnr.79" class="footref" href="#fn.79">79</a></sup><sup>, </sup><sup><a id="fnr.80" class="footref" href="#fn.80">80</a></sup>. 一
些 MathJax 显示选项可以通过 <code>org-html-mathjax-options</code> 配置,或者在缓冲区里配置. 例
如,使用下面的配置:
</p>
<pre class="example">
#+HTML_MATHJAX: align: left indent: 5em tagside: left font: Neo-Euler
#+HTML_MATHJAX: cancel.js noErrors.js
</pre>
<p>
方程标签显示在左边距上,方程式离左边距 5 em. 此外,该配置加载了两个 MathJax 扩展
<code>cancel.js</code> 和 <code>noErrors.js</code> .<sup><a id="fnr.81" class="footref" href="#fn.81">81</a></sup>
</p>

<p>
所有支持的变量请查看 <code>org-html-mathjax-options</code> 的文档那个字符串. MathJax 模版可以
通过 <code>org-html-mathjax-template</code> 配置.
</p>

<p>
如果你喜欢的话,你也可以要求 LaTex 片段被处理成小图片,并插入到浏览器页面中.在
MathJax 可用之前,这是 org 文件的默认方法. 该方法要求 dvipng 程序, dvisvgm 程序或
者 ImageMagick 套件在你的系统上可用. 你也可以使用下面设置来使用该处理方式:
</p>
<pre class="example">
#+OPTIONS: tex:dvipng
或
#+OPTIONS: tex:dvisvgm
或
#+OPTIONS: tex:imagemagick
</pre>
</div>
</div>
<div id="outline-container-org43d5273" class="outline-4">
<h4 id="org43d5273">HTML 导出的文本区域(Text areas in HTML export)</h4>
<div class="outline-text-4" id="text-org43d5273">
<p>
另一种展示例子的方式.
</p>

<p>
在 Org mode 的 Babel 出现之前,一种发布代码到 HTML 的流行的方法是使用
<code>:textarea</code>. 这种方法的好处就是复制和粘贴是使用简单的 JavaScript 命令内建到浏览器
里的.甚至粘贴前的复制也十分简单.
</p>

<p>
HTML 导出后端能创建这样的文本区域.它需要一个带 <code>:textarea</code> 选项的 <code>#+ATTR_HTML</code> 行,
就像下面例子里展示的一样.该行后面必须跟着一个示例或者源代码块.其他的 Org 块类型
不支持 <code>:textarea</code> 选项.
</p>

<p>
默认情况下,HTML 导出后端创建一个文本区域,有 80 字符宽度和能容纳内容的高度. 重写
这些默认设置请在 <code>#+ATTR_HTML</code> 行里使用 <code>:width</code> 和 <code>:height</code> 选项.
</p>

<pre class="example">
#+ATTR_HTML: :textarea t :width 40
#+BEGIN_EXAMPLE
  (defun org-xor (a b)
     "Exclusive or."
     (if a (not b) b))
#+END_EXAMPLE
</pre>
</div>
</div>
<div id="outline-container-org63186ef" class="outline-4">
<h4 id="org63186ef">CSS 支持(CSS support)</h4>
<div class="outline-text-4" id="text-org63186ef">
<p>
改变输出的外观.
</p>

<p>
你可以修改导出文件的 CSS 格式定义. HTML 导出器将下列特殊的 CSS classes<sup><a id="fnr.82" class="footref" href="#fn.82">82</a></sup> 分
配给文档合适的部分,你的格式定义可能会改变这些设置,外加任何标准 class 例如标题,列
表等等:
</p>
<dl class="org-dl">
<dt><code>p.author</code></dt><dd>作者信息,包括邮箱.</dd>
<dt><code>p.date</code></dt><dd>发布日期.</dd>
<dt><code>p.creator</code></dt><dd>创建者信息,关于 Org mode 版本的信息.</dd>
<dt><code>.title</code></dt><dd>文档标题.</dd>
<dt><code>.subtitle</code></dt><dd>文档副标题.</dd>
<dt><code>.todo</code></dt><dd>TODO 关键字,所有的未完成状态.</dd>
<dt><code>.done</code></dt><dd>DONE 关键字,所有完成状态.</dd>
<dt><code>.WAITING</code></dt><dd>每个关键字也使用其自身的名字命名类名.</dd>
<dt><code>.tamestamp</code></dt><dd>时间戳</dd>
<dt><code>.timestamp-kwd</code></dt><dd>时间戳相关联的关键字,例如 <code>SCEDULED</code></dd>
<dt><code>.timestamp-wrapper</code></dt><dd>关键字加时间戳周围的范围.</dd>
<dt><code>.tag</code></dt><dd>标题中的标签</dd>
<dt><code>._HOME</code></dt><dd>每个标签用其名字作为类名, "@" 被 "_" 替换.</dd>
<dt><code>.target</code></dt><dd>链接的目标</dd>
<dt><code>.linenr</code></dt><dd>代码例子里的行号</dd>
<dt><code>.code-highlighted</code></dt><dd>高亮引用的代码行</dd>
<dt><code>div.outline-N</code></dt><dd>层级为 N 的大纲(标题加文本)的 div 块</dd>
<dt><code>div.outline-text-N</code></dt><dd>层级为 N 的大纲文本的额外 div 块</dd>
<dt><code>.section-nubmer-N</code></dt><dd>标题里第 N 个小节,每个层级都不同</dd>
<dt><code>.figure-number</code></dt><dd>像 "Figure 1:" 这样的标记</dd>
<dt><code>.table-number</code></dt><dd>像 "Table 1:" 这样的标记</dd>
<dt><code>.listing-number</code></dt><dd>像 "Listing 1:" 这样的标记</dd>
<dt><code>div.figure</code></dt><dd>如何格式化一个内嵌图片</dd>
<dt><code>pre.src</code></dt><dd>格式化源代码</dd>
<dt><code>pre.example</code></dt><dd>普通例子</dd>
<dt><code>p.verse</code></dt><dd>节段</dd>
<dt><code>div.footnotes</code></dt><dd>标题的脚注部分</dd>
<dt><code>p.footnote</code></dt><dd>脚注定义段落,包括脚注</dd>
<dt><code>.footref</code></dt><dd>脚注引用数(总是一个上标)</dd>
<dt><code>.footnum</code></dt><dd>脚注定义里的脚注数(总是一个上标)</dd>
<dt><code>.org-svg</code></dt><dd>链接到 '.svg' 图片的默认类.</dd>
</dl>


<p>
HTML 导出的 back-end 在每一个导出的 HTML 文件中都包括一个紧凑的默认样式.要用另一
种样式覆盖默认样式,请在Org 文件里使用这些关键字.它们会替换 HTML 导出器使用的全局
默认设置.
</p>
<pre class="example">
#+HTML_HEAD: &lt;link rel="stylesheet" type="text/css" href="style1.css" /&gt;
#+HTML_HEAD_EXTRA: &lt;link rel="alternate stylesheet" type="text/css" href="style2.css" /&gt;
</pre>

<p>
只关闭默认样式,请自定义 <code>org-heml-head-include-default-style</code> 变量,或者在 Org 文件
里使用下面这个选项行:
</p>
<pre class="example">
#+OPTIONS: html-style:nil
</pre>

<p>
对于较长的样式定义,使用多个 <code>HTML_HEAD</code> 和 <code>HTML_HEAD_EXTRA</code> 关键字或者使用 <code>&lt;style&gt;</code>
&#x2026; <code>&lt;/style&gt;</code> 块包括样式.这两种方法都能避免应用外部文件.
</p>

<p>
要为子树添加样式,请使用 <code>HTML_CONTAINER_CLASS</code> 属性来为树分配类. 要为特定标题指定
CSS 样式,你可以使用 <code>CUSTOM_ID</code> 属性里指定的 ID. 你也可以用 <code>HTML_HEADLINE_CLASS</code> 属
性将特定的类分配给一个标题.
</p>

<p>
绝对不要修改 <code>org-html-style-default</code> 常量. 而是使用上面描述的其他更简单的方法来自
定义.
</p>
</div>
</div>
<div id="outline-container-orgf3ed7db" class="outline-4">
<h4 id="orgf3ed7db">JavaScript 支持(JavaScript support)</h4>
<div class="outline-text-4" id="text-orgf3ed7db">
<p>
Info and folding in a web browser.
</p>

<p>
Sebastian Rose(塞巴斯蒂安⸱罗斯)编写了一个 JavaScript 程序,专门设计用来允许用两种
不同的方式查看Org 创建的 HTML 文件.一种是类似 <span class="underline">Info</span> 的模式,这种模式里,每一节都分
开展示,并且可以使用 <code>n</code> 与 <code>p</code> 键导航,而且一些其他的快捷键也可以使用,按 <code>?</code> 来查看可用
快捷键的概述.第二种方式有一个 <span class="underline">folding</span> 视图(折叠视图),就像Emacs 里提供的 Org. 该
脚本位于 <a href="https://orgmode.org/org-info.js">https://orgmode.org/org-info.js</a> ,其文档位于
<a href="https://orgmode.org/worg/code/org-info-js/">https://orgmode.org/worg/code/org-info-js/</a> .该脚本托管在 <a href="https://orgmode.org">https://orgmode.org</a> 上,
但是为了可靠性,最好将其安装在您自己的 Web 服务器上.
</p>

<p>
要使用这个程序,只需要将这行添加到 Org 文件中:
</p>
<pre class="example">
#+INFOJS_OPT: view:info toc:nil
</pre>

<p>
现在,HTML header 有了自动调用脚本的代码.对于设置选项,请使用上面的语法设置以下描
述的选项:
</p>
<dl class="org-dl">
<dt><code>path:</code></dt><dd>脚本的路径.默认是从 <a href="https://orgmode.org/org-info.js">https://orgmode.org/org-info.js</a> 里抓取脚本,但是你
可能想使用这样的路径 <code>../scripts/org-info.js</code> 来使用脚本的本地副本.</dd>
<dt><code>view:</code></dt><dd>当网站第一次显示时的初始视图.可能的值有:
<dl class="org-dl">
<dt><code>info</code></dt><dd>类似 Info 的界面,每一页一节.</dd>
<dt><code>overview</code></dt><dd>折叠界面,初始化只显示最高层级</dd>
<dt><code>content</code></dt><dd>折叠界面,开始显示所有标题.</dd>
<dt><code>showall</code></dt><dd>折叠界面,所有标题和文本可见.</dd>
</dl></dd>
<dt><code>sdepth:</code></dt><dd>对 info 和 folding 模式来说视为单独一节内容的最大标题层级.默认值取
自 <code>org-export-headline-levels</code> ,也就是说, <code>H</code> 在 <code>OPTIONS</code> 里切换.如果该值比
<code>org-export-headline-levels</code> 里的值要小,每一个 indo/folding 小节仍然可以包含子标
题.</dd>
<dt><code>toc:</code></dt><dd>目录初始时是否可见?即使设置为 <code>nil</code> ,你也可以用 <code>i</code> 进入 "toc".</dd>
<dt><code>tdepth:</code></dt><dd>目录的深度.默认值取自变量 <code>org-export-headline-levels</code> 和
<code>org-export-with-toc</code>.</dd>
<dt><code>ftoc:</code></dt><dd>页面的 CSS 是否为 "toc" 指定了固定位置?如果是,目录会展示为一个小节.</dd>
<dt><code>ltoc:</code></dt><dd>每一小节是否应该有简短的内容?如果该部分应该高于初始文本,则将其设置为
<code>above</code>.</dd>
<dt><code>mouse:</code></dt><dd>当鼠标滑过时,标题被高亮.应该设置为 <code>underline</code> (默认) 或者为背景色(例
如 <code>#CCCCCC</code>).</dd>
<dt><code>buttons:</code></dt><dd>视图切换按钮是否应该到处都有?当为 <code>nil</code> (默认)时,只有一个这样的按钮.</dd>
</dl>


<p>
你可以通过自定义变量 <code>org-infojs-options</code> 来为这些选项选择默认值.如果你总是想要将
脚本应用到您的页面,请配置变量 <code>org-export-html-use-infojs</code>.
</p>
</div>
</div>
</div>
<div id="outline-container-orge915578" class="outline-3">
<h3 id="orge915578"><span class="todo TODO">TODO</span> LaTex 导出(LaTex Export)</h3>
<div class="outline-text-3" id="text-orge915578">
<p>
导出为 LaTex 并处理成 PDF.
</p>
</div>
</div>
<div id="outline-container-org962e9d4" class="outline-3">
<h3 id="org962e9d4"><span class="todo TODO">TODO</span> Markdown 导出(Markdown Export)</h3>
<div class="outline-text-3" id="text-org962e9d4">
<p>
导出为 Markdown.
</p>
</div>
</div>
<div id="outline-container-org60428bf" class="outline-3">
<h3 id="org60428bf"><span class="todo TODO">TODO</span> OpenDocument Text 导出(OpenDocument Text Export)</h3>
<div class="outline-text-3" id="text-org60428bf">
<p>
导出为 OpenDocument Text.
</p>
</div>
</div>
<div id="outline-container-org5489926" class="outline-3">
<h3 id="org5489926"><span class="todo TODO">TODO</span> Org 导出(Org Export)</h3>
<div class="outline-text-3" id="text-org5489926">
<p>
导出为 Org.
</p>
</div>
</div>
<div id="outline-container-org53aa008" class="outline-3">
<h3 id="org53aa008"><span class="todo TODO">TODO</span> Texinfo 导出(Texinfo Export)</h3>
<div class="outline-text-3" id="text-org53aa008">
<p>
导出为 Texinfo.
</p>
</div>
</div>
<div id="outline-container-orgd5d356d" class="outline-3">
<h3 id="orgd5d356d"><span class="todo TODO">TODO</span> iCalendar 导出(iCalendar Export)</h3>
<div class="outline-text-3" id="text-orgd5d356d">
<p>
导出为 iCalendar.
</p>
</div>
</div>
<div id="outline-container-org1a99062" class="outline-3">
<h3 id="org1a99062"><span class="todo TODO">TODO</span> 其他内置 Back-ends(Other Built-in Back-ends)</h3>
<div class="outline-text-3" id="text-org1a99062">
<p>
导出为 man 页面.
</p>
</div>
</div>
<div id="outline-container-org2f86caf" class="outline-3">
<h3 id="org2f86caf">高级导出配置(Advanced Export Configuration)</h3>
<div class="outline-text-3" id="text-org2f86caf">
<p>
调整导出的输出.
</p>

<p>
<b>导出钩子</b>
在真正导出开始之前导出程序会执行两个钩子函数.第一个钩子函数,
<code>org-export-before-processing-hook</code> ,运行在缓冲区的宏,Babel 代码,和 include 关
键字的扩展之前. 第二个钩子函数, <code>org-export-before-parsing-hook</code> ,在缓冲区被解析之
前运行.
</p>

<p>
添加到这些钩子函数的方法都带有单个参数调用:导出后端实际上作为一个 symbol 使用.你
可以使用它们对文档进行重型结构修改.例如,你能在导出期间移除缓冲区里的每个标题:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">my-headline-removal</span> (backend)
  <span style="font-style: italic;">"Remove all headlines in the current buffer.</span>
<span style="font-style: italic;">BACKEND is the export back-end being used, as a symbol."</span>
  (org-map-entries
   (<span style="font-weight: bold;">lambda</span> () (delete-region (point) (line-beginning-position 2)))))

(add-hook 'org-export-before-parsing-hook #'my-headline-removal)
</pre>
</div>

<p>
<b>过滤器</b>
过滤器是应用到一个给定后端特定部分的函数列表.过滤器里第一个函数的输出会传递给过
滤器里的下一个函数.最终的输出就是过滤器最后一个函数的输出.
</p>

<p>
org 导出程序有许多过滤器套件,可以应用到不同类型的对象,纯文本,解析树,导出选项,和
最后的输出格式.过滤器在元素类型或者对象类型之后命名:
<code>org-export-filter-TYPE-functions</code>, 其中 TYPE 是过滤器的目标类型.有效的类型有:
</p>

<p>
body                     bold                     babel-call
center-block             clock                    code
diary-sexp               drawer                   dynamic-block
entity                   example-block            export-block
export-snippet           final-output             fixed-width
footnote-definition      footnote-reference       headline
horizontal-rule          inline-babel-call        inline-src-block
inlinetask               italic                   item
keyword                  latex-environment        latex-fragment
line-break               link                     node-property
options                  paragraph                parse-tree
plain-list               plain-text               planning
property-drawer          quote-block              radio-target
section                  special-block            src-block
statistics-cookie        strike-through           subscript
superscript              table                    table-cell
table-row                target                   timestamp
underline                verbatim                 verse-block
</p>

<p>
这里有一个过滤器的例子,它将针对 LaTex 后端,将Org 缓冲区里连续的 ~~ 替换成 ~:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">my-latex-filter-nobreaks</span> (text backend info)
  <span style="font-style: italic;">"Ensure \"&#160;\" are properly handled in LaTeX export."</span>
  (<span style="font-weight: bold;">when</span> (org-export-derived-backend-p backend 'latex)
    (replace-regexp-in-string <span style="font-style: italic;">"&#160;"</span> <span style="font-style: italic;">"~"</span> text)))

(add-to-list 'org-export-filter-plain-text-functions
             'my-latex-filter-nobreaks)
</pre>
</div>
<p>
一个过滤器需要三个参数:要转换的代码,后端名称,和一些可选的关于导出过程的信息. 第
三个参数可以安全的忽略.请注意,使用 <code>org-export-derived-backend-p</code> 判断,是测试是否
为 latex 后端或其他从 latex 衍生的后端,例如 beamer.
</p>

<p>
<b>为单独文件定义过滤器</b>
Org 导出不仅能为后端过滤,也能通过 <code>BIND</code> 关键字为特定的文件过滤.下面是一个例子,拥
有两个过滤器;一个移除时间戳的括号,另一个移除 strike-through(删除线)的文本.该过滤
器方法在同一个 Org 文件的一个代码块结构中定义,这是一个方便调试的位置.
</p>
<pre class="example">
#+BIND: org-export-filter-timestamp-functions (tmp-f-timestamp)
#+BIND: org-export-filter-strike-through-functions (tmp-f-strike-through)
#+BEGIN_SRC emacs-lisp :exports results :results none
  (defun tmp-f-timestamp (s backend info)
    (replace-regexp-in-string "&amp;[lg]t;\\|[][]" "" s))
  (defun tmp-f-strike-through (s backend info) "")
#+END_SRC
</pre>

<p>
<b>扩展已有后端</b>
转换过程的某些部分可以针对某些元素扩展,以便引入新的或修订的转变.这就是 HTML 导出
后端如何扩展成处理 Markdown 格式的.该扩展可以无缝地工作,因此未由扩展的后端完成的
过滤的任何方面都由原始后端处理.在 Org 的所有导出自定义中,扩展是一个非常强大的功
能,因为它在解析器级别进行操作.
</p>

<p>
在下面例子中,使 ascii 后端显示源代码块中使用的语言.还使其仅在某些属性为非 <code>nil</code> 时
显示,就像这样:
</p>
<pre class="example">
#+ATTR_ASCII: :language t
</pre>
<p>
然后使用自定义的 "my-ascii" 后端扩展 ASCII 后端:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">my-ascii-src-block</span> (src-block contents info)
  <span style="font-style: italic;">"Transcode a SRC-BLOCK element from Org to ASCII.</span>
<span style="font-style: italic;">CONTENTS is nil.  INFO is a plist used as a communication</span>
<span style="font-style: italic;">channel."</span>
  (<span style="font-weight: bold;">if</span> (not (org-export-read-attribute <span style="font-weight: bold;">:attr_ascii</span> src-block <span style="font-weight: bold;">:language</span>))
      (org-export-with-backend 'ascii src-block contents info)
    (concat
     (format <span style="font-style: italic;">",--[ %s ]--\n%s`----"</span>
             (org-element-property <span style="font-weight: bold;">:language</span> src-block)
             (replace-regexp-in-string
              <span style="font-style: italic;">"^"</span> <span style="font-style: italic;">"| "</span>
              (org-element-normalize-string
               (org-export-format-code-default src-block info)))))))

(org-export-define-derived-backend 'my-ascii 'ascii
  <span style="font-weight: bold;">:translate-alist</span> '((src-block . my-ascii-src-block)))
</pre>
</div>

<p>
<code>my-ascii-src-block</code> 方法查看当前元素上的属性.如果非 true, 则交给 <span class="underline">ascii</span> 后端.如果
为 true, 也就是像上面例子里一样,该方法在代码周围创建一个框并为插入语言字符串留出
空间.最后的表单创建一个新的后端,该后端仅在转换 <code>src-block</code> 类型的元素时才会启动.
</p>

<p>
要使用新定义的后端,请在 Org 缓冲区里执行下面代码:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(org-export-to-buffer 'my-ascii <span style="font-style: italic;">"*Org MY-ASCII Export*"</span>)
</pre>
</div>
<p>
需要考虑的进一步步骤包括交互式功能,在导出调度器菜单中自行安装项目以及其他用户友
好的改进.
</p>
</div>
</div>

<div id="outline-container-org5b09c35" class="outline-3">
<h3 id="org5b09c35"><span class="todo TODO">TODO</span> 在外部缓冲区导出(Export in Foreign Buffers)</h3>
<div class="outline-text-3" id="text-org5b09c35">
<p>
用 Org 语法创作表格和列表.
</p>
</div>
</div>
</div>

<div id="outline-container-org9d02e1d" class="outline-2">
<h2 id="org9d02e1d"><span class="done DONE">DONE</span> 发布(Publishing)</h2>
<div class="outline-text-2" id="text-org9d02e1d">
<p>
Org 包括一个发布管理系统,能允许你配置由相互链接的 Org 文件组成的项目的自动 HTML
转换过程.您还可以将 Org 配置成自动将导出的 HTML 页面和相关附件(如图片和源代码文
件)上传到服务器.
</p>

<p>
你也可以将文件转换成 PDF ,甚至可以将 HTML 和 PDF 转换结合起来,以便在服务器上以两
种格式提供文件.
</p>

<p>
发布功能由 David O'Toole 贡献到 Org.
</p>
</div>

<div id="outline-container-org723ab4c" class="outline-3">
<h3 id="org723ab4c"><span class="done DONE">DONE</span> 配置(Configuration)</h3>
<div class="outline-text-3" id="text-org723ab4c">
<p>
定义项目.
</p>

<p>
发布需要众多配置来指定项目的文件,发布位置和许多其他属性.
</p>
</div>

<div id="outline-container-org769bf85" class="outline-4">
<h4 id="org769bf85"><span class="done DONE">DONE</span> 项目关联列表(Project alist)</h4>
<div class="outline-text-4" id="text-org769bf85">
<p>
中心配置变量.
</p>

<p>
变量 <code>org-bublish-project-alist</code>
</p>

<p>
发布过程几乎完全通过一个叫 <code>org-publish-project-alist</code> 的变量来设置.该列表的每个元
素配置一个项目,可使用下面两种形式之一:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-style: italic;">"project-name"</span> <span style="font-weight: bold;">:property</span> value <span style="font-weight: bold;">:property</span> value ...)
</pre>
</div>
<p>
即一个带交替键值的格式良好的属性列表.
或者是:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-style: italic;">"project-name"</span> <span style="font-weight: bold;">:components</span> (<span style="font-style: italic;">"project-name"</span> <span style="font-style: italic;">"project-name"</span> ...))
</pre>
</div>
<p>
这两种情况下,项目都是通过指定属性值来配置的.一个项目定义了要发布的文件集合,也定
义了当发布这些文件时使用的发布配置.当一个项目使用上面列出的第二种表单配置时,
<code>:components</code> 属性的单个成员被当作是一个子项目,这些子项目将需要不同发布选项的文件
组合在一起. 当你发布这样一个 "元项目(meta-project)" 时,所有序列里给定的组件也会
被一起发布
</p>
</div>
</div>



<div id="outline-container-org9560217" class="outline-4">
<h4 id="org9560217"><span class="done DONE">DONE</span> 来源和目的地(Sources and destinations)</h4>
<div class="outline-text-4" id="text-org9560217">
<p>
从这里到那里.
</p>

<p>
大多数属性是可选的,但是有一些是必须要设置的.特别是,Org 需要知道在哪里查找源文件,
以及在哪里放置已发布的文件.
</p>

<dl class="org-dl">
<dt><code>:base-directory</code></dt><dd>包含有发布源文件的目录.</dd>
<dt><code>:publishing-directory</code></dt><dd>发布输出文件的目录.你可以使用使用与 Emacs tramp 包的
文件名语法直接发布到Web 服务器.或者,你可以发布到本地目录,并使用外部工具上传到
你的网站上(参见 <a href="#orgfab865e">上传文件(Uploading Files)</a>).</dd>
<dt><code>:preparation-function</code></dt><dd>在开始发布程序之前调用的方法或方法列表.例如, 在发布之
前运行 <code>make</code> 来更新要发布的文件. 每一个准备(preparation)方法都带一个参数调用,即
项目的属性列表.</dd>
<dt><code>:completion-function</code></dt><dd>在发布程序完成之后调用的方法或方法列表.例如,要修改结果
文件的权限.每个完成(completion)方法都带有一个参数调用,即项目的属性列表.</dd>
</dl>
</div>
</div>
<div id="outline-container-org4f23154" class="outline-4">
<h4 id="org4f23154"><span class="done DONE">DONE</span> 选择文件(Selecting files)</h4>
<div class="outline-text-4" id="text-org4f23154">
<p>
什么文件是项目的一部分?
</p>

<p>
默认情况下,在源文件目录(base-directory)里所有带 <code>.org</code> 扩展的文件都被视为项目的一
部分.这个可以通过设置下面的属性来修改:
</p>
<dl class="org-dl">
<dt><code>:base-extension</code></dt><dd>源文件不带点号的扩展名.这个实际上是一个正则表达式.如果你想
要 <code>:base-directory</code> 里的所有文件(即使没有扩展名),请将这个属性设置为标志 <code>any</code>.</dd>
<dt><code>:exclude</code></dt><dd>匹配不应该被发布的文件名的正则表达式,即使他们根据扩展名会被选择.</dd>
<dt><code>:include</code></dt><dd>要包括的文件,不管 <code>:base-extension</code> 和 <code>:exclude</code> 的设置如何.</dd>
<dt><code>:recursive</code></dt><dd>非 <code>nil</code> 意味着递归检查 base-directory 目录中要发布的文件.</dd>
</dl>
</div>
</div>
<div id="outline-container-orgce8f22d" class="outline-4">
<h4 id="orgce8f22d"><span class="done DONE">DONE</span> 发布行为(Publishing action)</h4>
<div class="outline-text-4" id="text-orgce8f22d">
<p>
设置执行发布的函数.
</p>

<p>
发布意味着一个文件被复制到目标目录,并可能在此过程中进行转换.默认的转换是将 Org
文件导出为 HTML 文件,这个过程是由 <code>org-html-publish-to-html</code> 方法完成的,该方法会调
用 HTML 导出器(参见<a href="#org7b70547">HTML 导出(HTML Export)</a>). 但是你也可以使用
<code>org-latex-publish-to-pdf</code> 将你的内容作为 PDF 文件发布,或者作为 ASCII, Texinfo 等
等,只需使用相对应的方法.
</p>

<p>
如果你想将 Org 文件作为一个 <code>.org</code> 文件发布,但是不包含 <span class="underline">存档</span>, <span class="underline">注释</span>, 和 <span class="underline">标签排除</span> 的
树, 请使用 <code>org-org-publish-to-org</code> 方法. 这会产生 <code>file.org</code> 文件,并将其放置到发布
目录.如果你想要这个文件的 HTML 化版本,请将 <code>:htmlized-source</code> 设置为 <code>t</code>. 这会在发布
目录里产生 <code>file.org.html</code> 文件<sup><a id="fnr.83" class="footref" href="#fn.83">83</a></sup>.
</p>

<p>
其他文件(例如图片)只需要被复制到发布目的地;为此,您可以使用
<code>org-publish-attachment</code>. 对于非 Org 文件,你总是需要指定发布方法:
</p>
<dl class="org-dl">
<dt><code>:publishing-function</code></dt><dd>执行一个文件的发布的方法.这也可能是一个方法的列表,所有
方法都依次调用.</dd>
<dt><code>:htmlized-source</code></dt><dd><p>
非 <code>nil</code> 意味着发布 HTML 化的源.
</p>

<p>
这些方法必须接受三个参数:一个属性列表,至少包含一个 <code>:publishing-directory</code> 属性;
要发布的文件名;和输出文件的发布目录的路径.它应该接受指定的文件,进行必要的转换
(如果有),并将结果放入到目标文件夹.
</p></dd>
</dl>
</div>
</div>
<div id="outline-container-orga56d6ff" class="outline-4">
<h4 id="orga56d6ff"><span class="done DONE">DONE</span> 发布选项(Publishing options)</h4>
<div class="outline-text-4" id="text-orga56d6ff">
<p>
调整 HTML/LaTex 导出.
</p>

<p>
属性列表可用于为 HTML 和 LaTex 导出器设置许多导出选项.大多数情况下,这些属性和
Org 里的用户变量像对应.下面的表格列出了这些属性和他们属于的变量.更多细节请查看鸽
子变量的文档字符串.
</p>

<p>
当一个属性在 <code>org-publish-project-alist</code> 里给定了值时,在导出期间它的设置会覆盖相应
的用户变量的值(如果有). 然而,文件里的设置(参见<a href="#org53ffc01">导出设置(Export Settings)</a>), 会覆
盖所有其他设置.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 3:</span> 通用属性</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">‘:archived-trees’</td>
<td class="org-left">‘org-export-with-archived-trees’</td>
</tr>

<tr>
<td class="org-left">‘:exclude-tags’</td>
<td class="org-left">‘org-export-exclude-tags’</td>
</tr>

<tr>
<td class="org-left">‘:headline-levels’</td>
<td class="org-left">‘org-export-headline-levels’</td>
</tr>

<tr>
<td class="org-left">‘:language’</td>
<td class="org-left">‘org-export-default-language’</td>
</tr>

<tr>
<td class="org-left">‘:preserve-breaks’</td>
<td class="org-left">‘org-export-preserve-breaks’</td>
</tr>

<tr>
<td class="org-left">‘:section-numbers’</td>
<td class="org-left">‘org-export-with-section-numbers’</td>
</tr>

<tr>
<td class="org-left">‘:select-tags’</td>
<td class="org-left">‘org-export-select-tags’</td>
</tr>

<tr>
<td class="org-left">‘:with-author’</td>
<td class="org-left">‘org-export-with-author’</td>
</tr>

<tr>
<td class="org-left">‘:with-broken-links’</td>
<td class="org-left">‘org-export-with-broken-links’</td>
</tr>

<tr>
<td class="org-left">‘:with-clocks’</td>
<td class="org-left">‘org-export-with-clocks’</td>
</tr>

<tr>
<td class="org-left">‘:with-creator’</td>
<td class="org-left">‘org-export-with-creator’</td>
</tr>

<tr>
<td class="org-left">‘:with-date’</td>
<td class="org-left">‘org-export-with-date’</td>
</tr>

<tr>
<td class="org-left">‘:with-drawers’</td>
<td class="org-left">‘org-export-with-drawers’</td>
</tr>

<tr>
<td class="org-left">‘:with-email’</td>
<td class="org-left">‘org-export-with-email’</td>
</tr>

<tr>
<td class="org-left">‘:with-emphasize’</td>
<td class="org-left">‘org-export-with-emphasize’</td>
</tr>

<tr>
<td class="org-left">‘:with-fixed-width’</td>
<td class="org-left">‘org-export-with-fixed-width’</td>
</tr>

<tr>
<td class="org-left">‘:with-footnotes’</td>
<td class="org-left">‘org-export-with-footnotes’</td>
</tr>

<tr>
<td class="org-left">‘:with-latex’</td>
<td class="org-left">‘org-export-with-latex’</td>
</tr>

<tr>
<td class="org-left">‘:with-planning’</td>
<td class="org-left">‘org-export-with-planning’</td>
</tr>

<tr>
<td class="org-left">‘:with-priority’</td>
<td class="org-left">‘org-export-with-priority’</td>
</tr>

<tr>
<td class="org-left">‘:with-properties’</td>
<td class="org-left">‘org-export-with-properties’</td>
</tr>

<tr>
<td class="org-left">‘:with-special-strings’</td>
<td class="org-left">‘org-export-with-special-strings’</td>
</tr>

<tr>
<td class="org-left">‘:with-sub-superscript’</td>
<td class="org-left">‘org-export-with-sub-superscripts’</td>
</tr>

<tr>
<td class="org-left">‘:with-tables’</td>
<td class="org-left">‘org-export-with-tables’</td>
</tr>

<tr>
<td class="org-left">‘:with-tags’</td>
<td class="org-left">‘org-export-with-tags’</td>
</tr>

<tr>
<td class="org-left">‘:with-tasks’</td>
<td class="org-left">‘org-export-with-tasks’</td>
</tr>

<tr>
<td class="org-left">‘:with-timestamps’</td>
<td class="org-left">‘org-export-with-timestamps’</td>
</tr>

<tr>
<td class="org-left">‘:with-title’</td>
<td class="org-left">‘org-export-with-title’</td>
</tr>

<tr>
<td class="org-left">‘:with-toc’</td>
<td class="org-left">‘org-export-with-toc’</td>
</tr>

<tr>
<td class="org-left">‘:with-todo-keywords’</td>
<td class="org-left">‘org-export-with-todo-keywords’</td>
</tr>
</tbody>
</table>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 4:</span> ASCII specific properties</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">‘:ascii-bullets’</td>
<td class="org-left">‘org-ascii-bullets’</td>
</tr>

<tr>
<td class="org-left">‘:ascii-caption-above’</td>
<td class="org-left">‘org-ascii-caption-above’</td>
</tr>

<tr>
<td class="org-left">‘:ascii-charset’</td>
<td class="org-left">‘org-ascii-charset’</td>
</tr>

<tr>
<td class="org-left">‘:ascii-global-margin’</td>
<td class="org-left">‘org-ascii-global-margin’</td>
</tr>

<tr>
<td class="org-left">‘:ascii-format-drawer-function’</td>
<td class="org-left">‘org-ascii-format-drawer-function’</td>
</tr>

<tr>
<td class="org-left">‘:ascii-format-inlinetask-function’</td>
<td class="org-left">‘org-ascii-format-inlinetask-function’</td>
</tr>

<tr>
<td class="org-left">‘:ascii-headline-spacing’</td>
<td class="org-left">‘org-ascii-headline-spacing’</td>
</tr>

<tr>
<td class="org-left">‘:ascii-indented-line-width’</td>
<td class="org-left">‘org-ascii-indented-line-width’</td>
</tr>

<tr>
<td class="org-left">‘:ascii-inlinetask-width’</td>
<td class="org-left">‘org-ascii-inlinetask-width’</td>
</tr>

<tr>
<td class="org-left">‘:ascii-inner-margin’</td>
<td class="org-left">‘org-ascii-inner-margin’</td>
</tr>

<tr>
<td class="org-left">‘:ascii-links-to-notes’</td>
<td class="org-left">‘org-ascii-links-to-notes’</td>
</tr>

<tr>
<td class="org-left">‘:ascii-list-margin’</td>
<td class="org-left">‘org-ascii-list-margin’</td>
</tr>

<tr>
<td class="org-left">‘:ascii-paragraph-spacing’</td>
<td class="org-left">‘org-ascii-paragraph-spacing’</td>
</tr>

<tr>
<td class="org-left">‘:ascii-quote-margin’</td>
<td class="org-left">‘org-ascii-quote-margin’</td>
</tr>

<tr>
<td class="org-left">‘:ascii-table-keep-all-vertical-lines’</td>
<td class="org-left">‘org-ascii-table-keep-all-vertical-lines’</td>
</tr>

<tr>
<td class="org-left">‘:ascii-table-use-ascii-art’</td>
<td class="org-left">‘org-ascii-table-use-ascii-art’</td>
</tr>

<tr>
<td class="org-left">‘:ascii-table-widen-columns’</td>
<td class="org-left">‘org-ascii-table-widen-columns’</td>
</tr>

<tr>
<td class="org-left">‘:ascii-text-width’</td>
<td class="org-left">‘org-ascii-text-width’</td>
</tr>

<tr>
<td class="org-left">‘:ascii-underline’</td>
<td class="org-left">‘org-ascii-underline’</td>
</tr>

<tr>
<td class="org-left">‘:ascii-verbatim-format’</td>
<td class="org-left">‘org-ascii-verbatim-format’</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">‘:beamer-theme’</td>
<td class="org-left">‘org-beamer-theme’</td>
</tr>

<tr>
<td class="org-left">‘:beamer-column-view-format’</td>
<td class="org-left">‘org-beamer-column-view-format’</td>
</tr>

<tr>
<td class="org-left">‘:beamer-environments-extra’</td>
<td class="org-left">‘org-beamer-environments-extra’</td>
</tr>

<tr>
<td class="org-left">‘:beamer-frame-default-options’</td>
<td class="org-left">‘org-beamer-frame-default-options’</td>
</tr>

<tr>
<td class="org-left">‘:beamer-outline-frame-options’</td>
<td class="org-left">‘org-beamer-outline-frame-options’</td>
</tr>

<tr>
<td class="org-left">‘:beamer-outline-frame-title’</td>
<td class="org-left">‘org-beamer-outline-frame-title’</td>
</tr>

<tr>
<td class="org-left">‘:beamer-subtitle-format’</td>
<td class="org-left">‘org-beamer-subtitle-format’</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">‘:html-allow-name-attribute-in-anchors’</td>
<td class="org-left">‘org-html-allow-name-attribute-in-anchors’</td>
</tr>

<tr>
<td class="org-left">‘:html-checkbox-type’</td>
<td class="org-left">‘org-html-checkbox-type’</td>
</tr>

<tr>
<td class="org-left">‘:html-container’</td>
<td class="org-left">‘org-html-container-element’</td>
</tr>

<tr>
<td class="org-left">‘:html-divs’</td>
<td class="org-left">‘org-html-divs’</td>
</tr>

<tr>
<td class="org-left">‘:html-doctype’</td>
<td class="org-left">‘org-html-doctype’</td>
</tr>

<tr>
<td class="org-left">‘:html-extension’</td>
<td class="org-left">‘org-html-extension’</td>
</tr>

<tr>
<td class="org-left">‘:html-footnote-format’</td>
<td class="org-left">‘org-html-footnote-format’</td>
</tr>

<tr>
<td class="org-left">‘:html-footnote-separator’</td>
<td class="org-left">‘org-html-footnote-separator’</td>
</tr>

<tr>
<td class="org-left">‘:html-footnotes-section’</td>
<td class="org-left">‘org-html-footnotes-section’</td>
</tr>

<tr>
<td class="org-left">‘:html-format-drawer-function’</td>
<td class="org-left">‘org-html-format-drawer-function’</td>
</tr>

<tr>
<td class="org-left">‘:html-format-headline-function’</td>
<td class="org-left">‘org-html-format-headline-function’</td>
</tr>

<tr>
<td class="org-left">‘:html-format-inlinetask-function’</td>
<td class="org-left">‘org-html-format-inlinetask-function’</td>
</tr>

<tr>
<td class="org-left">‘:html-head-extra’</td>
<td class="org-left">‘org-html-head-extra’</td>
</tr>

<tr>
<td class="org-left">‘:html-head-include-default-style’</td>
<td class="org-left">‘org-html-head-include-default-style’</td>
</tr>

<tr>
<td class="org-left">‘:html-head-include-scripts’</td>
<td class="org-left">‘org-html-head-include-scripts’</td>
</tr>

<tr>
<td class="org-left">‘:html-head’</td>
<td class="org-left">‘org-html-head’</td>
</tr>

<tr>
<td class="org-left">‘:html-home/up-format’</td>
<td class="org-left">‘org-html-home/up-format’</td>
</tr>

<tr>
<td class="org-left">‘:html-html5-fancy’</td>
<td class="org-left">‘org-html-html5-fancy’</td>
</tr>

<tr>
<td class="org-left">‘:html-indent’</td>
<td class="org-left">‘org-html-indent’</td>
</tr>

<tr>
<td class="org-left">‘:html-infojs-options’</td>
<td class="org-left">‘org-html-infojs-options’</td>
</tr>

<tr>
<td class="org-left">‘:html-infojs-template’</td>
<td class="org-left">‘org-html-infojs-template’</td>
</tr>

<tr>
<td class="org-left">‘:html-inline-image-rules’</td>
<td class="org-left">‘org-html-inline-image-rules’</td>
</tr>

<tr>
<td class="org-left">‘:html-inline-images’</td>
<td class="org-left">‘org-html-inline-images’</td>
</tr>

<tr>
<td class="org-left">‘:html-link-home’</td>
<td class="org-left">‘org-html-link-home’</td>
</tr>

<tr>
<td class="org-left">‘:html-link-org-files-as-html’</td>
<td class="org-left">‘org-html-link-org-files-as-html’</td>
</tr>

<tr>
<td class="org-left">‘:html-link-up’</td>
<td class="org-left">‘org-html-link-up’</td>
</tr>

<tr>
<td class="org-left">‘:html-link-use-abs-url’</td>
<td class="org-left">‘org-html-link-use-abs-url’</td>
</tr>

<tr>
<td class="org-left">‘:html-mathjax-options’</td>
<td class="org-left">‘org-html-mathjax-options’</td>
</tr>

<tr>
<td class="org-left">‘:html-mathjax-template’</td>
<td class="org-left">‘org-html-mathjax-template’</td>
</tr>

<tr>
<td class="org-left">‘:html-equation-reference-format’</td>
<td class="org-left">‘org-html-equation-reference-format’</td>
</tr>

<tr>
<td class="org-left">‘:html-metadata-timestamp-format’</td>
<td class="org-left">‘org-html-metadata-timestamp-format’</td>
</tr>

<tr>
<td class="org-left">‘:html-postamble-format’</td>
<td class="org-left">‘org-html-postamble-format’</td>
</tr>

<tr>
<td class="org-left">‘:html-postamble’</td>
<td class="org-left">‘org-html-postamble’</td>
</tr>

<tr>
<td class="org-left">‘:html-preamble-format’</td>
<td class="org-left">‘org-html-preamble-format’</td>
</tr>

<tr>
<td class="org-left">‘:html-preamble’</td>
<td class="org-left">‘org-html-preamble’</td>
</tr>

<tr>
<td class="org-left">‘:html-self-link-headlines’</td>
<td class="org-left">‘org-html-self-link-headlines’</td>
</tr>

<tr>
<td class="org-left">‘:html-table-align-individual-field’</td>
<td class="org-left">‘de{org-html-table-align-individual-fields’</td>
</tr>

<tr>
<td class="org-left">‘:html-table-attributes’</td>
<td class="org-left">‘org-html-table-default-attributes’</td>
</tr>

<tr>
<td class="org-left">‘:html-table-caption-above’</td>
<td class="org-left">‘org-html-table-caption-above’</td>
</tr>

<tr>
<td class="org-left">‘:html-table-data-tags’</td>
<td class="org-left">‘org-html-table-data-tags’</td>
</tr>

<tr>
<td class="org-left">‘:html-table-header-tags’</td>
<td class="org-left">‘org-html-table-header-tags’</td>
</tr>

<tr>
<td class="org-left">‘:html-table-row-tags’</td>
<td class="org-left">‘org-html-table-row-tags’</td>
</tr>

<tr>
<td class="org-left">‘:html-table-use-header-tags-for-first-column’</td>
<td class="org-left">‘org-html-table-use-header-tags-for-first-column’</td>
</tr>

<tr>
<td class="org-left">‘:html-tag-class-prefix’</td>
<td class="org-left">‘org-html-tag-class-prefix’</td>
</tr>

<tr>
<td class="org-left">‘:html-text-markup-alist’</td>
<td class="org-left">‘org-html-text-markup-alist’</td>
</tr>

<tr>
<td class="org-left">‘:html-todo-kwd-class-prefix’</td>
<td class="org-left">‘org-html-todo-kwd-class-prefix’</td>
</tr>

<tr>
<td class="org-left">‘:html-toplevel-hlevel’</td>
<td class="org-left">‘org-html-toplevel-hlevel’</td>
</tr>

<tr>
<td class="org-left">‘:html-use-infojs’</td>
<td class="org-left">‘org-html-use-infojs’</td>
</tr>

<tr>
<td class="org-left">‘:html-validation-link’</td>
<td class="org-left">‘org-html-validation-link’</td>
</tr>

<tr>
<td class="org-left">‘:html-viewport’</td>
<td class="org-left">‘org-html-viewport’</td>
</tr>

<tr>
<td class="org-left">‘:html-wrap-src-lines’</td>
<td class="org-left">‘org-html-wrap-src-lines’</td>
</tr>

<tr>
<td class="org-left">‘:html-xml-declaration’</td>
<td class="org-left">‘org-html-xml-declaration’</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">‘:latex-active-timestamp-format’</td>
<td class="org-left">‘org-latex-active-timestamp-format’</td>
</tr>

<tr>
<td class="org-left">‘:latex-caption-above’</td>
<td class="org-left">‘org-latex-caption-above’</td>
</tr>

<tr>
<td class="org-left">‘:latex-classes’</td>
<td class="org-left">‘org-latex-classes’</td>
</tr>

<tr>
<td class="org-left">‘:latex-class’</td>
<td class="org-left">‘org-latex-default-class’</td>
</tr>

<tr>
<td class="org-left">‘:latex-compiler’</td>
<td class="org-left">‘org-latex-compiler’</td>
</tr>

<tr>
<td class="org-left">‘:latex-default-figure-position’</td>
<td class="org-left">‘org-latex-default-figure-position’</td>
</tr>

<tr>
<td class="org-left">‘:latex-default-table-environment’</td>
<td class="org-left">‘org-latex-default-table-environment’</td>
</tr>

<tr>
<td class="org-left">‘:latex-default-table-mode’</td>
<td class="org-left">‘org-latex-default-table-mode’</td>
</tr>

<tr>
<td class="org-left">‘:latex-diary-timestamp-format’</td>
<td class="org-left">‘org-latex-diary-timestamp-format’</td>
</tr>

<tr>
<td class="org-left">‘:latex-footnote-defined-format’</td>
<td class="org-left">‘org-latex-footnote-defined-format’</td>
</tr>

<tr>
<td class="org-left">‘:latex-footnote-separator’</td>
<td class="org-left">‘org-latex-footnote-separator’</td>
</tr>

<tr>
<td class="org-left">‘:latex-format-drawer-function’</td>
<td class="org-left">‘org-latex-format-drawer-function’</td>
</tr>

<tr>
<td class="org-left">‘:latex-format-headline-function’</td>
<td class="org-left">‘org-latex-format-headline-function’</td>
</tr>

<tr>
<td class="org-left">‘:latex-format-inlinetask-function’</td>
<td class="org-left">‘org-latex-format-inlinetask-function’</td>
</tr>

<tr>
<td class="org-left">‘:latex-hyperref-template’</td>
<td class="org-left">‘org-latex-hyperref-template’</td>
</tr>

<tr>
<td class="org-left">‘:latex-image-default-height’</td>
<td class="org-left">‘org-latex-image-default-height’</td>
</tr>

<tr>
<td class="org-left">‘:latex-image-default-option’</td>
<td class="org-left">‘org-latex-image-default-option’</td>
</tr>

<tr>
<td class="org-left">‘:latex-image-default-width’</td>
<td class="org-left">‘org-latex-image-default-width’</td>
</tr>

<tr>
<td class="org-left">‘:latex-images-centered’</td>
<td class="org-left">‘org-latex-images-centered’</td>
</tr>

<tr>
<td class="org-left">‘:latex-inactive-timestamp-format’</td>
<td class="org-left">‘org-latex-inactive-timestamp-format’</td>
</tr>

<tr>
<td class="org-left">‘:latex-inline-image-rules’</td>
<td class="org-left">‘org-latex-inline-image-rules’</td>
</tr>

<tr>
<td class="org-left">‘:latex-link-with-unknown-path-format’</td>
<td class="org-left">‘org-latex-link-with-unknown-path-format’</td>
</tr>

<tr>
<td class="org-left">‘:latex-listings-langs’</td>
<td class="org-left">‘org-latex-listings-langs’</td>
</tr>

<tr>
<td class="org-left">‘:latex-listings-options’</td>
<td class="org-left">‘org-latex-listings-options’</td>
</tr>

<tr>
<td class="org-left">‘:latex-listings’</td>
<td class="org-left">‘org-latex-listings’</td>
</tr>

<tr>
<td class="org-left">‘:latex-minted-langs’</td>
<td class="org-left">‘org-latex-minted-langs’</td>
</tr>

<tr>
<td class="org-left">‘:latex-minted-options’</td>
<td class="org-left">‘org-latex-minted-options’</td>
</tr>

<tr>
<td class="org-left">‘:latex-prefer-user-labels’</td>
<td class="org-left">‘org-latex-prefer-user-labels’</td>
</tr>

<tr>
<td class="org-left">‘:latex-subtitle-format’</td>
<td class="org-left">‘org-latex-subtitle-format’</td>
</tr>

<tr>
<td class="org-left">‘:latex-subtitle-separate’</td>
<td class="org-left">‘org-latex-subtitle-separate’</td>
</tr>

<tr>
<td class="org-left">‘:latex-table-scientific-notation’</td>
<td class="org-left">‘org-latex-table-scientific-notation’</td>
</tr>

<tr>
<td class="org-left">‘:latex-tables-booktabs’</td>
<td class="org-left">‘org-latex-tables-booktabs’</td>
</tr>

<tr>
<td class="org-left">‘:latex-tables-centered’</td>
<td class="org-left">‘org-latex-tables-centered’</td>
</tr>

<tr>
<td class="org-left">‘:latex-text-markup-alist’</td>
<td class="org-left">‘org-latex-text-markup-alist’</td>
</tr>

<tr>
<td class="org-left">‘:latex-title-command’</td>
<td class="org-left">‘org-latex-title-command’</td>
</tr>

<tr>
<td class="org-left">‘:latex-toc-command’</td>
<td class="org-left">‘org-latex-toc-command’</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 5:</span> Markdown specific properties</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">‘:md-footnote-format’</td>
<td class="org-left">‘org-md-footnote-format’</td>
</tr>

<tr>
<td class="org-left">‘:md-footnotes-section’</td>
<td class="org-left">‘org-md-footnotes-section’</td>
</tr>

<tr>
<td class="org-left">‘:md-headline-style’</td>
<td class="org-left">‘org-md-headline-style’</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">‘:odt-content-template-file’</td>
<td class="org-left">‘org-odt-content-template-file’</td>
</tr>

<tr>
<td class="org-left">‘:odt-display-outline-level’</td>
<td class="org-left">‘org-odt-display-outline-level’</td>
</tr>

<tr>
<td class="org-left">‘:odt-fontify-srcblocks’</td>
<td class="org-left">‘org-odt-fontify-srcblocks’</td>
</tr>

<tr>
<td class="org-left">‘:odt-format-drawer-function’</td>
<td class="org-left">‘org-odt-format-drawer-function’</td>
</tr>

<tr>
<td class="org-left">‘:odt-format-headline-function’</td>
<td class="org-left">‘org-odt-format-headline-function’</td>
</tr>

<tr>
<td class="org-left">‘:odt-format-inlinetask-function’</td>
<td class="org-left">‘org-odt-format-inlinetask-function’</td>
</tr>

<tr>
<td class="org-left">‘:odt-inline-formula-rules’</td>
<td class="org-left">‘org-odt-inline-formula-rules’</td>
</tr>

<tr>
<td class="org-left">‘:odt-inline-image-rules’</td>
<td class="org-left">‘org-odt-inline-image-rules’</td>
</tr>

<tr>
<td class="org-left">‘:odt-pixels-per-inch’</td>
<td class="org-left">‘org-odt-pixels-per-inch’</td>
</tr>

<tr>
<td class="org-left">‘:odt-styles-file’</td>
<td class="org-left">‘org-odt-styles-file’</td>
</tr>

<tr>
<td class="org-left">‘:odt-table-styles’</td>
<td class="org-left">‘org-odt-table-styles’</td>
</tr>

<tr>
<td class="org-left">‘:odt-use-date-fields’</td>
<td class="org-left">‘org-odt-use-date-fields’</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">‘:texinfo-active-timestamp-format’</td>
<td class="org-left">‘org-texinfo-active-timestamp-format’</td>
</tr>

<tr>
<td class="org-left">‘:texinfo-classes’</td>
<td class="org-left">‘org-texinfo-classes’</td>
</tr>

<tr>
<td class="org-left">‘:texinfo-class’</td>
<td class="org-left">‘org-texinfo-default-class’</td>
</tr>

<tr>
<td class="org-left">‘:texinfo-table-default-markup’</td>
<td class="org-left">‘org-texinfo-table-default-markup’</td>
</tr>

<tr>
<td class="org-left">‘:texinfo-diary-timestamp-format’</td>
<td class="org-left">‘org-texinfo-diary-timestamp-format’</td>
</tr>

<tr>
<td class="org-left">‘:texinfo-filename’</td>
<td class="org-left">‘org-texinfo-filename’</td>
</tr>

<tr>
<td class="org-left">‘:texinfo-format-drawer-function’</td>
<td class="org-left">‘org-texinfo-format-drawer-function’</td>
</tr>

<tr>
<td class="org-left">‘:texinfo-format-headline-function’</td>
<td class="org-left">‘org-texinfo-format-headline-function’</td>
</tr>

<tr>
<td class="org-left">‘:texinfo-format-inlinetask-function’</td>
<td class="org-left">‘org-texinfo-format-inlinetask-function’</td>
</tr>

<tr>
<td class="org-left">‘:texinfo-inactive-timestamp-format’</td>
<td class="org-left">‘org-texinfo-inactive-timestamp-format’</td>
</tr>

<tr>
<td class="org-left">‘:texinfo-link-with-unknown-path-format’</td>
<td class="org-left">‘org-texinfo-link-with-unknown-path-format’</td>
</tr>

<tr>
<td class="org-left">‘:texinfo-node-description-column’</td>
<td class="org-left">‘org-texinfo-node-description-column’</td>
</tr>

<tr>
<td class="org-left">‘:texinfo-table-scientific-notation’</td>
<td class="org-left">‘org-texinfo-table-scientific-notation’</td>
</tr>

<tr>
<td class="org-left">‘:texinfo-tables-verbatim’</td>
<td class="org-left">‘org-texinfo-tables-verbatim’</td>
</tr>

<tr>
<td class="org-left">‘:texinfo-text-markup-alist’</td>
<td class="org-left">‘org-texinfo-text-markup-alist’</td>
</tr>
</tbody>
</table>
</div>
</div>





<div id="outline-container-org9acefd1" class="outline-4">
<h4 id="org9acefd1"><span class="done DONE">DONE</span> 发布链接(Publishing links)</h4>
<div class="outline-text-4" id="text-org9acefd1">
<p>
发布后哪些链接仍有效?
</p>

<p>
要创建一个要从一个 Org 文件到另一个的链接,你可以使用类似这样的:
<code>[[file:foo.org][The foo]]</code> 或者简单使用这样的: <code>[[file:foo.org]]</code> (参见
<a href="#orgf0a99bf">外部链接(External Links)</a>). 当发布时,这个链接变成一个 <code>foo.html</code> 的链接.因此,您可
以链接 "Org Web" 项目的页面,当您将其发布为 HTML 时,这些链接将按预期工作.如果你也
发布 Org 源文件,并且想要链接到它,请使用 <code>http</code> 链接而不是 <code>file:</code> 链接,因为 <code>file</code> 链
接会转变为链接到相应的 <code>.html</code> 文件.
</p>

<p>
你也可以链接到相关文件,如图像.如果你小心使用相对文件名,并且还将 Org 配置为上传这
些相关文件,这些链接也会起作用.这种用法的一个例子请查看<a href="#org95e82f3">复杂的例子(Complex Example)</a>.
</p>

<p>
最后,已发布的文档之间的链接可以包括一些搜索选项(参见<a href="#orgc4a851d">搜索选项(Search Options)</a>),
这些选项将被接卸到链接文件中的合适位置.例如,一旦发布到 HTML ,下面的链接全都指向
<code>foo.html</code> 文件中一个专用锚点.
</p>
<pre class="example">
[[file:foo.org::*heading]]
[[file:foo.org::#custom-id]]
[[file:foo.org::target]]
</pre>
</div>
</div>

<div id="outline-container-orga850101" class="outline-4">
<h4 id="orga850101"><span class="done DONE">DONE</span> 站点地图(Site map)</h4>
<div class="outline-text-4" id="text-orga850101">
<p>
生成一个所有页面的列表.
</p>

<p>
下面的属性可以用来控制给定项目文件的地图的发布.
</p>

<dl class="org-dl">
<dt><code>:auto-sitemap</code></dt><dd>当非 <code>nil</code> 时,在 <code>org-publish-current-project</code> 或 <code>org-publish-all</code>
期间发布一个站点地图.</dd>
<dt><code>:sitemap-filename</code></dt><dd>站点地图输出的文件名.默认为 <code>sitemap.org</code> 会发布为 <code>sitemap.html</code>.</dd>
<dt><code>:sitemap-title</code></dt><dd>站点地图页面的标题.默认为文件名.</dd>
<dt><code>:sitemap-format-entry</code></dt><dd>使用此选项,可以知道站点地图条目在站点地图里的格式.这
是一个带三个参数调用的方法:相对于项目的 base 目录的文件或目录名,站点地图格式和
当前项目.该方法应该返回一个字符串.默认将文件名转换为链接,并使用文档标题作为
描述.对于特殊的格式需要,你可以使用 <code>org-publish-find-date</code>,
<code>org-publish-find-title</code> 和 <code>org-publish-find-property</code> ,来从发布的文档里获取额外
的信息.</dd>
<dt><code>:sitemap-function</code></dt><dd>用于生成站点地图的插件函数.它带两个参数调用:站点地图的标
题和项目中涉及的文件和目录的嵌套列表表示,可以使用 <code>org-list-to-generic</code>,
<code>org-list-to-subtree</code> 等进一步转换.默认是生成一个指向项目中所有文件的链接的简单列表.</dd>
<dt><code>:sitemap-sort-folders</code></dt><dd>文件夹应该出现在站点地图里的位置.将该属性设置为
<code>first</code> (默认) 或 <code>last</code> 将文件夹分别首先或最后展示.当设置为 <code>ignore</code> 时,文件夹会被
完全忽略.当站点地图样式是 <code>tree</code> 时,该变量没有任何效果.</dd>
<dt><code>:sitemap-sort-files</code></dt><dd>站点地图里的文件是如何排序的. 将它设置为 <code>alphabetically</code>
(默认设置), <code>chronologically</code> 或者是 <code>anti-chronologically</code> . <code>chronologically</code> 会将
日期最旧的文件排在最前面, <code>anti-chronologically</code> 会将日期最新的文件排在最前
面. <code>alphabetically</code> 会按照字母顺序排序. 文件的日期是由 <code>org-publish-find-date</code> 函
数检索出来的.</dd>
<dt><code>:sitemap-ignore-case</code></dt><dd>排序是否区分大小写,默认为 <code>nil</code>, 不区分大小写.</dd>
<dt><code>:sitemap-file-entry-format</code></dt><dd>使用这个选项可以设置站点地图的条目在站点地图里是
如何格式化的. 这是一个带转义字符的格式字符串: <code>%t</code> 表示文件的标题, <code>%a</code> 表示文件的
作者, <code>%d</code> 表示文件的日期. 日期是由 <code>org-publish-find-date</code> 函数获取并由
<code>org-publish-sitemap-date-format</code> 函数格式化的. 默认的选项设置为 <code>%t</code>.</dd>
<dt><code>:sitemap-date-format</code></dt><dd><code>format-time-string</code> 函数的格式字符串, 它告诉站点地图条
目的日期如何被格式化. 该属性绕过默认为 <code>%Y-%m-%d</code> 的
<code>org-publish-sitemap-date-format</code> 设置.</dd>
</dl>
</div>
</div>
<div id="outline-container-org4d403f9" class="outline-4">
<h4 id="org4d403f9"><span class="done DONE">DONE</span> 生成索引(Generating an index)</h4>
<div class="outline-text-4" id="text-org4d403f9">
<p>
跨页索引.
</p>

<p>
Org mode 可以生成一个跨发布项目文件的索引.
</p>

<dl class="org-dl">
<dt><code>:makeindex</code></dt><dd><p>
当为非 <code>nil</code> 值时,在文件 <code>theindex.org</code> 里生成索引并将该文件发布为
<code>theindex.html</code> .
该文件在第一次设置了 <code>:makeindex</code> 选项并发布项目时被创建. 该文件只包含一个语句
<code>#+INCLUDE:"theindex.inc"</code> .然后你可以通过添加标题,样式信息等来围绕这个语句构建
该文件.
索引条目通过 <code>INDEX</code> 关键字指定.包含一个感叹号的条目会创建一个子项
</p>
<pre class="example">

*** Curriculum Vitae
#+INDEX: CV
#+INDEX: Application!CV

</pre></dd>
</dl>
</div>
</div>
</div>

<div id="outline-container-orgfab865e" class="outline-3">
<h3 id="orgfab865e"><span class="done DONE">DONE</span> 上传文件(Uploading Files)</h3>
<div class="outline-text-3" id="text-orgfab865e">
<p>
如何让文件到服务器上.
</p>

<p>
对于已经使用了第三方的同步工具,例如 Rsync 或者 Unison 的人来说,最好不要用Org
Mode 的内置远程发布工具,因为Org mode 严重依赖 Tramp. Tramp 尽管非常有用且功能强
大,但是对于多个文件传输来说往往效率不高,并且在大量使用时会导致问题.
</p>

<p>
专业的同步工具提供了几个优点.除了时间戳比较之外,他们还提供了内容和权限/属性检查.因
为这个原因,你可能更倾向于将你的网站发布到本地目录(甚至可能包含你的Org文件),然后
使用 Rsync 或 Unison 来与远程主机进行同步.
</p>

<p>
例如,由于 Unison 可以配置为将哪些文件传送到远程目标,因此它可以大大简化项目发布的
定义.只需要简单的将所有文件放置到正确位置,使用 <code>org-publish</code> 处理你的 Org 文件,然
后让同步工具完成剩下的工作.在这种情况下,你不需要在项目定义里包含附件,例如JPG,CSS
或者 PNG 文件,因为第三方工具会同步他们.
</p>

<p>
发布到一个本地目录也比发布到远程要快的多,因此你可以更轻松地重新发布整个项目. 如
果你将 <code>org-publish-use-timestamps-flag</code> 设置为 <code>nil</code> ,你可以获得重新包含任意外部文
件的益处,例如你可能会用 <code>INCLUDE</code> 关键字包含的源示例文件. Org 的时间戳机制没有智能
到会检测包含的文件是否被修改的程度.
</p>
</div>
</div>

<div id="outline-container-org5b63523" class="outline-3">
<h3 id="org5b63523"><span class="done DONE">DONE</span> 示例配置(Sample Configuration)</h3>
<div class="outline-text-3" id="text-org5b63523">
<p>
示例项目.
</p>

<p>
下面我们提供两个示例撇只.第一个是一个简单的项目只发布一系列Org 文件.第二个示例更
复杂,有多个组件项目.
</p>
</div>

<div id="outline-container-org8a38d68" class="outline-4">
<h4 id="org8a38d68">简单的例子(Simple example)</h4>
<div class="outline-text-4" id="text-org8a38d68">
<p>
这个例子将一系列 Org 文件发布到本地机器的 <code>public_html</code> 目录里.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">setq</span> org-publish-project-alist
      '((<span style="font-style: italic;">"org"</span>
         <span style="font-weight: bold;">:base-directory</span> <span style="font-style: italic;">"~/org/"</span>
         <span style="font-weight: bold;">:publishing-function</span> org-html-publish-to-html
         <span style="font-weight: bold;">:publishing-directory</span> <span style="font-style: italic;">"~/public_html"</span>
         <span style="font-weight: bold;">:section-numbers</span> nil
         <span style="font-weight: bold;">:with-toc</span> nil
         <span style="font-weight: bold;">:html-head</span> <span style="font-style: italic;">"&lt;link rel=\"stylesheet\"</span>
<span style="font-style: italic;">                         href=\"../other/mystyle.css\"</span>
<span style="font-style: italic;">                         type=\"text/css\"/&gt;"</span>)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org95e82f3" class="outline-4">
<h4 id="org95e82f3">复杂的例子(Complex Example)</h4>
<div class="outline-text-4" id="text-org95e82f3">
<p>
这个更复杂的示例发布整个网站,包括转换成HTML 的Org 文件,图片文件,Emacs Lisp 源代
码和样式表. 发布目录是远程目录,并且不包括私有文件.
</p>

<p>
为了确保链接被保留,在网站上复制你的目录结构时需要小心处理,并且应使用相对路径.例
如,如果你的Org 文件保存在 <code>~/org/</code> 目录下,你的图片在 <code>~/images/</code> 目录,你应该用下面的
形式链接到一个图片:
</p>
<pre class="example">
file:../images/myimage.png
</pre>

<p>
在网页服务器上,图片的相对路径应该相同.你可以通过将一个 <code>images/</code> 目录设置到网页服
务器上正确的位置,并将图片发布其中来实现这一点.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">
(<span style="font-weight: bold;">setq</span> org-publish-project-alist
      '((<span style="font-style: italic;">"orgfiles"</span>
         <span style="font-weight: bold;">:base-directory</span> <span style="font-style: italic;">"~/org/"</span>
         <span style="font-weight: bold;">:base-extension</span> <span style="font-style: italic;">"org"</span>
         <span style="font-weight: bold;">:publishing-directory</span> <span style="font-style: italic;">"/ssh:user@host:~/html/notebook/"</span>
         <span style="font-weight: bold;">:publishing-function</span> org-html-publish-to-html
         <span style="font-weight: bold;">:exclude</span> <span style="font-style: italic;">"PrivatePage.org"</span> <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">regexp</span>
         <span style="font-weight: bold;">:headline-levels</span> 3
         <span style="font-weight: bold;">:section-numbers</span> nil
         <span style="font-weight: bold;">:with-toc</span> nil
         <span style="font-weight: bold;">:html-head</span> <span style="font-style: italic;">"&lt;link rel=\"stylesheet\"</span>
<span style="font-style: italic;">                       href=\"../other/mystyle.css\" type=\"text/css\"/&gt;"</span>
         <span style="font-weight: bold;">:html-preamble</span> t)

        (<span style="font-style: italic;">"images"</span>
         <span style="font-weight: bold;">:base-directory</span> <span style="font-style: italic;">"~/images/"</span>
         <span style="font-weight: bold;">:base-extension</span> <span style="font-style: italic;">"jpg</span><span style="font-weight: bold; font-style: italic;">\\</span><span style="font-weight: bold; font-style: italic;">|</span><span style="font-style: italic;">gif</span><span style="font-weight: bold; font-style: italic;">\\</span><span style="font-weight: bold; font-style: italic;">|</span><span style="font-style: italic;">png"</span>
         <span style="font-weight: bold;">:publishing-directory</span> <span style="font-style: italic;">"/ssh:user@host:~/html/images/"</span>
         <span style="font-weight: bold;">:publishing-function</span> org-publish-attachment)

        (<span style="font-style: italic;">"other"</span>
         <span style="font-weight: bold;">:base-directory</span> <span style="font-style: italic;">"~/other/"</span>
         <span style="font-weight: bold;">:base-extension</span> <span style="font-style: italic;">"css</span><span style="font-weight: bold; font-style: italic;">\\</span><span style="font-weight: bold; font-style: italic;">|</span><span style="font-style: italic;">el"</span>
         <span style="font-weight: bold;">:publishing-directory</span> <span style="font-style: italic;">"/ssh:user@host:~/html/other/"</span>
         <span style="font-weight: bold;">:publishing-function</span> org-publish-attachment)
        (<span style="font-style: italic;">"website"</span> <span style="font-weight: bold;">:components</span> (<span style="font-style: italic;">"orgfiles"</span> <span style="font-style: italic;">"images"</span> <span style="font-style: italic;">"other"</span>))))

</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgbac7e7c" class="outline-3">
<h3 id="orgbac7e7c"><span class="done DONE">DONE</span> 触发发布(Triggering Publication)</h3>
<div class="outline-text-3" id="text-orgbac7e7c">
<p>
发布命令.
</p>

<p>
正确配置后, Org 能使用下面的命令发布:
</p>

<dl class="org-dl">
<dt><code>C-c C-e P x</code> &#x2013; <code>org-publish</code></dt><dd>提示输入指定项目并将属于该项目的所有文件发布.</dd>
<dt><code>C-c C-e P p</code> &#x2013; <code>org-publish-current-project</code></dt><dd>发布包含了当前文件的项目.</dd>
<dt><code>C-c C-e P f</code> &#x2013; <code>org-publish-current-file</code></dt><dd>仅发布当前文件.</dd>
<dt><code>C-c C-e P a</code> &#x2013; <code>org-publish-all</code></dt><dd>发布所有项目.</dd>
</dl>


<p>
当文件被修改时,Org 使用时间戳来追踪文件. 上面的命令通常只发布已经修改过的文件.你
可以通过在上面任意命令之前加上前缀参数或者自定义变量
<code>org-publish-use-timestamps-flag</code> 来重写该行为,并强制发布所有文件. 这样做在文件里
用了 <code>SETUPFILE</code> 或者 <code>INCLUDE</code> 关键字来包含其他文件时是尤其有必要的.
</p>
</div>
</div>
</div>
<div id="outline-container-orgde4233a" class="outline-2">
<h2 id="orgde4233a"><span class="todo TODO">TODO</span> 引用处理(Citation handling)</h2>
</div>
<div id="outline-container-org1767335" class="outline-2">
<h2 id="org1767335"><span class="done DONE">DONE</span> 处理源代码(Working with Source Code)</h2>
<div class="outline-text-2" id="text-org1767335">
<p>
这里的源代码指的是使用人类可读的编程语言编写的,可能带有注释的,任意纯文本计算机指
令集.当在一个 Org 文档中,源代码使用了 'begin' 和 'end' 记号标识时, Org 可以管理
这些源代码. 使用源代码始于识别源代码块. 一个源代码块几乎可以放置在 Org 文档的任
何地方;它不限于文档的序言或结尾.但是,如果源代码块位于 Org 注释内,或是位于固定宽
度的部分里,则 Org 无法管理这些源代码块.
</p>

<p>
下面是一个使用 Emacs Lisp 语言的源代码块的例子:
</p>
<pre class="example">
#+BEGIN_SRC emacs-lisp
  (defun org-xor (a b)
     "Exclusive or."
     (if a (not b) b))
#+END_SRC
</pre>

<p>
源代码块是众多 Org 块结构类型中的一种, Org 的块结构类型还包括 "center",
"comment", "dynamic", "example", "export", "quote", "special" 和 "verse".
</p>

<p>
本节适用于 "#+BEGIN_SRC" 和 "#+END_SRC" 之间的块结构(也就是源代码块结构)
</p>

<p>
下面各小节描述了 Org 处理源代码块的功能的细节.
</p>
</div>
<div id="outline-container-orga3f283f" class="outline-3">
<h3 id="orga3f283f"><span class="done DONE">DONE</span> 功能预览(Features Overview)</h3>
<div class="outline-text-3" id="text-orga3f283f">
<p>
享受源代码块结构的多种功能.
</p>

<p>
Org 可以以多种方式管理由 "#BEGIN_SRC" 和 "#+END_SRC" 分隔的块中的源代码,这可以简
化现代源代码维护所必需的日常任务. Org 可以编辑,格式化,提取,导出和发布源代码块.Org
也可以编译和执行源代码块,然后捕获结果. Org mode 资料有时将源代码块成为 <span class="underline">live code</span>
块(实时代码块|活代码块?),因为它们可以更改 Org 文档或其导出的材料的内容.用户可以
通过调整用于编译,执行,提取和导出的头信息参数
(参见 <a href="#org05436bf">使用头参数(Using Header Arguments)</a>) 来控制每个代码块的"活力".
</p>

<p>
对于编辑和格式化源代码块,Org 使用合适的 Emacs 主模式,这些模式包含了专门为该语言
的源代码设计的功能.
</p>

<p>
Org 可以提取一个或多个源代码块,并将它们写入到一个或多个源文件中,该步骤在文学化
编程术语中被成为 <span class="underline">tangling</span>.
</p>

<p>
对于导出和发布, Org 的后端程序可以将源代码块正确地格式化,通常使用本地的语法高亮
显示.
</p>

<p>
对于执行和编译源代码块,用户可以配置 Org 来选择合适的编译器. Org 提供了收集执行结
果或编译器输出,并将其插入到 Org 文档和(或)导出的功能(工具). 除了文本结果之外,
Org 也能插入其他数据类型的链接,包括视频,音频和图像. Org 也能将编译器的错误信息链
接到源代码块的合适的行.
</p>

<p>
Org 管理源代码块的一个重要特征是能够对任意语言的源代码块使用通用语法,将变量,函数
和结果传递给另一个代码块. 尽管大部分的文学化编程工具都局限于一种或另一种语言,
Org 的语言不可知的方法让文学化编程人员将每个编程任务与合适的编程语言匹配,并将它
们混合在一个 Org 文档中. 这种语言间的互操作性解释了 Org 的源代码块管理功能被其创
始人 Eric Schulte 和 Dan Davison 命名为 <span class="underline">Org Babel</span> 的原因.
</p>

<blockquote>
<p>
the confusing sound of many people talking at the same time or using different
languages: a babel of voice.
中文译为:嘈杂声(尤指讲多种语言)
</p>
</blockquote>

<p>
Org mode 通过将文本,数据,代码,执行环境的配置设置,执行结果,和相关的叙述,声明,参考,以
及内部和外部的链接保存在一个 Org 文档中,实现了发布可复现的研究的易验证和易维护的
承诺.
</p>
</div>
</div>
<div id="outline-container-orgf2f7b6e" class="outline-3">
<h3 id="orgf2f7b6e"><span class="done DONE">DONE</span> 代码块的结构(Structure of Code Blocks)</h3>
<div class="outline-text-3" id="text-orgf2f7b6e">
<p>
代码块的语法描述.
</p>

<p>
Org 提供了两种在 Org 文档里构造源代码的方法:源代码块和直接内联.两种规格如下所示.
</p>

<p>
一个源代码块符合这个结构:
</p>
<pre class="example">

#+NAME: &lt;name&gt;
#+BEGIN_SRC &lt;language&gt; &lt;switches&gt; &lt;header arguments&gt;
  &lt;body&gt;
#+END_SRC
</pre>

<p>
不要因为必需记住源代码块语法而拖延. Org 模式提供了一个命令,用于将现有文本包装在
块中(参见 <a href="#org5bcee50">结构模板(Structure Templates)</a>).Org 也与 Emacs 的其他补全系统一起工作,
其中一些系统早于 Org, 并且具有自定义的特定领域的语言来定义模板. 经常使用模板能减
少错误,提高准确性并保持一致性.
</p>

<p>
一个内联代码块符合下面这个结构:
</p>

<pre class="example">
src_&lt;language&gt;{&lt;body&gt;}

src_&lt;language&gt;[&lt;header arguments&gt;]{&lt;body&gt;}
</pre>

<p>
上面两种结构中使用的各个标记的含义:
</p>

<dl class="org-dl">
<dt><code>#+NAME: &lt;name&gt;</code></dt><dd>可选项. 命名代码块,这样它从其他的代码块或是内联代码中被调
用来执行或是捕获结果,就像一个函数一样. 其他块结构,文件,和表格公式
(参见 <a href="#orgf6845f0">电子表格(The Spreadsheet)</a>) 里的代码可以使用名字来引用一个源代码块. 这个
命名与命名 Org 表格的目的相同. Org mode 要求命名唯一. 对于重复的命名, Org mode
的行为是未知的.</dd>

<dt><code>#+BEGIN_SRC ... #+END_SRC</code></dt><dd>强制项. 它们标记着 Org 需要的一个块的开始和结
束. <code>#+BEGIN_SRC</code> 行接受下文描述的额外的参数.</dd>

<dt><code>&lt;language&gt;</code></dt><dd>强制项. 这是块结构中源代码语言的标识符.关于所支持的语言的标识
符,请参见 <a href="#orgc0e7e39">语言(Languages)</a> 部分.</dd>

<dt><code>&lt;switches&gt;</code></dt><dd>可选项. 开关参数为代码的执行,导出和格式化提供了更好的控制.(具
体使用案例参见 <a href="#orge51ce3a">文字示例(Literal Examples)</a> )</dd>

<dt><code>&lt;header arguments&gt;</code></dt><dd>可选项. 头参数控制代码块的执行,导出和 <span class="underline">tangling</span> 的多
个方面(使用案例参见<a href="#org05436bf">使用头参数(Using Header Arguments)</a>). 使用 Org 的属性功能,
可以将头参数有选择性的到整个缓冲区或是 Org 文档的特定的子树.</dd>

<dt><code>&lt;body&gt;</code></dt><dd>指定语言标识符的方言的源代码</dd>
</dl>
</div>
</div>

<div id="outline-container-org05436bf" class="outline-3">
<h3 id="org05436bf"><span class="done DONE">DONE</span> 使用头参数(Using Header Arguments)</h3>
<div class="outline-text-3" id="text-org05436bf">
<p>
设置头参数的不同方法.
</p>

<p>
Org 自带许多所有语言通用的头参数. 当特定的语言可用于源代码块时,会为它们添加新的
头参数. <span class="underline">一个头参数由一个初始冒号加上小写的参数名字指定</span>.
</p>

<p>
因为头参数可以通过多种方式设置,因此 Org 通过给本地属性更高的优先级来在出现冲突和
重叠的情况下对其进行优先级排序. 例如, 方法调用里的头信息参数值会覆盖全局默认设置
中的头信息参数的值.
</p>

<p>
<b>系统范围(级)的头参数</b>
</p>
<hr />
<p>
系统级的头参数可以通过配置变量 <code>org-babel-default-header-args</code> 来指定, 该变量默
认为下面这些值:
</p>
<pre class="example">
:session    =&gt; "none"
:results    =&gt; "replace"
:exports    =&gt; "code"
:cache      =&gt; "no"
:noweb      =&gt; "no"
</pre>

<p>
下面这个例子将 <code>:noweb</code> 头参数设置为 <code>yes</code>, 这会使得 Org 默认扩展 <code>:noweb</code> 引用.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">setq</span> org-babel-default-header-args
      (cons '(<span style="font-weight: bold;">:noweb</span> . <span style="font-style: italic;">"yes"</span>)
            (assq-delete-all <span style="font-weight: bold;">:noweb</span> org-babel-default-header-args)))
</pre>
</div>

<p>
通过配置变量 <code>org-babel-default-header-args:&lt;LANG&gt;</code>, 每个语言都可以拥有单独的默
认头参数, 这里的 &lt;LANG&gt; 是语言的名字. 更多细节,请参考特定语言的在线文档:
<a href="https://orgmode.org/worg/org-contrib/babel/">https://orgmode.org/worg/org-contrib/babel/</a>.
</p>

<p>
<b>Org 模式属性里的头参数</b>
</p>
<hr />
<p>
对于可以应用到缓冲区的头参数,可以在 Org 文件的任意位置使用 <code>PROPERTY</code> 关键字(请
参考 <a href="#orga6e491a">属性语法(Property Syntax)</a>).
</p>

<p>
下面这个例子让所有的 R 语言的代码块在同一个会话中执行. 将 <code>:results</code> 设置为
<code>silent</code> 会忽略所有代码块的执行结果,而不仅仅是 R 代码块; 对于任意块结构,都不会有
结果插入.
</p>
<pre class="example">
#+PROPERTY: header-args:R  :session *R*
#+PROPERTY: header-args    :results silent
</pre>

<p>
通过 Org 的属性抽屉(参见 <a href="#orga6e491a">属性语法(Property Syntax)</a>) 设置的头参数应用于向下的子
树级别. 因为这些属性抽屉可以出现在文件层级的任意位置,所以 Org 使用最外层的调用或
是源块结构来解析这些值(这里的最外层实际上指的是离 Org 的树结构的根节点最远的方
向,即离块结构最近的设置). Org 此时会忽略 <code>org-use-property-inheritance</code> 的设置,
也就是说就算该变量为 <code>nil</code> ,Org 也会搜寻最近的上一级属性设置来为块结构设置头参数.
</p>

<p>
下面的例子将子树里所有的代码块结构的 <code>:cache</code> 参数设置默认为 <code>yes</code>:
</p>
<pre class="example">
* sample header
  :PROPERTIES:
  :header-args:    :cache yes
  :END:
</pre>

<p>
通过 <code>org-set-property</code> 函数(该函数绑定到快捷键 <code>C-c C-x p</code> )定义的属性,适用于所
有生效的语言(Org 默认只启用了 Emacs-lisp 语言的支持).
</p>

<p>
特定语言的头参数也可以从 <code>header-args:&lt;LANG&gt;</code> 属性里读取,这里的 <code>&lt;LANG&gt;</code> 是语言
标识符.例如:
</p>

<pre class="example">
* Heading
  :PROPERTIES:
  :header-args:clojure:    :session *clojure-1*
  :header-args:R:          :session *R*
  :END:
** Subheading
  :PROPERTIES:
  :header-args:clojure:    :session *clojure-2*
  :END:
</pre>
<p>
这个例子会强制 <code>Heading</code> 和 <code>Subheading</code> 里的 Clojure 代码块使用不同的会话,但是
对所有的 R 代码块使用相同的会话. 在 <code>Subheading</code> 里的块会继承 <code>Heading</code> 里的设置.
</p>

<p>
<b>特定代码块的头参数</b>
</p>
<hr />
<p>
在 <code>#+BEGIN_SRC</code> 行,头参数通常在源代码块级别.设置在这一级别的参数优先级高于设置
在变量 <code>org-babel-default-header-args</code> 里和那些作为头属性的参数.
</p>

<p>
在下面的例子里,将 <code>:results</code> 设置为 <code>silent</code> 会让其忽略代码执行的结果. 将
<code>:exports</code> 设置为 <code>code</code> 会只将代码块的 body 部分(也就是主体代码部分)导出为 HTML
或 LaTeX.
</p>
<pre class="example">
#+NAME: factorial
#+BEGIN_SRC haskell :results silent :exports code :var n=0
  fac 0 = 1
  fac n = n * fac (n-1)
#+END_SRC
</pre>


<p>
下面是内联代码块的相同头参数设置:
</p>
<pre class="example">
src_haskell[:exports both]{fac 5}
</pre>

<p>
在每一行使用 <code>#+HEADER:</code> 可以让代码块头参数跨越多行.请注意,Org 现在仍接受
<code>#+HEADER:</code> 的复数形式拼写仅仅是为了便于向下兼容,它可能会在某一时刻被移除.
</p>

<p>
在一个未命名的代码块里的多行头参数:
</p>
<pre class="example">
#+HEADER: :var data1=1
#+BEGIN_SRC emacs-lisp :var data2=2
   (message "data1:%S, data2:%S" data1 data2)
#+END_SRC

#+RESULTS:
: data1:1, data2:2
</pre>
<p>
再一个已命名的代码块里的多行头参数:
</p>
<pre class="example">
#+NAME: named-block
#+HEADER: :var data=2
#+BEGIN_SRC emacs-lisp
  (message "data:%S" data)
#+END_SRC

#+RESULTS: named-block
  : data:2
</pre>

<p>
<b>函数调用里的头参数</b>
</p>
<hr />
<p>
函数调用里的头参数是最独特的,并且如果发生了参数设置的重叠,它会覆盖所有其他设置.它
们拥有最高一级的优先级. 下面展示了两个 <code>#+CALL:</code> 的例子. 对于完整的 <code>CALL</code> 关键
字的语法,请查阅 <a href="#org81d9cb6">执行代码块(Evaluating Code Blocks)</a>.
</p>

<p>
在这个例子里 <code>:export results</code> 头参数被应用到 <code>#+CALL:</code> 行的执行操作里.
</p>
<pre class="example">
#+CALL: factorial(n=5) :exports results
</pre>

<p>
这个例子里 <code>:session special</code> 头参数被应用到 <code>factorial</code> 代码块的执行中.
</p>
<pre class="example">
#+CALL: factorial[:session special](n=5)
</pre>
</div>
</div>
<div id="outline-container-org0e36621" class="outline-3">
<h3 id="org0e36621"><span class="done DONE">DONE</span> 代码块的环境(Environment of a Code Block)</h3>
<div class="outline-text-3" id="text-org0e36621">
<p>
代码运行的参数,会话,工作目录等等.
</p>

<p>
<b>传递参数</b>
</p>
<hr />
<p>
使用 <code>var</code> 来向源代码块传递参数.代码块里的变量的细节因语言而异,具体内容在特定语
言的文档中有介绍.但是 <code>var</code> 的语法对所有语言都是一样的.这包含了声明变量和指定默
认值.
</p>

<p>
下面的语法使用 <code>var</code> 头参数来为代码块传递参数:
</p>
<pre class="example">
:var NAME=ASSIGN
</pre>

<p>
这里的 NAME 是代码块主体中绑定的变量的名字. ASSIGN 是一个字面值,例如一个字符串,
一个数字,一个表格的引用,一个列表,一个文字示例,另一个带参数或不带参数的代码块,或
是一个代码块的运行结果. ASSIGN 可以为不同文件中的元素的引用指定文件名,使用 <code>:</code>
将文件名和引用分开即可:
</p>
<pre class="example">
:var NAME=FILE:REFERENCE
</pre>


<ul class="org-ul">
<li><p>
表格:
下面是一个通过引用传递值的例子: 使用 <code>NAME</code> 关键字命名了的表格:
</p>
<pre class="example">
#+NAME: example-table
| 1 |
| 2 |
| 3 |
| 4 |
</pre>
<p>
emacs-lisp 代码块里引用该表格:
</p>
<pre class="example">
#+NAME: table-length
#+BEGIN_SRC emacs-lisp :var table=example-table
  (length table)
#+END_SRC

#+RESULTS: table-length
: 4
</pre>

<p>
当传递一个表格时,你可以专门处理行或列,表格里包含标签的行或列.
</p>

<p>
<code>colnames</code> 头参数接受 <code>yes</code>, <code>no</code> 或 <code>nil</code> 值. 默认值是 <code>nil</code> :如果一个输入的
表格有列名(因为第二行是水平线),那么 Org 会先移除列名,处理表格,再将列名放回表格,然
后将表格写入到结果块里.使用 <code>yes</code> 值,Org 会对第一行做同样的操作,即使初始表格并
不包含任何水平线. 当设置为 <code>no</code> 时, Org 不对列明做任何预处理.
</p>
<pre class="example">
#+NAME: less-cols
| a |
|---|
| b |
| c |

#+BEGIN_SRC python :var tab=less-cols :colnames nil
    return [[val + '*' for val in row] for row in tab]
#+END_SRC

#+RESULTS:
| a  |
|----|
| b* |
| c* |
</pre>
<p>
这个例子里表格传递给 python 代码块是以一个多维列表的形式传递的.
</p>

<p>
类似的, <code>rownames</code> 头参数能接受两个值: <code>yes</code> 或 <code>no</code>. 当设置为 <code>yes</code> 时, Org
会移除第一列,处理表格,将第一列放回表格,然后将表格写入到结果块中. 默认的值为
<code>no</code>,这意味着 Org 不会预处理第一列. 请注意, Emacs Lisp 代码块会忽略掉
<code>rownames</code> 头参数,因为表格处理在 Emacs 里很容易.
</p>
<pre class="example">
#+NAME: with-rownames
| one | 1 | 2 | 3 | 4 |  5 |
| two | 6 | 7 | 8 | 9 | 10 |

#+BEGIN_SRC python :var tab=with-rownames :rownames yes
  return [[val + 10 for val in row] for row in tab]
#+END_SRC

#+RESULTS:
| one | 11 | 12 | 13 | 14 | 15 |
| two | 16 | 17 | 18 | 19 | 20 |
</pre>

<p>
要引用另一个文件中的表格,请加入文件名和带冒号的表格名,例如,
<code>:var table=other-file.org:example-table</code>.
</p></li>
<li><p>
列表:
一个简单的命名列表.
</p>
<pre class="example">
#+NAME: EXAMPLE-LIST
- SIMPLE
  - NOT
  - NESTED
- LIST

#+BEGIN_SRC EMACS-LISP :VAR X=EXAMPLE-LIST
  (PRINT X)
#+END_SRC

#+RESULTS:
| SIMPLE | LIST |
</pre>
<p>
请注意只有最高等级的列表条目被传递,嵌入的列表项目会被忽略.
</p></li>
<li><p>
不带参数的代码块:
代码块名称,可由上面示例里的 <code>NAME</code> 关键字指定,后面可选跟括号.
</p>
<pre class="example">
#+BEGIN_SRC emacs-lisp :var length=table-length()
  (* 2 length)
#+END_SRC

#+RESULTS:
: 8
</pre></li>
<li><p>
带参数的代码块:
代码块名称,由 <code>NAME</code> 关键字指定,后面跟着括号和括号里传递的可选的参数.
</p>
<pre class="example">
#+NAME: double
#+BEGIN_SRC emacs-lisp :var input=8
  (* 2 input)
#+END_SRC

#+RESULTS: double
: 16

#+NAME: squared
#+BEGIN_SRC emacs-lisp :var input=double(input=1)
  (* input input)
#+END_SRC

#+RESULTS: squared
: 4
</pre></li>
<li><p>
文字示例:
一个用 <code>NAME</code> 关键字命名的文字示例块.
</p>
<pre class="example">

#+NAME: literal-example
#+BEGIN_EXAMPLE
  A literal example
  on two lines
#+END_EXAMPLE

#+NAME: read-literal-example
#+BEGIN_SRC emacs-lisp :var x=literal-example
  (concatenate #'string x " for you.")
#+END_SRC

#+RESULTS: read-literal-example
: A literal example
: on two lines for you.
</pre></li>
</ul>


<p>
索引变量的值可以引用一个变量的部分.索引从0开始,负数从尾端倒数计数.如果一个索引用
逗号分隔,则后面的每个部分都将索引为下一维度. 请注意,这个索引操作发生在其他的表格
相关的头参数(比如, <code>hlines</code>, <code>colnames</code>, <code>rownames</code>)被应用之前. 下面的例子将表格
<code>example-table</code> 的第一行的最后一个单元格赋值给变量 <code>data</code>:
</p>
<pre class="example">

#+NAME: example-table
| 1 | a |
| 2 | b |
| 3 | c |
| 4 | d |

#+BEGIN_SRC emacs-lisp :var data=example-table[0,-1]
  data
#+END_SRC

#+RESULTS:
: a
</pre>
<blockquote>
<p>
用逗号隔开的索引相当于多维矩阵的座标,[0,-1] 就表示第0行倒数第1个元素.
</p>
</blockquote>

<p>
用冒号隔开的两个整数引用变量值的一个范围.这种情况下将引用整个包含的范围.例如,下
面的例子将 <code>example-table</code> 的中间三行赋值给 <code>data</code>.
</p>
<pre class="example">

#+NAME: example-table
| 1 | a |
| 2 | b |
| 3 | c |
| 4 | d |
| 5 | 3 |

#+BEGIN_SRC emacs-lisp :var data=example-table[1:3]
  data
#+END_SRC

#+RESULTS:
| 2 | b |
| 3 | c |
| 4 | d |
</pre>

<p>
要选择整个范围,使用一个空的索引,或者是单个字符 <code>*</code>. <code>0:-1</code> 也是相同的效果.下面的
例子展示了如何只引用第一列.
</p>
<pre class="example">
#+NAME: example-table
| 1 | a |
| 2 | b |
| 3 | c |
| 4 | d |

#+BEGIN_SRC emacs-lisp :var data=example-table[,0]
  data
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 | 4 |
</pre>

<p>
索引引用可以被表格和代码块使用.索引引用可以处理任意数量的维度.逗号分隔多个维度,
如下所示.
</p>
<pre class="example">
#+NAME: 3D
#+BEGIN_SRC emacs-lisp
  '(((1  2  3)  (4  5  6)  (7  8  9))
    ((10 11 12) (13 14 15) (16 17 18))
    ((19 20 21) (22 23 24) (25 26 27)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :var data=3D[1,,1]
  data
#+END_SRC

#+RESULTS:
| 11 | 14 | 17 |
</pre>

<p>
请注意,行名和列名不会在变量索引之前被移除.即使当 <code>colnames</code> 和 <code>rownames</code> 参数设
置为移除行名和列名,在索引时你也需要将它们算上.
</p>

<p>
Emacs lisp 代码也可以为这些变量设置值. 为了区分来自 Lisp 代码的值, Org 将任何以
<code>(</code>, <code>[</code>, <code>'</code>, 或 <code>`</code> 开头的值视为 Emacs Lisp 代码. 然后这类代码的执行结果会被赋
值到那个变量的值.下面的例子展示了如何使用头信息来可靠的查询和传递 Org 模式缓冲区
的文件名到一个代码块中.我们这里需要可靠性是因为一旦块中的代码开始执行,文件的名字
就可能会改变.
</p>
<pre class="example">
#+BEGIN_SRC sh :var filename=(buffer-file-name) :exports both
  wc -w $filename
#+END_SRC
</pre>
<p>
请注意从表格和列表里读取的值不会被错误地当成 Emacs Lisp 代码执行,如下面展示的代
码所示.
</p>
<pre class="example">
#+NAME: table
| (a b c) |

#+HEADER: :var data=table[0,0]
#+BEGIN_SRC perl
  $data
#+END_SRC

#+RESULTS:
: (a b c)
</pre>

<p>
<b>使用会话</b>
</p>
<hr />
<p>
两个代码块可以分享相同的环境. <code>session</code> 头参数就是为了让多个源代码块在一个会话下
运行的. Org 将在相同的解释器进程里运行具有相同会话名的代码块.
</p>

<dl class="org-dl">
<dt><code>none</code></dt><dd>默认值,每个代码块都会获得一个新的解释器进程用来执行代码.一旦块执行完
毕,进程就结束.</dd>
<dt>STRING</dt><dd>任何除了 <code>none</code> 之外的字符串会将该字符串变成该会话的名字.例如
<code>:session STRING</code> 将会话命名为 <code>STRING</code>. 如果 <code>session</code> 没有值,则会话名会从源
语言标识符里派生.使用相同的源代码语言的相邻的代码块使用相同的会话.根据语言的不
同,声明变量,来自其他块的代码,和所有的解释器环境都可能被共享.当后续源代码块改变
会话名称时,有些解释型语言支持并发会话.</dd>
</dl>


<p>
只有支持交互式执行的语言才支持会话功能.不是所有的语言都提供了这种支持,例如 C 语
言和 ditaa. 即使是如 Python 和 Haskell 这样支持交互式执行的语言也对可以交互运行
的语言构造施加了限制. Org 继承了那些在会话中运行的代码块的限制.
</p>

<p>
<b>选择一个工作目录</b>
</p>
<hr />
<p>
<code>dir</code> 头参数指定代码块运行期间的默认目录. 如果该参数不存在,则使用当前缓冲区相关
的目录. 也就是说,临时提供 <code>:dir DIRECTORY</code> 与使用 <code>M-x cd &lt;RET&gt; DIRECTORY</code> ,然后
不设置 <code>dir</code> 具有相同的效果.实际上, <code>dir</code> 只是简单的设置了 Emacs 的变量
<code>default-directory</code>. 如果有必要的话,将 <code>mkdirp</code> 头参数设置为非 <code>nil</code> 值会创建目
录.
</p>

<p>
例如,要保存绘图文件到家目录的 <code>Work/</code> 目录下&#x2013;注意波浪号被扩展了:
</p>
<pre class="example">
#+BEGIN_SRC R :file myplot.png :dir ~/Work
  matplot(matrix(rnorm(100), 10), type="l")
#+END_SRC
</pre>

<p>
要在一个远程机器上执行代码块,请使用 Tramp 语法提供一个远程目录名. 例如:
</p>
<pre class="example">
#+BEGIN_SRC R :file plot.png :dir /scp:dand@yakuba.princeton.edu:
  plot(1:10, main=system("hostname", intern=TRUE))
#+END_SRC
</pre>

<p>
首先, Org 像平常一样捕捉文本结果插入到 Org 文件中.然后 Org 也会插入一个链接到远
程文件的链接, 感谢 Emacs 的 Tramp 功能. Org 会从 <code>dir</code> 和 <code>default-directory</code> 里
构建文件名称的远程路径,如下所示:
</p>
<pre class="example">
[[file:/scp:dand@yakuba.princeton.edu:/home/dand/plot.png][plot.png]]
</pre>

<p>
当 <code>dir</code> 和 <code>session</code> 一起使用时, Org 会为新的会话设置开始目录.但是 Org 不会改变
已有会话的目录.
</p>

<p>
为了避免 Org 插入远程文件的错误链接,请不要将 <code>dir</code> 和 <code>:exports resutls</code> 或
<code>:exports both</code> 一起使用. 这是因为 Org 不会扩展 'default directory' 以避免一些潜
在的可移植性问题.
</p>

<p>
<b>插入头部和尾部</b>
</p>
<hr />
<p>
'prologue' 头参数用于附加到代码块的顶部以供执行,如重置指令. 例如,你可以使用在一
个 Gnuplot 代码块里使用 <code>:prologue reset</code> ,或是为每一个这样的代码块设置:
</p>
<pre class="example">
(add-to-list 'org-babel-default-header-args:gnuplot
             '((:prologue . "reset")))
</pre>

<p>
类似的, <code>epilogue</code> 头参数是为了附加到代码块的尾部以供执行的.
</p>
</div>
</div>

<div id="outline-container-org81d9cb6" class="outline-3">
<h3 id="org81d9cb6"><span class="done DONE">DONE</span> 执行代码块(Evaluating Code Blocks)</h3>
<div class="outline-text-3" id="text-org81d9cb6">
<p>
将代码块的运行结果放到 Org 缓冲区里.
</p>

<p>
一个关于安全性的提示: 代码执行带来伤害的风险. Org 通过在执行源代码块里的任意代码
之前提示输入用户的许可来进行保护. 要定制这个保护措施,或是禁用它,
请参阅 <a href="#org915f469">代码执行安全性(Code Evaluation Security)</a> 部分.
</p>

<p>
<b>如何执行源代码</b>
</p>
<hr />
<p>
Org 会捕捉代码块的执行结果,并将它们插入到 Org 文件里就在代码块之后的位置. 插入点
是位于一个新行和 <code>RESULTS</code> 关键字之后. Org 会创建 <code>RESULTS</code> 关键字(如果它还没有).
</p>

<p>
默认情况下, Org 仅启用 Emacs Lisp 代码块的执行.
启用其他语言请参阅 <a href="#orgc0e7e39">语言(Languages)</a>.
</p>

<p>
Org 提供了多种方法来执行代码块.当光标位于一个代码块时<sup><a id="fnr.84" class="footref" href="#fn.84">84</a></sup>, <code>C-c C-c</code> 或 <code>C-c C-v e</code> 会调用 <code>Org-babel-execute-src-block</code> 函数,该函数
会执行块中的代码,收集结果, 并将结果插入到缓冲区.
</p>

<p>
通过从 Org 模式缓冲区或表格里调用一个已命名的代码块
<sup><a id="fnr.85" class="footref" href="#fn.85">85</a></sup>, Org 可以从当前 Org mode 缓冲区
或从 "Babel 库" 里调用命名的代码块(参见 <a href="#org6769dc0">Babel 库(Library of Babel)</a>).
</p>

<p>
'CALL' 关键字的语法是:
</p>
<pre class="example">
#+CALL: &lt;name&gt;(&lt;arguments&gt;)
#+CALL: &lt;name&gt;[&lt;inside header arguments&gt;](&lt;arguments&gt;) &lt;end header arguments&gt;
</pre>
<p>
内联的命名代码块的语法是:
</p>
<pre class="example">
... call_&lt;name&gt;(&lt;arguments&gt;) ...
... call_&lt;name&gt;[&lt;inside header arguments&gt;](&lt;arguments&gt;)[&lt;end header arguments&gt;] ...
</pre>

<p>
当使用内联语法时,结果会基于变量 <code>org-babel-inline-result-wrap</code> 进行包装,该变量默
认设置为 <code>"=%s="</code> 以生成适合标记的原义文本.
</p>

<dl class="org-dl">
<dt><code>&lt;name&gt;</code></dt><dd><p>
这是当前文档中要计算的代码块的名称(参加 <a href="#orgf2f7b6e">代码块的结构(Structure of Code Blocks)</a> ). 如果代码块位于另一个文件,请让 <code>&lt;name&gt;</code> 以文件名跟一个冒号开头.
例如, 为了执行 'file.org' 里的一个名为 'clear-data' 的块, 你可以使用下面内容:
</p>
<pre class="example">
#+CALL: file.org:clear-data()
</pre></dd>
<dt><code>&lt;arguments&gt;</code></dt><dd><p>
Org 使用标准的函数调用语法传递参数到代码块. 例如, 一个传递
'4' 到一个命名为 'double' 的代码块,且该代码块声明了头参数 <code>:var n=2</code>, 的
<code>#+CALL:</code> 行,可以这样写;
</p>
<pre class="example">
#+CALL: double(n=4)
</pre>
<p>
请注意这个函数调用语法于头参数语法的区别.
</p></dd>
<dt><code>&lt;inside header arguments&gt;</code></dt><dd>Org 使用头参数语法将内部头参数传递给命名代码块.内
部头参数应用到代码块的执行.例如, <code>[:results output]</code> 收集该块执行期间打印到标
准输出的结果. 请注意该头参数语法和函数调用语法的不同.</dd>
<dt><code>&lt;end header arguments&gt;</code></dt><dd>结尾头参数影响代码块返回的结果.例如,
<code>:results html</code> 在插入结果到 Org 缓冲区之前将结果用 <code>#+BEGIN_EXPORT html</code> 块来
包装.</dd>
</dl>


<p>
测试,这里的 <code>&lt;inside header arguments&gt;</code> 和 <code>&lt;end header arguments&gt;</code> 根据说明来看
应该只是位置不同但效果一致的头参数设置:
</p>
<pre class="example">
#+NAME: hello_py
#+begin_src python
def hello():
    print("hello Org!")
hello()
#+end_src

#+CALL: hello_py[:results output]()

#+RESULTS:
: hello Org!

#+CALL: hello_py():results output

#+RESULTS:
: hello Org!

#+CALL: hello_py():results html output

#+RESULTS:
#+begin_export html
hello Org!
#+end_export
</pre>

<p>
<b>限制代码块执行</b>
</p>
<hr />
<p>
'eval' 头参数可以限制特定代码块和 <code>CALL</code> 关键字的执行.通过提示输入确认对于保护执
行未信任的代码来说是很有用的.
</p>

<dl class="org-dl">
<dt>'never' 或 'no'</dt><dd>Org 不会执行源代码.</dd>
<dt>'query'</dt><dd>Org 提示用户输入执行源代码的权限.</dd>
<dt>'never-export' 或 'no-export'</dt><dd>在导出时 Org 不会执行源代码,然而用户可以交互
式执行它.</dd>
<dt>'query-export'</dt><dd>导出期间,Org 提示用户输入执行源代码的权限.</dd>
</dl>


<p>
如果 'eval' 头参数没有设置,则 Org 根据 <code>org-confirm-babel-evaluate</code> 变量的值来决
定是否执行源代码(参见 <a href="#org915f469">代码执行安全性(Code Evaluation Security)</a>) .
</p>

<p>
<b>缓存执行结果</b>
</p>
<hr />
<p>
'cache' 头参数是用来缓存代码块的执行结果的. 缓存结果可以避免重新计算自上次运行以
来未改变的代码块.要从缓存中收益并避免重复计算,源代码块必须在缓冲区中已经存在一个
结果,并且包括 'var' 引用的值在内的头参数的值和块的本身自上次计算结果以来都没有改
变. 这一特性大大有助于避免长时间运行的计算.然而,对于某学边缘情况,缓存的结果可能
不可靠.
</p>

<p>
当代码块是纯函数时,缓存特性是最适合的,即为相同输入参数返回相同值,
(参见 <a href="#org0e36621">代码块的环境(Environment of a Code Block)</a>), 没有副作用,且不依赖输入参数以
外的外部变量的函数. 依赖计时器,文件系统对象,和随机数生成器的函数很显然不适合使用
缓存.
</p>

<p>
警告: 当 'cache' 在一个会话中使用时,缓存可能会造成意外结果.
</p>

<p>
当缓存机制检查任意源代码改动时,它不会扩展 noweb 风格的引用
(参见<a href="#orgd2719d8">Noweb 引用语法(Noweb Reference Syntax)</a>) .
</p>

<p>
'cahche' 头参数可以有这两个值中的一个值: 'yes' 或 'no'.
</p>

<dl class="org-dl">
<dt>'no'</dt><dd>默认值,不缓存结果;代码块每次都执行.</dd>
<dt>'yes'</dt><dd>通过比较组合的代码块和传递给它的参数的 SHA1 哈希值来决定是否运行代码
或是返回缓存的结果.这个哈希值打包在先前执行的 <code>#+RESULTS:</code> 行中.当哈希值匹配时,
Org 不会执行代码块.当哈希值不匹配时, Org 执行代码块,插入结果,并重新计算哈希值,
更新 <code>#+RESULTS:</code> 行.</dd>
</dl>


<p>
在下面的例子里名，两个函数都被缓存. 但是 'caller' 只在 'random' 的结果自上次运行
后发生变化时才运行.
</p>

<pre class="example">
#+NAME: random
#+BEGIN_SRC R :cache yes
  runif(1)
#+END_SRC

#+RESULTS[a2a72cd647ad44515fab62e144796432793d68e1]: random
0.4659510825295

#+NAME: caller
#+BEGIN_SRC emacs-lisp :var x=random :cache yes
  x
#+END_SRC

#+RESULTS[bec9c8724e397d5df3b696502df3ed7892fc4f5f]: caller
0.254227238707244
</pre>
</div>
</div>

<div id="outline-container-org0b96222" class="outline-3">
<h3 id="org0b96222"><span class="done DONE">DONE</span> 运行的结果(Results of Evaluation)</h3>
<div class="outline-text-3" id="text-org0b96222">
<p>
选择结果的类型,后续处理等等.
</p>

<p>
Org 如何处理代码块运行的结果取决于多个头参数的共同作用.然而,主要的决定因素是
'results' 头参数. 它接受4种类型的选项. 每个代码块只能接受每种类型的一个选项:
</p>
<dl class="org-dl">
<dt>Collection</dt><dd>关于如何从代码块中收集结果;</dd>
<dt>Type</dt><dd>关于代码块会返回哪种类型的结果; 会影响 Org 如何将结果处理和插入到 Org
缓冲区;</dd>
<dt>Format</dt><dd>关于结果,影响 Org 如何处理结果;</dd>
<dt>Handling</dt><dd>关于一旦结果被正确格式化后插入结果.</dd>
</dl>


<p>
<b>Collection</b>
</p>
<hr />
<p>
collection (收集)选项指定结果. 选择下面其中一个选项,它们是互斥的:
</p>
<dl class="org-dl">
<dt>'value'</dt><dd>大部分 Babel 库的默认值. <span class="underline">函数模式</span> . Org 通过将代码包装在源代码语言的
函数定义中来获取值.这就是为什么当使用 <code>:results value</code> 时,代码应该像函数一样执
行并返回值. 对于像 Python 这样的语言, 当使用 <code>:results value</code> 时,一个显示的
'return' 语句是必需的. 结果是代码块里最后一个语句返回的值.<br />
当在一个会话里执行代码块时(参见 <a href="#org0e36621">代码块的环境(Environment of a Code Block)</a>),
Org 将代码传递给作为交互式 Emacs 次级进程运行的解释器. Org 从源代码解释器的最
后一个语句输出里获取值. Org 必须使用特定语言的方法来获取值. 例如, Ruby 语言里
从 <code>'_'</code> 变量获取, R 语言里从 <code>'.Last.value'</code> 的值里获取.</dd>
<dt>'output'</dt><dd><p>
<span class="underline">脚本模式</span> Org 将代码传递给一个运行着解释器的外部进程. Org 将标准
输出流的内容作为文本结果返回.
</p>

<p>
当使用会话时, Org 将代码传递给作为交互式 Emacs 次级进程运行的解释器. Org 连接
解释器输出的任意文本,并将集合作为结果返回.
</p></dd>
</dl>


<p>
<b>Type</b>
</p>
<hr />
<p>
Type (类型) 告知代码块执行时预期的结果类型. 选择下面选项中的一个;它们是互斥的.
默认的表现由结果类型自动决定.
</p>

<dl class="org-dl">
<dt><code>'table' 'vector'</code></dt><dd><p>
将结果作为 Org 表格解释. 如果结果是单个值,则创建一个一行
一列的表格. 使用示例: <code>:results value table</code>.
</p>

<p>
在没个表格行之间或表格标题之下,结果有时有水平线,也叫做 "hlines".
</p>

<p>
默认为 'no' 值的 'hlines' 参数会从输入表格中删除这些水平线. 对于大部分代码来说,这
是可取的,否则这些 'hlines' 符号会引发未绑定的变量的错误. 'yes' 则接受这样的水
平线,如下面例子所展示.
</p>
<pre class="example">
#+NAME: many-cols
| a | b | c |
|---+---+---|
| d | e | f |
|---+---+---|
| g | h | i |

#+NAME: no-hline
#+BEGIN_SRC python :var tab=many-cols :hlines no
  return tab
#+END_SRC

#+RESULTS: no-hline
| a | b | c |
| d | e | f |
| g | h | i |

#+NAME: hlines
#+BEGIN_SRC python :var tab=many-cols :hlines yes
  return tab
#+END_SRC

#+RESULTS: hlines
| a | b | c |
|---+---+---|
| d | e | f |
|---+---+---|
| g | h | i |
</pre></dd>

<dt>'list'</dt><dd>将结果作为 Org 列表解释. 如果结果是单个值,创建一个有一个元素的列表.</dd>

<dt>'scalar' 'verbatim'</dt><dd>按原义解释并插入为引用文本. 不会创建表格. 使用示例:
<code>:results value verbatim</code>.</dd>

<dt>'file'</dt><dd><p>
解释为一个文件名.将代码块的执行结果保存到那个文件中,然后插入一个连接
到它的链接. 你可以控制链接相关的文件名和描述.
</p>

<p>
首先 Org  会尝试从 'file' 头参数的值生成文件名,并生成用 'output-dir' 头参数指
定的目录.如果 'output-dir' 没有指定, Org 假定它是当前目录.
</p>

<pre class="example">
#+BEGIN_SRC asymptote :results value file :file circle.pdf :output-dir img/
size(2cm);
draw(unitcircle);
#+END_SRC
</pre>

<p>
如果 'file' 头参数缺失, Org 将根据代码块的名称生成输出文件的主文件名(或是叫文
件主名?), 以及其 'file-ext' 头参数来生成文件的扩展名.这种情况下,名字和扩展都是
必需的(上面的例子里可以代码块可以没有命名,但是下面的例子里就必须有命名和扩展名
了).
</p>
<pre class="example">
#+name: circle
#+BEGIN_SRC asymptote :results value file :file-ext pdf
size(2cm);
draw(unitcircle);
#+END_SRC
</pre>

<p>
'file-desc' 头参数定义了链接的描述部分(参见 <a href="#org5eb6777">链接格式(Link Format)</a> ). 如果有
'file-desc' 出现,但它没有值,则 'file' 的值会用作链接描述. 当没有使用这个参数时,描
述部分会被省略. 如果你想提供 'file-desc' 参数,但又要忽略描述部分,你可以使用一
个空矩阵来提供该参数(比如: <code>:file-desc []</code>).
</p>

<p>
默认情况下, Org 假设写入到文件的表格具有用 TAB 分隔的输出. 你可以使用 'sep' 头
参数选择一个不同的分隔符.
</p>

<p>
'file-mode' 头参数定义文件权限.
要让文件可执行, 请使用 <code>:file-mode (identity #o755)</code>.
</p>
<pre class="example">
#+BEGIN_SRC shell :results file :file script.sh :file-mode (identity #o755)
echo "#!/bin/bash"
echo "echo Hello World"
#+END_SRC
</pre></dd>
</dl>


<p>
<b>Format</b>
</p>
<hr />
<p>
格式与代码块返回的结果的类型有关.选择下面选项之一,它们是互斥的. 默认值遵循上面指
定的类型.
</p>

<dl class="org-dl">
<dt>'code'</dt><dd>结果包含在代码块中,用于解析.用法示例: <code>:results value code</code>.</dd>
<dt>'drawer'</dt><dd>结果包含在一个 'RESULTS' 抽屉里.用于包含 'raw'(原始) 或 'org' 的结
果,以便后面编写脚本和自动化处理.使用示例: <code>:results value drawer</code></dd>
<dt>'html'</dt><dd>结果包含在一个 'BEGIN_EXPORT html' 块中.
用法示例: <code>:results value html</code>.</dd>
<dt>'latex'</dt><dd>结果包含在 'BEGIN_EXPORT latex' 块中.用法示例: <code>results value latex</code>.</dd>
<dt>'link' 'graphics'</dt><dd><p>
当和 'file' 类型一起使用时,结果是指向 ':file' 头参数指定
的文件的链接.然而于普通的 'file' 类型不同,不会向磁盘写入任何内容.该块只是用其
副作用,如下面例子所示:
</p>
<pre class="example">
#+begin_src shell :results file link :file "download.tar.gz"
wget -c "https://example.com/download.tar.gz"
#+end_src
</pre>
<p>
这个 link 的意思是执行结果只为链接到文件的链接,只是生成这个链接,至于链接的文件
是怎么生成的,存不存在等一概不管.这样想的话, 'graphics' 应该就是结果为一个图片
的链接,这个图片从哪里来的,是否存在等也是一概不管.所以这个选项的作用就是仅仅生
成一个链接而已啊.
</p></dd>
<dt>'org'</dt><dd><p>
结果包含在一个 'BEGIN_SRC org' 块里. 用于逗号转义, 块中的 '&lt;TAB&gt;' ,或
是导出文件. 用法: <code>:results value org</code>. 这是因为 Org 使用的标记符号或其他符号
在块结构里可能会被当成 Org 文档的结构,所以需要进行转义处理,如下面的例子.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">return</span> <span style="font-style: italic;">"* Heading"</span>
</pre>
</div></dd>

<dt>'pp'</dt><dd>结果转变成美化打印的源代码.将结果包含在代码块中.
支持的语言: Emacs Lisp, Python, 和 Ruby. 使用案例: ':results value pp'</dd>
<dt>'raw'</dt><dd>按原生 Org mode 解释.直接插入到缓冲区,如果是表格则进行重新排列.使用示
例: <code>:results value raw</code></dd>
</dl>


<p>
'wrap' 头参数通过将字符串附加到 '#+BEGIN_' 和 '#+END_' 里来无条件地标记结果块.如
果没指定字符串, Org 将结果包含在 '#+BEGIN_result' &#x2026; '#+END_results' 块里.它优
先于上面列出的 'results' 值. 例如:
</p>
<pre class="example">
#+BEGIN_SRC emacs-lisp :results html :wrap EXPORT markdown
"&lt;blink&gt;Welcome back to the 90's&lt;/blink&gt;"
#+END_SRC

#+RESULTS:
#+BEGIN_EXPORT markdown
&lt;blink&gt;Welcome back to the 90's&lt;/blink&gt;
#+END_EXPORT
</pre>

<p>
<b>Handling</b>
</p>

<p>
收集结果后的 Handling (处理)选项.
</p>

<dl class="org-dl">
<dt>'replace'</dt><dd>默认值,插入结果到 Org 缓冲区. 移除先前的结果.用例:
<code>:results output replace</code>.</dd>
<dt>'silent'</dt><dd>不将结果插入到 Org mode 缓冲区,但是将它们在 minibuffer 里输出. 用
例: <code>:results output silent</code></dd>
<dt>'none'</dt><dd>完全不处理结果. 不会插入到 Org mode 缓冲区也不会在 minibuffer 里输出.
用例: <code>:results none</code>.</dd>
<dt>'append'</dt><dd>将结果追加到 Org 缓冲区. 最近的结果在最下面. 不会移除之前的结果.用
例: <code>:results output append</code></dd>
<dt>'prepend'</dt><dd>将结果前置追加到 Org 缓冲区. 最近的结果在最上面. 不会移除之前的结
果.用例: <code>:results output prepend</code></dd>
</dl>


<p>
<b>Post-processing(后期处理)</b>
</p>
<hr />
<p>
'post' 头参数是用来从块执行里后处理结果的. 当 'post' 有任意值时, Org 将结果绑定
到 <code>*this*</code> 变量,以便方便的传递到 'var' 头参数规范(参见
<a href="#org0e36621">代码块的环境(Environment of a Code Block)</a>).  这让结果对其他代码块可用,或者甚至
是直接用于 Emacs Lisp 代码执行.
</p>

<p>
下面的两个例子说明了 'post' 头参数的作用:
</p>

<p>
第一个例子展示了如何使用 'post' 来附加一个 'ATTR_LATEX' 关键字.
</p>
<pre class="example">

#+NAME: attr_wrap
#+BEGIN_SRC sh :var data="" :var width="\\textwidth" :results output
  echo "#+ATTR_LATEX: :width $width"
  echo "$data"
#+END_SRC

#+HEADER: :file /tmp/it.png
#+BEGIN_SRC dot :post attr_wrap(width="5cm", data=*this*) :results drawer
  digraph{
          a -&gt; b;
          b -&gt; c;
          c -&gt; a;
  }
#+end_src

#+RESULTS:
:RESULTS:
#+ATTR_LATEX :width 5cm
[[file:/tmp/it.png]]
:END:
</pre>
<p>
第二个例子展示了在 'post' 中使用 'colnames' 头参数来在代码块之间传递数据.
</p>
<pre class="example">

#+NAME: round-tbl
#+BEGIN_SRC emacs-lisp :var tbl="" fmt="%.3f"
  (mapcar (lambda (row)
            (mapcar (lambda (cell)
                      (if (numberp cell)
                          (format fmt cell)
                        cell))
                    row))
          tbl)
#+end_src

#+BEGIN_SRC R :colnames yes :post round-tbl[:colnames yes](*this*)
  set.seed(42)
  data.frame(foo=rnorm(1))
#+END_SRC

#+RESULTS:
|   foo |
|-------|
| 1.371 |
</pre>

<p>
'post' 头参数就是将代码块的结果赋值给 <code>*this*</code> 变量,然后可以用这个变量来传递该代
码块的结果作为调用另外的代码块或是 Emacs Lisp 代码的参数.
</p>
</div>
</div>

<div id="outline-container-orgcbf0681" class="outline-3">
<h3 id="orgcbf0681"><span class="done DONE">DONE</span> 导出代码块(Exporting Code Blocks)</h3>
<div class="outline-text-3" id="text-orgcbf0681">
<p>
导出代码内容和(或)结果.
</p>

<p>
可以导出代码块的代码,代码块的执行结果,代码和代码块的执行结构,或是不导出. Org 默
认大多数语言导出代码. 对有些语言,例如 ditaa, Org 默认导出结果. 仅仅导出代码块的
主体,请参阅 <a href="#orge51ce3a">文字示例(Literal Examples)</a>. 想要有选择性的导出 Org 文档的子树,请查
阅 <a href="#org9c28439">导出(Exporting)</a>.
</p>

<p>
'exports' 头参数是用来指定 Org 文档的该部分是否导出为,例如, HTML 或是 LaTeX 格式.
</p>

<dl class="org-dl">
<dt>'code'</dt><dd>默认值. 代码的主体部分会被包含到导出的文件里.用例:
<code>:exports code</code>.</dd>
<dt>'results'</dt><dd>代码的执行结果被包含在导出的文件里.用例:
<code>:exports results</code>.</dd>
<dt>'both'</dt><dd>代码和运行结构都包含在导出的文件里.用例:
<code>:exports both</code>.</dd>
<dt>'none'</dt><dd>代码和执行结构都不会被包含在导出文件里. 代码是否执行完全取决于其他选
项.用例 : <code>:exports none</code></dd>
</dl>


<p>
要阻止 Org 执行代码块来加速导出过程,请使用头参数 <code>:eval never-export</code>. 为了更好
的安全性要阻止 Org 执行代码块,请将 <code>org-export-use-babel</code> 变量设置为 <code>nil</code>, 但是
请明白一点,就是头参数也将会无效.
</p>

<p>
批处理时关闭执行很有效. 例如, wikis 的标记语言,有着很高风险的未信任代码. 停止代
码块的执行同时也停止了代码块的所有头参数的执行.在某些情况下,这可能是不可取的. 所
以,在导出期间,要仅允许头参数的执行而不是源代码块的任何代码,请设置
<code>:eval never-export</code> 参考 <a href="#org81d9cb6">执行代码块(Evaluating Code Blocks)</a>.
</p>

<p>
在导出时 Org  不会执行注释子树里的代码块(参见 <a href="#org63f66ca">注释行(Comment Lines)</a>). 另一方面,
Org 确实会执行从导出中排除的子树的代码块
(参见 <a href="#org53ffc01">导出设置(Export Settings)</a> 部分)
</p>
</div>
</div>

<div id="outline-container-org3658bc6" class="outline-3">
<h3 id="org3658bc6"><span class="done DONE">DONE</span> 提取源代码(Extracting Source Code)</h3>
<div class="outline-text-3" id="text-org3658bc6">
<p>
创建纯源代码文件.
</p>

<p>
从代码块里提取源代码文学化编程的一个基本任务. Org 有特性能让该任务变得简单. 在文
学化编程术语里,创建的文档是由代码和说明编织而成的,在导出时,代码会被计算机执行.
Org 便于编织,维护,共享和导出文学化编程文档. Org 为提取源代码提供了广泛的自定
义选项.
</p>

<p>
当 Org 'tangle' 代码块时, 它会扩展,合并和转换它们. 然后 Org 按照选项的配置,将它
们重组为一个或多个分开的文件. 在这个 'tangling' 过程期间, Org 会扩展源代码里的变
量,解析所有 noweb 格式的引用(参见 <a href="#orgd2719d8">Noweb 引用语法(Noweb Reference Syntax)</a>.).
</p>

<p>
<b>头参数</b>
</p>
<hr />
<p>
<b>'tangle' 头参数指定了代码块是否被导出到源文件.</b>
</p>

<dl class="org-dl">
<dt>'yes'</dt><dd>导出代码块到源文件. 源文件的文件名从 Org 文件的文件名里派生, 文件扩展
名从源代码的语言标识符里派生. 示例: <code>:tangle yes</code>.</dd>
<dt>'no'</dt><dd>默认值. 不会提取源代码文件中的代码.</dd>

<dt>FILENAME</dt><dd>文件名.导出代码块到源文件,其文件名从传递给 'tangle' 头参数的任意字
符串里派生. Org 将文件名导出为相对于 Org 文件位置的目录.
示例: <code>:tangle FILENAME</code></dd>
</dl>


<p>
<b>如果目录不存在, 'mkdirp' 头参数会为 'tanngled' 的文件创建创建父目录. 'yes' 值启
用目录创建,而 'no' 禁用目录创建.</b>
</p>

<p>
<b>'comments' 头参数控制向 tangled 文件里插入注释. 这些注释会在代码块里任何已存在
的注释的上面和下面.</b>
</p>

<pre class="example">
python 代码块:
#+begin_src python :comments link :tangle deleteme.py
print("hello") # this is a comment
#+end_src

deleteme.py 文件内容:
# [[file:orgmode.org::*提取源代码(Extracting Source Code)][提取源代码(Extracting Source Code):1]]
print("hello") # this is a comment
# 提取源代码(Extracting Source Code):1 ends here
</pre>

<dl class="org-dl">
<dt>'no'</dt><dd>默认值.在 tangling 期间不插入任何注释.</dd>
<dt>'link'</dt><dd>用注释包装代码块.包括指向 Org 文件中代码 tangle 的位置的链接.</dd>
<dt>'yes'</dt><dd>为了向后兼容而保留.和 'link' 一样.</dd>
<dt>'org'</dt><dd>Org 文件里最近的标题文本会被作为注释插入.插入的确切文本时从代码块的前
导内容里选取的.经过测试,基本上就是把代码块到离得最近的标题之间的内容都作为注释
插入了.</dd>
<dt>'both'</dt><dd>同时包含 'link' 和 'org' 选项.</dd>
<dt>'noweb'</dt><dd>包含 'link' 选项,扩展 noweb 引用
(参见 <a href="#orgd2719d8">Noweb 引用语法(Noweb Reference Syntax)</a>), 并将它们包装在代码块主体内部的
链接注释里.就是扩展 noweb 引用并将它们添加到 link 值生成的链接注释里.</dd>
</dl>


<p>
<b>'padline' 头参数控制换行的插入以便填充 tangled 文件里的源代码.</b>
</p>
<dl class="org-dl">
<dt>'yes'</dt><dd>默认值. 在 tangled 文件的每个代码块之前和之后都插入一个换行.</dd>
<dt>'no'</dt><dd>不会插入换行来填充 'tangled' 代码块.</dd>
</dl>


<p>
<b>'shebang' 头参数可以将结果转变成可执行的脚本文件. 通过将其设置为一个字符串值--</b>
<b>例如, <code>:shebang "#!/bin/bash"</code>.Org 将该字符串作为代码块提取到的 tangle 文件的 第</b>
<b>一行插入. 然后 Org 打开 tangled 文件的可执行权限(file-mode 头参数好像也能做到类</b>
<b>似的功能.).</b>
</p>

<p>
<b>'tangle-mode' 通过 'set-file-modes' 来指定要为 tangled 文件设置什么权限.例如,要</b>
<b>使 tangled 文件只读,请使用 <code>:tangle-mode (identity o444)</code> 要让它可执行,请使用</b>
<b><code>:tangle-mode (identity #o755)</code> ,这也会覆盖 'shebang' 赋予的可执行权限. 当多个</b>
<b>源代码块使用不同且冲突的 'tangle-mode' 头参数 tangle 到一个文件时,Org 的行为是</b>
<b>不确定的.</b>
</p>

<p>
默认情况下, Org 在 tangling 期间会扩展代码块. 'no-expand' 头参数关闭了这样的扩展.请
注意 'org-babel-expand-src-block' 的扩展的一个副作用是也会将值(
参见<a href="#org0e36621">代码块的环境(Environment of a Code Block)</a> )赋予给变量. 扩展也会将 noweb 引
用替换成它们的目标(参见 <a href="#orgd2719d8">Noweb 引用语法(Noweb Reference Syntax)</a>). 因此,这个选项
的这些扩展中的部分可能会造成过早的赋值.这个选项仅仅对于 tangling 有区别. 它在导
出时没有效果,因为无论如何都必须扩展要执行的代码块.
</p>

<p>
<b>Functions</b>
</p>
<hr />

<dl class="org-dl">
<dt>'org-babel-tangle'</dt><dd>Tangle 当前文件. 绑定到快捷键 'C-c C-v t'. 带前缀参数使
用只会 tangle 当前代码块.</dd>
<dt>'org-babel-tangle-file'</dt><dd>选择要 tangle 的文件.绑定为快捷键 'C-c C-v f'.</dd>
</dl>


<p>
<b>Tangle hooks</b>
</p>
<hr />
<dl class="org-dl">
<dt>'org-babel-post-tangle-hook'</dt><dd>该钩子是从 'org-babel-tangle' tangle 的文件里
运行的, 它适合 tangled 文件里代码的后处理,编译和执行.</dd>
</dl>


<p>
<b>Jumping between code and Org</b>
</p>
<hr />
<p>
调试器通常将错误和信息连接回源代码. 但是对于 tangled 文件来说,我们希望连接回 Org
文件,而不是 tangled 源文件.为了达成这个额外的跳转, Org 使用
'org-babel-tangle-jump-to-org' 函数和两个额外的源代码块头参数:
</p>
<ol class="org-ol">
<li>将 'padline' 设置为 true ,着就是默认设置.</li>
<li>将 'comments' 设置为 'link', 这会使得 Org 插入指向 Org 文件的链接.</li>
</ol>

<p>
经过测试,设置好这两个参数后,在导出的源文件的代码部分(也就是 link 插入的注释的中
间代码部分,在插入的注释部分调用会提示不在 tangled 代码里)使用命令
'org-babel-tangle-jump-to-org' 会跳转回 Org 文件里 tangle 该代码的源代码块位置.
</p>
</div>
</div>

<div id="outline-container-orgc0e7e39" class="outline-3">
<h3 id="orgc0e7e39"><span class="done DONE">DONE</span> 语言(Languages)</h3>
<div class="outline-text-3" id="text-orgc0e7e39">
<p>
支持的代码块语言列表.
</p>

<p>
Org 支持几十种语言的代码块. 请查阅 Worg(社区驱动的 Org 文档)的特定语言的文档
(<a href="https://orgmode.org/worg/org-contrib/babel/languages/index.html">https://orgmode.org/worg/org-contrib/babel/languages/index.html</a>)
</p>

<p>
默认情况下,只有 Emacs Lisp 的代码启用了执行. 要启用或禁用其他语言,请使用 Emacs
的自定义界面或是通过下面展示的代码到初始化文件来自定义
'org-babel-load-languages' 变量.
</p>

<p>
在这个例子里, Emacs Lisp 禁用了执行, R 语言启用了执行.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . nil)
   (R . t)))
</pre>
</div>

<p>
请注意这不是唯一一种启用一个语言的方式. 当使用 'require' 语句加载时, Org 也能启
用语言. 例如,下面的代码启用了 Clojure 代码块的执行:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">require</span> '<span style="font-weight: bold; text-decoration: underline;">ob-clojure</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-org4c2c13b" class="outline-3">
<h3 id="org4c2c13b"><span class="done DONE">DONE</span> 编辑源代码(Editing Source Code)</h3>
<div class="outline-text-3" id="text-org4c2c13b">
<p>
对应语言的主模式编辑.
</p>

<p>
使用 <code>C-c '</code> 来编辑当前代码块. 它会打开一个新的主模式编辑缓冲区,其中包含有源代码
块的主体,为任何编辑做好了准备. 再次使用 <code>C-c '</code> 来关闭缓冲区并返回到 Org 缓冲区.
</p>

<p>
<code>C-x C-s</code> 保存缓冲区并更新 Org 缓冲区的内容. 设置
'org-edit-src-auto-save-idle-delay' 来在特定的空闲延迟时间后保存基础缓冲区. 设置
'org-edit-src-turn-on-auto-save' 以使用自动保存模式将此缓冲区自动保存到单独的文
件中.
</p>

<p>
在主模式下编辑源代码时, Org Src 副模式仍然保持激活状态. 它提供了下面描述的这些定
制化变量.有关更多的变量,请查看自定义组 'org-edit-structure'.
</p>

<dl class="org-dl">
<dt>'org-src-lang-modes'</dt><dd>如果有一个叫做 '&lt;LANG&gt;-mode' 的 Emacs 主模式存在,这里
的 &lt;LANG&gt; 是来自代码块头信息行的语言标识符, 那么该编辑缓冲区就使用这个主模式.使
用这个变量来随意将语言标识符映射到主模式.</dd>
<dt>'org-src-window-setup'</dt><dd>当新的编辑缓冲区创建时,用来指定 Emacs 窗口排列.</dd>
<dt>'org-src-preserve-indentation'</dt><dd>默认为 'nil'. 源代码会被缩进.这个缩进会应用
到导出和 tangling 期间,并且根据上下文的不同,可能会修改前导空格和制表符. 当为非
'nil' 值时,源代码会与最左边的列对其. 在导出或 tangling 期间不会修改任何行,这对
于空格敏感的语言来说非常有用,比如 Python 语言.</dd>
<dt>'org-src-ask-before-returning-to-edit-buffer'</dt><dd>当为 'nil' 时, Org 没有任何进
一步提示就返回编辑缓冲区.默认值会提示是否确认.</dd>
</dl>


<p>
将 'org-src-fontify-natively' 设置为非 'nil' 值来在 Org 缓冲区里开启原生代码美化.
代码的美化可以在展示页面上提供文本和代码的视觉分离. 要进一步自定义特定语言的
'org-block' 的外观,请自定义 'org-src-block-faces'. 下面的例子将常规块结构的背景
阴影化,并对 Python 和 Emacs Lisp 语言的源代码块着色.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">require</span> '<span style="font-weight: bold; text-decoration: underline;">color</span>)
(set-face-attribute 'org-block nil <span style="font-weight: bold;">:background</span>
                    (color-darken-name
                     (face-attribute 'default <span style="font-weight: bold;">:background</span>) 3))

(<span style="font-weight: bold;">setq</span> org-src-block-faces '((<span style="font-style: italic;">"emacs-lisp"</span> (<span style="font-weight: bold;">:background</span> <span style="font-style: italic;">"#EEE2FF"</span>))
                            (<span style="font-style: italic;">"python"</span> (<span style="font-weight: bold;">:background</span> <span style="font-style: italic;">"#E5FFB8"</span>))))

</pre>
</div>


<p>
这里就是说 'org-block' 设置所有块的基础外观, 而 'org-src-block-faces' 则可以为特
定语言设置外观.
</p>
</div>
</div>

<div id="outline-container-orgd2719d8" class="outline-3">
<h3 id="orgd2719d8"><span class="done DONE">DONE</span> Noweb 引用语法(Noweb Reference Syntax)</h3>
<div class="outline-text-3" id="text-orgd2719d8">
<p>
Org mode 里的文学化编程(Literate programming).
</p>

<p>
Noweb: <a href="https://en.wikipedia.org/wiki/Noweb">维基百科</a>
</p>
<blockquote>
<p>
Noweb is a literate programming tool, created in 1989–1999 by Norman Ramsey, and designed to be simple, easily extensible and language independent.
</p>
</blockquote>

<p>
源代码块可以包含指向其他源代码块的引用, 使用 noweb<sup><a id="fnr.86" class="footref" href="#fn.86">86</a></sup> 风格的语法:
</p>
<pre class="example">
&lt;&lt;CODE-BLOCK-ID&gt;&gt;
</pre>

<p>
这里的 CODE-BLOCK-ID 指向单个源代码块的 'NAME' 或共享相同 'noweb-ref' 头参数(参
见<a href="#org05436bf">使用头参数(Using Header Arguments)</a>)的一个或多个源代码块的集合.
Org 可以用被引用的一个或多个代码块的代码替换这些引用,或者,如果是用 'NAME' 命名的
单个源代码块,则使用该块的执行结果替换这些引用(这里确实没搞懂什么意思,实际测试是
使用的代码替换的引用,并没有使用执行的结果).
</p>

<p>
'noweb' 头参数控制 noweb 语法引用的扩展. 当源代码被执行,导出或 tangle 时,会发生
扩展.
</p>

<dl class="org-dl">
<dt>'no'</dt><dd>默认值. 在执行,tangling 或导出时不扩展代码块主体里的 noweb 语法引用.</dd>
<dt>'yes'</dt><dd>在执行, tangling 或导出时扩展代码块主体里的 noweb 语法引用.</dd>
<dt>'tangle'</dt><dd>在 tangling 时扩展代码块主体里的 noweb 语法引用. 在执行和导出时不
扩展.</dd>
<dt>'no-export'</dt><dd>在执行和 tangling 时扩展代码块主体里的 noweb 语法引用. 在导出时
不扩展.</dd>
<dt>'strip-export'</dt><dd>在执行或 tangling 之前扩展代码块主体里的 noweb 语法引用.在导
出时移除 noweb 语法引用.</dd>
<dt>'eval'</dt><dd>只在执行之前扩展代码块主体里的 noweb 语法引用.</dd>
</dl>


<p>
在最简单的情况下, 单个源代码块的内容被插入到其他块中.因此,下面的例子里:
</p>
<pre class="example">
#+NAME: initialization
#+BEGIN_SRC emacs-lisp
  (setq sentence "Never a foot too far, even.")
#+END_SRC

#+BEGIN_SRC emacs-lisp :noweb yes
  &lt;&lt;initialization&gt;&gt;
  (reverse sentence)
#+END_SRC

</pre>
<p>
第二个代码块会被扩展成:
</p>
<pre class="example">
#+BEGIN_SRC emacs-lisp :noweb yes
  (setq sentence "Never a foot too far, even.")
  (reverse sentence)
#+END_SRC
</pre>

<p>
你也可以包含共享公共 'noweb-ref' 头参数的多个代码块的内容,该参数可以在文件,子树
或是代码块级别设置. 在下面显示的例子里,每个块里源代码的主体被提取出来,以便在
tangle 时连结到一个纯代码文件中.
</p>

<pre class="example">
#+BEGIN_SRC sh :tangle yes :noweb yes :shebang #!/bin/sh
  &lt;&lt;fullest-disk&gt;&gt;
#+END_SRC
* the mount point of the fullest disk
  :PROPERTIES:
  :header-args: :noweb-ref fullest-disk
  :END:

** query all mounted disks
#+BEGIN_SRC sh
  df \
#+END_SRC

** strip the header row
#+BEGIN_SRC sh
  |sed '1d' \
#+END_SRC

** output mount point of fullest disk
#+BEGIN_SRC sh
  |awk '{if (u &lt; +$5) {u = +$5; m = $6}} END {print m}'
#+END_SRC
</pre>
<p>
上面的例子里,在上级标题设置了 :noweb 头参数,因此其所有子树的代码块都共享这个公共
的 :noweb 头参数.
</p>

<p>
默认情况下,一个换行符会将每个 noweb 引用连结分隔开. 要使用不同的分隔符,请编辑
'noweb-sep' 头参数.
</p>

<p>
又或者,Org 可以包含单个代码块的执行结果而不是其主体代码.当括号(可能包含参数)附加
到代码块名称后,将对其进行执行操作,如下所示.
</p>
<pre class="example">
&lt;&lt;NAME(optional arguments)&gt;&gt;
</pre>

<p>
请注意,在这种情况下,需要使用 "name" 关键字设置代码块名称; 当需要执行时
'noweb-ref' 设置的引用不会起作用.
</p>

<p>
下面是一个例子,演示了当 noweb 样式的引用使用和不使用括号时导出内容如何变化.
</p>
<pre class="example">
#+NAME: some-code
#+BEGIN_SRC python :var num=0 :results output :exports none
  print(num*10)
#+END_SRC
</pre>
<p>
不使用括号,下面这个代码块:
</p>
<pre class="example">
#+BEGIN_SRC text :noweb yes
     &lt;&lt;some-code&gt;&gt;
#+END_SRC
</pre>
<p>
会被扩展为:
</p>
<pre class="example">
print(num*10)
</pre>

<p>
使用括号:
</p>
<pre class="example">
#+BEGIN_SRC text :noweb yes
&lt;&lt;some-code(num=10)&gt;&gt;
#+END_SRC
</pre>
<p>
会被扩展为:
</p>
<pre class="example">
100
</pre>

<p>
Noweb 插入尊重出现在 noweb 语法之前的前缀字符.该行为如下例所示. 因为
<code>&lt;&lt;example&gt;&gt;</code> noweb 引用出现在 SQL 注释语法之后,所以扩展的 noweb 引用的每一行都
被注释了
</p>

<p>
已有代码块:
</p>
<pre class="example">

#+NAME: example
#+BEGIN_SRC text
  this is the
  multi-line body of example
#+END_SRC
</pre>
<p>
该代码块:
</p>
<pre class="example">
#+BEGIN_SRC sql :noweb yes
 ---&lt;&lt;example&gt;&gt;
#+END_SRC
</pre>
<p>
会扩展为:
</p>
<pre class="example">
#+BEGIN_SRC sql :noweb yes
 ---this is the
 ---multi-line body of example
#+END_SRC
</pre>

<p>
因为这种改变不会影响没有换行的 noweb 替换文本,所以内联 noweb 引用时可用.
</p>

<p>
该特性也可以被用来做导出的代码片段的缩进管理.
</p>

<p>
已有:
</p>
<pre class="example">
#+NAME: if-true
#+BEGIN_SRC python :exports none
  print('do things when true')
#+end_src

#+name: if-false
#+begin_src python :exports none
  print('do things when false')
#+end_src
</pre>

<p>
下面的代码块:
</p>
<pre class="example">

#+begin_src python :noweb yes :results output
  if true:
      &lt;&lt;if-true&gt;&gt;
  else:
      &lt;&lt;if-false&gt;&gt;
#+end_src
</pre>

<p>
会被扩展成:
</p>
<pre class="example">
if true:
    print('do things when true')
else:
    print('do things when false')
</pre>

<p>
当对一个源代码块扩展的输出有疑问时,你可以使用下面的命令预览结果:
</p>
<dl class="org-dl">
<dt>'C-c C-v v' 或 'C-c C-v C-v' &#x2013; (org-babel-expand-src-block)</dt><dd>根据其头参数扩
展当前源代码块,并在一个预览缓冲区里弹出结果.</dd>
</dl>
</div>
</div>

<div id="outline-container-org6769dc0" class="outline-3">
<h3 id="org6769dc0"><span class="done DONE">DONE</span> Babel 库(Library of Babel)</h3>
<div class="outline-text-3" id="text-org6769dc0">
<p>
使用并贡献有用的代码块库.
</p>

<p>
"Library of Babel" 是代码块的一个集合. 类似于一个函数库,这些代码块可以从其他的
Org 文件里调用. Worg 上提供了一组有用的代码块的集合
(<a href="https://orgmode.org/worg/library-of-babel.html">https://orgmode.org/worg/library-of-babel.html</a>). 对于远程代码块的执行语法,请参
阅 <a href="#org81d9cb6">执行代码块(Evaluating Code Blocks)</a>.
</p>

<p>
对于任何想向库中添加代码的用户,请先将代码保存在 Org 文件的常规代码块中,然后使用
'org-babel-lob-ingest' 加载该 Org 文件(该函数绑定为 'C-c C-v i')
</p>
</div>
</div>

<div id="outline-container-org3ced5bc" class="outline-3">
<h3 id="org3ced5bc"><span class="done DONE">DONE</span> 快捷键绑定和有用的功能(Key bindings and Useful Functions)</h3>
<div class="outline-text-3" id="text-org3ced5bc">
<p>
快速处理代码块.
</p>

<p>
许多常见的 Org mode 快捷键序列会根据上下文重新绑定.
</p>

<p>
在代码块里激活的快捷键:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Key binding</th>
<th scope="col" class="org-left">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">‘C-c C-c’</td>
<td class="org-left">‘org-babel-execute-src-block’</td>
</tr>

<tr>
<td class="org-left">‘C-c C-o’</td>
<td class="org-left">‘org-babel-open-src-block-result’</td>
</tr>

<tr>
<td class="org-left">‘M-&lt;UP&gt;’</td>
<td class="org-left">‘org-babel-load-in-session’</td>
</tr>

<tr>
<td class="org-left">‘M-&lt;DOWN&gt;’</td>
<td class="org-left">‘org-babel-pop-to-session’</td>
</tr>
</tbody>
</table>

<p>
在 Org mode 缓冲区里激活的快捷键:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Key binding</th>
<th scope="col" class="org-left">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">‘C-c C-v p’ or ‘C-c C-v C-p’</td>
<td class="org-left">‘org-babel-previous-src-block’</td>
</tr>

<tr>
<td class="org-left">‘C-c C-v n’ or ‘C-c C-v C-n’</td>
<td class="org-left">‘org-babel-next-src-block’</td>
</tr>

<tr>
<td class="org-left">‘C-c C-v e’ or ‘C-c C-v C-e’</td>
<td class="org-left">‘org-babel-execute-maybe’</td>
</tr>

<tr>
<td class="org-left">‘C-c C-v o’ or ‘C-c C-v C-o’</td>
<td class="org-left">‘org-babel-open-src-block-result’</td>
</tr>

<tr>
<td class="org-left">‘C-c C-v v’ or ‘C-c C-v C-v’</td>
<td class="org-left">‘org-babel-expand-src-block’</td>
</tr>

<tr>
<td class="org-left">‘C-c C-v u’ or ‘C-c C-v C-u’</td>
<td class="org-left">‘org-babel-goto-src-block-head’</td>
</tr>

<tr>
<td class="org-left">‘C-c C-v g’ or ‘C-c C-v C-g’</td>
<td class="org-left">‘org-babel-goto-named-src-block’</td>
</tr>

<tr>
<td class="org-left">‘C-c C-v r’ or ‘C-c C-v C-r’</td>
<td class="org-left">‘org-babel-goto-named-result’</td>
</tr>

<tr>
<td class="org-left">‘C-c C-v b’ or ‘C-c C-v C-b’</td>
<td class="org-left">‘org-babel-execute-buffer’</td>
</tr>

<tr>
<td class="org-left">‘C-c C-v s’ or ‘C-c C-v C-s’</td>
<td class="org-left">‘org-babel-execute-subtree’</td>
</tr>

<tr>
<td class="org-left">‘C-c C-v d’ or ‘C-c C-v C-d’</td>
<td class="org-left">‘org-babel-demarcate-block’</td>
</tr>

<tr>
<td class="org-left">‘C-c C-v t’ or ‘C-c C-v C-t’</td>
<td class="org-left">‘org-babel-tangle’</td>
</tr>

<tr>
<td class="org-left">‘C-c C-v f’ or ‘C-c C-v C-f’</td>
<td class="org-left">‘org-babel-tangle-file’</td>
</tr>

<tr>
<td class="org-left">‘C-c C-v c’ or ‘C-c C-v C-c’</td>
<td class="org-left">‘org-babel-check-src-block’</td>
</tr>

<tr>
<td class="org-left">‘C-c C-v j’ or ‘C-c C-v C-j’</td>
<td class="org-left">‘org-babel-insert-header-arg’</td>
</tr>

<tr>
<td class="org-left">‘C-c C-v l’ or ‘C-c C-v C-l’</td>
<td class="org-left">‘org-babel-load-in-session’</td>
</tr>

<tr>
<td class="org-left">‘C-c C-v i’ or ‘C-c C-v C-i’</td>
<td class="org-left">‘org-babel-lob-ingest’</td>
</tr>

<tr>
<td class="org-left">‘C-c C-v I’ or ‘C-c C-v C-I’</td>
<td class="org-left">‘org-babel-view-src-block-info’</td>
</tr>

<tr>
<td class="org-left">‘C-c C-v z’ or ‘C-c C-v C-z’</td>
<td class="org-left">‘org-babel-switch-to-session-with-code’</td>
</tr>

<tr>
<td class="org-left">‘C-c C-v a’ or ‘C-c C-v C-a’</td>
<td class="org-left">‘org-babel-sha1-hash’</td>
</tr>

<tr>
<td class="org-left">‘C-c C-v h’ or ‘C-c C-v C-h’</td>
<td class="org-left">‘org-babel-describe-bindings’</td>
</tr>

<tr>
<td class="org-left">‘C-c C-v x’ or ‘C-c C-v C-x’</td>
<td class="org-left">‘org-babel-do-key-sequence-in-edit-buffer’</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgc7afcff" class="outline-3">
<h3 id="orgc7afcff"><span class="done DONE">DONE</span> 批处理执行(Batch Execution)</h3>
<div class="outline-text-3" id="text-orgc7afcff">
<p>
从命令行调用函数.
</p>

<p>
Org mode 特性,包括了可以从命令行调用处理源代码的功能. 这使得能够构建批处理的
shell 脚本,运行自动化系统任务和扩展 Org mode 的作用.
</p>

<p>
示例脚本显示了使用 'org-babel-tangle' 对多个文件的批处理.
</p>

<pre class="example">
#!/bin/sh
# Tangle files with Org mode
#
emacs -Q --batch --eval "
    (progn
      (require 'ob-tangle)
      (dolist (file command-line-args-left)
        (with-current-buffer (find-file-noselect file)
          (org-babel-tangle))))
  " "$@"
</pre>

<p>
该 shell 脚本执行时会对其后面跟着的所有文件执行 org-babel-tangle 操作.
这个严格来说算是 shell 脚本吧. <code>"$@"</code> 传递所有命令调用时传递的参数, 这怎么说呢,
就像是执行 bash 脚本,而 bash 脚本的内容又是执行 emacs 命令,emacs 命令的内容是执
行一系列 Emacs Lisp 代码. 从里往外分析就是 Emacs 本身能执行直接调用 Emacs Lisp
代码的操作,所以我们编写了一个 shell 脚本来把参数传递给 Emacs Lisp 代码来执行.
</p>

<p>
这样的套路用在其他语言好像也行.本质就是多个程序代码(指令)的嵌套传参和调用嘛.
</p>
</div>
</div>
</div>


<div id="outline-container-orgfdff793" class="outline-2">
<h2 id="orgfdff793"><span class="todo TODO">TODO</span> 杂项(Miscellaneous)</h2>
<div class="outline-text-2" id="text-orgfdff793">
</div>
<div id="outline-container-org7a8ca1a" class="outline-3">
<h3 id="org7a8ca1a">Completion</h3>
</div>
<div id="outline-container-orge6e17fa" class="outline-3">
<h3 id="orge6e17fa">Conflicts</h3>
</div>

<div id="outline-container-orgeffbbc5" class="outline-3">
<h3 id="orgeffbbc5">Protocols</h3>
</div>

<div id="outline-container-org89bb441" class="outline-3">
<h3 id="org89bb441">转义字符(Escape Character)</h3>
</div>
<div id="outline-container-org5bcee50" class="outline-3">
<h3 id="org5bcee50">结构模板(Structure Templates)</h3>
<div class="outline-text-3" id="text-org5bcee50">
<p>
只使用少许按键,就能插入诸如 "#+BEGIN_SRC"&#x2026;"#+END_SRC" 的空白结构块,或是将已有
文本包含在这样的结构块中,是可行的.
</p>

<dl class="org-dl">
<dt><code>C-c C-, -- (org-insert-structure-template)</code></dt><dd>提示输入一个块结构的类型,并将
其插入到光标位置处.如果有选中区域,则将选中区域包含在块里. 首先,会提示用户输入
快捷键,这些快捷键用来从下面的变量里寻找一个结构类型. 如果输入的按键是 <code>&lt;TAB&gt;</code>,
<code>&lt;RET&gt;</code>, 或是 <code>&lt;SPC&gt;</code>, 则改为提示用户输入一个块类型.</dd>
</dl>


<p>
可用的结构类型定义在变量 <code>org-structure-template-alist</code> 里,添加或修改值请查看其
文档字符串.
</p>

<p>
Org Tempo 会将片段扩展为定义在 <code>org-structure-template-alist</code> 和
<code>org-tempo-keywords-alist</code> 里的结构. 例如, <code>&lt; s &lt;TAB&gt;</code> 会创建一个代码块结构.通过
自定义 <code>org-modules</code> 变量或是将 <code>(require 'org-tempo)</code> 添加到你的 Emacs 初始化文
件中<sup><a id="fnr.87" class="footref" href="#fn.87">87</a></sup> 可以启用这一功能.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">快捷键</td>
<td class="org-left">块结构</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">‘a’</td>
<td class="org-left">‘#+BEGIN_EXPORT ascii’ &#x2026; ‘#+END_EXPORT’</td>
</tr>

<tr>
<td class="org-left">‘c’</td>
<td class="org-left">‘#+BEGIN_CENTER’ &#x2026; ‘#+END_CENTER’</td>
</tr>

<tr>
<td class="org-left">‘C’</td>
<td class="org-left">‘#+BEGIN_COMMENT’ &#x2026; ‘#+END_COMMENT’</td>
</tr>

<tr>
<td class="org-left">‘e’</td>
<td class="org-left">‘#+BEGIN_EXAMPLE’ &#x2026; ‘#+END_EXAMPLE’</td>
</tr>

<tr>
<td class="org-left">‘E’</td>
<td class="org-left">‘#+BEGIN_EXPORT’ &#x2026; ‘#+END_EXPORT’</td>
</tr>

<tr>
<td class="org-left">‘h’</td>
<td class="org-left">‘#+BEGIN_EXPORT html’ &#x2026; ‘#+END_EXPORT’</td>
</tr>

<tr>
<td class="org-left">‘l’</td>
<td class="org-left">‘#+BEGIN_EXPORT latex’ &#x2026; ‘#+END_EXPORT’</td>
</tr>

<tr>
<td class="org-left">‘q’</td>
<td class="org-left">‘#+BEGIN_QUOTE’ &#x2026; ‘#+END_QUOTE’</td>
</tr>

<tr>
<td class="org-left">‘s’</td>
<td class="org-left">‘#+BEGIN_SRC’ &#x2026; ‘#+END_SRC’</td>
</tr>

<tr>
<td class="org-left">‘v’</td>
<td class="org-left">‘#+BEGIN_VERSE’ &#x2026; ‘#+END_VERSE’</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org915f469" class="outline-3">
<h3 id="org915f469">代码执行安全性(Code Evaluation Security)</h3>
</div>
<div id="outline-container-org5c13de5" class="outline-3">
<h3 id="org5c13de5">缓冲区内设置(In-buffer Settings)</h3>
</div>
</div>

<div id="outline-container-org15ee510" class="outline-2">
<h2 id="org15ee510"><span class="todo TODO">TODO</span> Hacking</h2>
<div class="outline-text-2" id="text-org15ee510">
</div>
<div id="outline-container-org70fc20b" class="outline-3">
<h3 id="org70fc20b">Dynamic Blocks</h3>
</div>
<div id="outline-container-orge6a66a0" class="outline-3">
<h3 id="orge6a66a0">Adding Hyperlink Types</h3>
</div>
</div>
<div id="outline-container-org7a2c496" class="outline-2">
<h2 id="org7a2c496"><span class="todo TODO">TODO</span> History and Acknowledgments</h2>
</div>
<div id="outline-container-org5913762" class="outline-2">
<h2 id="org5913762"><span class="todo TODO">TODO</span> GNU Free Documentation License</h2>
</div>
<div id="outline-container-orga6c95c7" class="outline-2">
<h2 id="orga6c95c7"><span class="todo TODO">TODO</span> Main Index</h2>
</div>
<div id="outline-container-orge3eae6a" class="outline-2">
<h2 id="orge3eae6a"><span class="todo TODO">TODO</span> Key Index</h2>
</div>
<div id="outline-container-orgcfc06ac" class="outline-2">
<h2 id="orgcfc06ac"><span class="todo TODO">TODO</span> Command and Function Index</h2>
</div>
<div id="outline-container-org74c6950" class="outline-2">
<h2 id="org74c6950"><span class="todo TODO">TODO</span> Variable Index</h2>
</div>
<div id="outline-container-org3d187b4" class="outline-2">
<h2 id="org3d187b4"><span class="todo TODO">TODO</span> 正则表达式(Regular Expressions)</h2>
</div>

<div id="outline-container-orgf8101e2" class="outline-2">
<h2 id="orgf8101e2"><span class="todo TODO">TODO</span> Unfinished task</h2>
<div class="outline-text-2" id="text-orgf8101e2">
<p>
除了 TODO Item 一节,其他带TODO 文本的地方都是许多需要修改引用或脚注的地方.
</p>
</div>
</div>
<div id="outline-container-org0c42067" class="outline-2">
<h2 id="org0c42067"><span class="todo TODO">TODO</span> Questions &amp; Answers</h2>
<div class="outline-text-2" id="text-org0c42067">
</div>
<div id="outline-container-orgb750e15" class="outline-3">
<h3 id="orgb750e15">orgmode '#STARTUP: hideblocks' doesn't work</h3>
<div class="outline-text-3" id="text-orgb750e15">
<ul class="org-ul">
<li>description:
org version: 9.4.4
emacs version: 27.2
OS: Linux kamisama-20e0a013cd 5.10.102-1-MANJARO #1 SMP PREEMPT Wed Feb 23 14:44:40 UTC 2022 x86_64 GNU/Linux</li>
<li><p>
answer:
org 9.4 增加了一个新的变量 <code>org-startup-folded</code> 用开控制Orgmode的显示设置.
non-nil 表示orgmode 会使用概述模式打开文件.
也可以在每个文件里用 in-buffer 设置:
</p>
<pre class="example">
#+STARTUP: fold              (or ‘overview’, this is equivalent)
#+STARTUP: nofold            (or ‘showall’, this is equivalent)
#+STARTUP: content
#+STARTUP: showeverything
</pre>
<p>
<del>这个设置会覆盖块结构的折叠设置.所以想要使用折叠块结构的设置,需要这两个设置</del>
<del>一起使用: <code>#+STARTUP: nofold hideblocks</code></del>
当然,你也可以把它设置为 nil 那么它就不会影响 org-hide-block-startup 的设置
了,但是实际上呢,把它设置为 fold ,那么代码块连带着所有的层级结构都会默认初始
为折叠状态.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">setq</span> org-startup-folded nil)
</pre>
</div>
<p>
当按照上面代码设置了之后, <code>#+STARTUP: hideblocks</code> 就能正常生效了.
</p></li>
</ul>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">搜索的实际行为取决于变量 <code>org-link-search-must-match-exact-headline</code> 的值. 如果该值为 <code>nil</code> 则进行模糊文本搜索.如果是 <code>t</code> ,则只匹配标题,忽略空格和统计cookies. 如果值是 <code>query-to-create</code> ,则搜索准确的标题,如果未找到,则询问用户是否创建该标题.</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">注意,你不是必须使用这个命
令插入链接,Org 的链接时纯文本,你可以直接键入或粘贴他们到缓冲区里.使用这个命
令,链接会自动用双括号包围,并且你会被要求输入可选的描述性文本</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">在插入一个保
存的链接后,该链接会从保存的链接里移除.要使它保留在列表里以便随后使用,需要加
上三个 <code>C-u</code> 前缀参数调用 <code>C-c C-l</code> 或者配置选项
<code>org-link-keep-stored-after-insertion</code> .</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <div class="footpara"><p class="footpara">这在方法 <code>org-link-parameters</code> 定义的链接属性设置为 <code>:complete</code> 时生
效</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5">5</a></sup> <div class="footpara"><p class="footpara">查看变量 ~org-link-use-indirect-buffer-for-internals</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6">6</a></sup> <div class="footpara"><p class="footpara">为了向后兼容,行号也可跟在单个冒号之
后</p></div></div>

<div class="footdef"><sup><a id="fn.7" class="footnum" href="#fnr.7">7</a></sup> <div class="footpara"><p class="footpara">当然,你可以创建一个只包含TODO
项目的长列表的文件,但这不是必须的</p></div></div>

<div class="footdef"><sup><a id="fn.8" class="footnum" href="#fnr.8">8</a></sup> <div class="footpara"><p class="footpara">改变变量 <code>org-todo-keywords</code> 只会在缓冲区重启Org mode 之后生效.</p></div></div>

<div class="footdef"><sup><a id="fn.9" class="footnum" href="#fnr.9">9</a></sup> <div class="footpara"><p class="footpara">在agenda
缓冲区里使用 t 命令也生效</p></div></div>

<div class="footdef"><sup><a id="fn.10" class="footnum" href="#fnr.10">10</a></sup> <div class="footpara"><p class="footpara">除了 '@','^'和'!'的所有字符都可以作为选择字符,因为这些
字符在这里有特殊含义</p></div></div>

<div class="footdef"><sup><a id="fn.11" class="footnum" href="#fnr.11">11</a></sup> <div class="footpara"><p class="footpara">查看变量
<code>org-fast-tag-selection-include-todo</code> 文档,它允许你通过标签接口(见 Setting
Tags) 改变待办事项的状态,如果你喜欢把这两个概念混着用.注意,这意味着你要提供
两组独一无二的关键字</p></div></div>

<div class="footdef"><sup><a id="fn.12" class="footnum" href="#fnr.12">12</a></sup> <div class="footpara"><p class="footpara">只有在访问一个文件并激活
Org mode 之后, Org mode 才会解析这些行.光标在 <code>#+</code> 开头的行上时,使用 <code>C-c C-c</code>
只是为当前缓冲区重启 Org mode</p></div></div>

<div class="footdef"><sup><a id="fn.13" class="footnum" href="#fnr.13">13</a></sup> <div class="footpara"><p class="footpara">相应的缓冲区内设置是: <code>#+STARTUP: logdone</code></p></div></div>

<div class="footdef"><sup><a id="fn.14" class="footnum" href="#fnr.14">14</a></sup> <div class="footpara"><p class="footpara">相应的缓冲区内设置是: <code>#+STARTUP: lognotedone</code></p></div></div>

<div class="footdef"><sup><a id="fn.15" class="footnum" href="#fnr.15">15</a></sup> <div class="footpara"><p class="footpara">参见变量 <code>org-log-states-order-reversed</code></p></div></div>

<div class="footdef"><sup><a id="fn.16" class="footnum" href="#fnr.16">16</a></sup> <div class="footpara"><p class="footpara">注意,这个 LOGBOOK 抽屉
在 agenda 视图里按 <code>&lt;SPC&gt;</code> 是不会被折叠的,要使用 <code>C-u &lt;SPC&gt;</code> 才行.</p></div></div>

<div class="footdef"><sup><a id="fn.17" class="footnum" href="#fnr.17">17</a></sup> <div class="footpara"><p class="footpara">在你同时使用了 <code>org-log-done</code> 和
状态改变记录时,Org mode 可能会记录两个时间戳.但是,Org mode 不会提示输入两条
笔记:如果你同时使用了两种配置,状态变化的笔记优先,并会取消完成状态的笔记</p></div></div>

<div class="footdef"><sup><a id="fn.18" class="footnum" href="#fnr.18">18</a></sup> <div class="footpara"><p class="footpara">另见选项 <code>org-priority-start-cycle-with-default</code></p></div></div>

<div class="footdef"><sup><a id="fn.19" class="footnum" href="#fnr.19">19</a></sup> <div class="footpara"><p class="footpara">让子任务排除在全局待办事项之
外,请参见选项 <code>org-agenda-todo-list-sublevels</code></p></div></div>

<div class="footdef"><sup><a id="fn.20" class="footnum" href="#fnr.20">20</a></sup> <div class="footpara"><p class="footpara">描述列表除外.但你可以通过相应的更改
<code>org-list-automatic-rules</code> 来支持它.</p></div></div>

<div class="footdef"><sup><a id="fn.21" class="footnum" href="#fnr.21">21</a></sup> <div class="footpara"><p class="footpara">如果你想
这些 cookie 计算该 cookie 之下的所有复选框,而不仅仅是直接子节点的复选框,你可
以设置变量 <code>org-hierarchical-checkbox-statistics</code></p></div></div>

<div class="footdef"><sup><a id="fn.22" class="footnum" href="#fnr.22">22</a></sup> <div class="footpara"><p class="footpara"><code>C-u C-c C-c</code> 在一个没有复选框的列表的第一个条目上使用时,会给剩余的列
表添加复选框.</p></div></div>

<div class="footdef"><sup><a id="fn.23" class="footnum" href="#fnr.23">23</a></sup> <div class="footpara"><p class="footpara">和所有缓冲区设置一样,使用 <code>C-c C-c</code>
来激活行中的任何更改.</p></div></div>

<div class="footdef"><sup><a id="fn.24" class="footnum" href="#fnr.24">24</a></sup> <div class="footpara"><p class="footpara">只有在搜索并不涉及复杂的测试时生效(包括属性,参见 <a href="#org20a9924">属性搜索(Property Searches)</a>).</p></div></div>

<div class="footdef"><sup><a id="fn.25" class="footnum" href="#fnr.25">25</a></sup> <div class="footpara"><p class="footpara">若要将这个默认列表扩展到 agenda 文件里使用的所有标签(参见
<a href="#org7296ea5">Agenda Views</a>),请自定义变量 <code>org-complete-tags-always-offer-all-agenda-tags</code></p></div></div>

<div class="footdef"><sup><a id="fn.26" class="footnum" href="#fnr.26">26</a></sup> <div class="footpara"><p class="footpara">快捷键会给没有设
置快捷键的标签自动分配</p></div></div>

<div class="footdef"><sup><a id="fn.27" class="footnum" href="#fnr.27">27</a></sup> <div class="footpara"><p class="footpara">如果有多
个摘要类型应用于同一属性,则根据第一个摘要属性计算父值.</p></div></div>

<div class="footdef"><sup><a id="fn.28" class="footnum" href="#fnr.28">28</a></sup> <div class="footpara"><p class="footpara">时期可以定义为持续时间,只要使用 <code>org-duration-units</code> 定义的单位, 例如 "3d 1h". 如果列中有任何值是这样的,则摘要也会表示为持续时间.</p></div></div>

<div class="footdef"><sup><a id="fn.29" class="footnum" href="#fnr.29">29</a></sup> <div class="footpara"><p class="footpara">请注意, <code>COLUMNS</code> 定义必须是定义在单
一行上,只有因为格式限制才会将其包裹在此处.</p></div></div>

<div class="footdef"><sup><a id="fn.30" class="footnum" href="#fnr.30">30</a></sup> <div class="footpara"><p class="footpara">贡献的包并不是 Emacs 的一部分,但是跟随Org 的主发行版一起
发布 &#x2013; 请访问 <a href="https://orgmode.org">https://orgmode.org</a></p></div></div>

<div class="footdef"><sup><a id="fn.31" class="footnum" href="#fnr.31">31</a></sup> <div class="footpara"><p class="footpara">Org 的日期格式受标准
ISO 8601 日期/时间格式的启发.要使用其他格式,请参考<a href="#orga990c7a">自定义时间格式(Custom time format)</a>. 当您自己键入日期时,日期名称是可选的.然而,为了阅读方便,Org 在插入或修改
任何日期时都会添加该日的名称.</p></div></div>

<div class="footdef"><sup><a id="fn.32" class="footnum" href="#fnr.32">32</a></sup> <div class="footpara"><p class="footpara">当使用标准的日记表达方法时,你需要特别关注参数的
顺序.该顺序严重依赖于变量 <code>calendar-date-style</code> .例如,要指定一个日期 December 12
2005,该调用看起来可能是: <code>(diary-date 12 1 2005)</code> 或 <code>(diary-date 1 12 2005)</code> 或
<code>(diary-date 2005 12 1)</code> ,使用哪种取决于变量的值.这一直是许多困惑的源头. Org
mode 用户可以使用这个方法的特殊版本,例如 <code>org-date</code> 或者 <code>org-anniversary</code> . 这些
特殊版本和对应的 <code>diary-</code> 方法一样工作,但是使用固定的 ISO 参数顺序(年,月,日),与
<code>calendar-date-style</code> 的值无关.</p></div></div>

<div class="footdef"><sup><a id="fn.33" class="footnum" href="#fnr.33">33</a></sup> <div class="footpara"><p class="footpara">参见变量
<code>org-read-date-prefer-future</code> . 你可以将该变量设置为符号 <code>time</code> 来将现在之前的日期视
为明天之后的日期.</p></div></div>

<div class="footdef"><sup><a id="fn.34" class="footnum" href="#fnr.34">34</a></sup> <div class="footpara"><p class="footpara">如果你不需要/不想要日历,请配置变量
<code>org-popup-calendar-for-date-prompt</code>.</p></div></div>

<div class="footdef"><sup><a id="fn.35" class="footnum" href="#fnr.35">35</a></sup> <div class="footpara"><p class="footpara">你也可以使用日历命令 <code>.</code> 来跳转到
今天的日期, 但是如果你在为时间戳插入一个小时规格, <code>.</code> 会在小时后插入一个点号.相
比之下, <code>C-.</code> 总是会跳转到今天的日期.</p></div></div>

<div class="footdef"><sup><a id="fn.36" class="footnum" href="#fnr.36">36</a></sup> <div class="footpara"><p class="footpara">如果你发现这令你分心,可以使用
<code>org-read-date-display-live</code> 来关闭实时展示.</p></div></div>

<div class="footdef"><sup><a id="fn.37" class="footnum" href="#fnr.37">37</a></sup> <div class="footpara"><p class="footpara">在任务被标记未完成之后仍然会被列
出在 agenda 视图里. 如果你不喜欢这样,请设置变量
<code>org-agenda-skip-scheduled-if-done</code></p></div></div>

<div class="footdef"><sup><a id="fn.38" class="footnum" href="#fnr.38">38</a></sup> <div class="footpara"><p class="footpara"><code>SCHEDULED</code> 和 <code>DEADLINE</code>
日期会被插入到标题正下方一行.请不要在这一行与标题之间插入任何文本</p></div></div>

<div class="footdef"><sup><a id="fn.39" class="footnum" href="#fnr.39">39</a></sup> <div class="footpara"><p class="footpara">相应的 <code>STARTUP</code> 选项是 <code>logredeadline</code>,
<code>lognoteredeadline</code> 和 <code>nologredeadline</code> .</p></div></div>

<div class="footdef"><sup><a id="fn.40" class="footnum" href="#fnr.40">40</a></sup> <div class="footpara"><p class="footpara">相应的 <code>STARTUP</code> 选项是 <code>logreschedule</code> , <code>lognotereschedule</code> 和
<code>nologreschedule</code> .</p></div></div>

<div class="footdef"><sup><a id="fn.41" class="footnum" href="#fnr.41">41</a></sup> <div class="footpara"><p class="footpara">然而,Org 不重复无效(未激活)的时间戳, 参见 <a href="#org1d92752">时间戳(Timestamps)</a></p></div></div>

<div class="footdef"><sup><a id="fn.42" class="footnum" href="#fnr.42">42</a></sup> <div class="footpara"><p class="footpara">要改变这一行为,你可以使用选项 <code>org-log-repeat</code>
或者使用 <code>STARTUP</code> 选项: <code>logrepeat</code> , <code>lognoterepeat</code> 和 <code>nologrepeat</code> . 使用
<code>lognoterepeat</code> ,会提示你输入一条笔记.</p></div></div>

<div class="footdef"><sup><a id="fn.43" class="footnum" href="#fnr.43">43</a></sup> <div class="footpara"><p class="footpara">计时功能
只会在少于30个星号的缩进的标题中进行.这是方法 <code>org-clock-sum</code> 中 <code>lmax</code> 的硬编码限
制.</p></div></div>

<div class="footdef"><sup><a id="fn.44" class="footnum" href="#fnr.44">44</a></sup> <div class="footpara"><p class="footpara">要在假设你在Emacs
之外也进行了此任务的情况下恢复计时,请使用 <code>(setq org-clock-persist t)</code> .</p></div></div>

<div class="footdef"><sup><a id="fn.45" class="footnum" href="#fnr.45">45</a></sup> <div class="footpara"><p class="footpara">要即时添加一个工作量估计,
将一个添加工作量估计的方法与钩子 <code>org-clock-in-prepare-hook</code> 挂钩.</p></div></div>

<div class="footdef"><sup><a id="fn.46" class="footnum" href="#fnr.46">46</a></sup> <div class="footpara"><p class="footpara">任
务的最近一次重置被 <code>LAST_REPEAT</code> 属性记录.</p></div></div>

<div class="footdef"><sup><a id="fn.47" class="footnum" href="#fnr.47">47</a></sup> <div class="footpara"><p class="footpara">另见变量 <code>org-clock-mode-line-total</code></p></div></div>

<div class="footdef"><sup><a id="fn.48" class="footnum" href="#fnr.48">48</a></sup> <div class="footpara"><p class="footpara">相应的缓冲区内设置是 <code>#+STARTUP: lognoteclock-out</code> .</p></div></div>

<div class="footdef"><sup><a id="fn.49" class="footnum" href="#fnr.49">49</a></sup> <div class="footpara"><p class="footpara">请注意在平面列表中求和层级数据的陷阱(参见 <a href="#org5423901">Agenda Column View</a>)</p></div></div>

<div class="footdef"><sup><a id="fn.50" class="footnum" href="#fnr.50">50</a></sup> <div class="footpara"><p class="footpara">注意,相应的 <code>STARTUP</code> 选项是 <code>logrefile,
  lognoterefile, nologrefile</code></p></div></div>

<div class="footdef"><sup><a id="fn.51" class="footnum" href="#fnr.51">51</a></sup> <div class="footpara"><p class="footpara">Org
提供四种不同日期/星期树类型的捕获的目标. 现在,Org 自动将这些转换成使用
<code>file+olp+datetree</code> , 并应用 <code>:time-prompt</code> 和 <code>:tree-type</code> 属性. 因为旧的目标用法
现在已被弃用,所以请你使用 <code>file+olp+datetree</code> 来重写你的日期/星期树类型的目标.</p></div></div>

<div class="footdef"><sup><a id="fn.52" class="footnum" href="#fnr.52">52</a></sup> <div class="footpara"><p class="footpara">日期树是一个大纲结构,年为最高级别,月或 ISO 格式的周作为次一级
别,日期作为最第层级. 这种树结构里也能使用标签.</p></div></div>

<div class="footdef"><sup><a id="fn.53" class="footnum" href="#fnr.53">53</a></sup> <div class="footpara"><p class="footpara">当文件名不是绝对路径时,Org 假定它是相对于
<code>org-directory</code> 路径的.</p></div></div>

<div class="footdef"><sup><a id="fn.54" class="footnum" href="#fnr.54">54</a></sup> <div class="footpara"><p class="footpara">如果你需要使用这些序列的字面值(原义),请使用一个反
斜杠将 <code>%</code> 转义.</p></div></div>

<div class="footdef"><sup><a id="fn.55" class="footnum" href="#fnr.55">55</a></sup> <div class="footpara"><p class="footpara">如果你定义了你自己的链接类型(参见
<a href="#orge6a66a0">Adding Hyperlink Types</a>) 任何你存储在 <code>org-store-link-props</code> 里的属性都能通过类似
的方式在捕获模版里访问到.</p></div></div>

<div class="footdef"><sup><a id="fn.56" class="footnum" href="#fnr.56">56</a></sup> <div class="footpara"><p class="footpara">这永远是另一个人,而不是用户. 请参阅变量 <code>org-link-from-user-regexp</code> .</p></div></div>

<div class="footdef"><sup><a id="fn.57" class="footnum" href="#fnr.57">57</a></sup> <div class="footpara"><p class="footpara">如果你将条目或 Org 文件从一个目录移动到另一个
目录,你可能想要配置 <code>org-attach-id-dir</code> 来包含绝对路径</p></div></div>

<div class="footdef"><sup><a id="fn.58" class="footnum" href="#fnr.58">58</a></sup> <div class="footpara"><p class="footpara">如果该变量的值不时一个列表,是一个单一的文件名,那么议程文
件的列表就会在这个外部文件中维护</p></div></div>

<div class="footdef"><sup><a id="fn.59" class="footnum" href="#fnr.59">59</a></sup> <div class="footpara"><p class="footpara">当使用调度器
(Dispatcher)时,在选择命令之前按 <code>&lt;</code> 会将命令作用范围限制在当前文件,并忽视
<code>org-agenda-files</code> 的值,直到调用下一个调度器命令前都生效.</p></div></div>

<div class="footdef"><sup><a id="fn.60" class="footnum" href="#fnr.60">60</a></sup> <div class="footpara"><p class="footpara">为了向后兼容,你也可以按 <code>1</code> 来限制
到当前缓冲区.</p></div></div>

<div class="footdef"><sup><a id="fn.61" class="footnum" href="#fnr.61">61</a></sup> <div class="footpara"><p class="footpara">为了向后兼容,你也可以按 <code>0</code> 来限制到当前区域/子树.</p></div></div>

<div class="footdef"><sup><a id="fn.62" class="footnum" href="#fnr.62">62</a></sup> <div class="footpara"><p class="footpara">为了向后兼容,通用前缀参数
<code>C-u</code> 会将所有待办条目列在议程之前.该功能已弃用,请使用专用的待办列表,或块议程(参
见<a href="#org10752d8">Block agenda</a>)</p></div></div>

<div class="footdef"><sup><a id="fn.63" class="footnum" href="#fnr.63">63</a></sup> <div class="footpara"><p class="footpara">例子里使用的 <code>org-anniversary</code> 变量就像 <code>diary-anniversary</code>
一样,但是参数顺序总是根据 ISO 来的,因此与 <code>calendar-date-style</code> 的值无关.</p></div></div>

<div class="footdef"><sup><a id="fn.64" class="footnum" href="#fnr.64">64</a></sup> <div class="footpara"><p class="footpara">你可以设置
<code>org-pretty-entities</code> 变量来将该行为设置为默认,或是使用 <code>STARTUP</code> 选项
<code>entitiespretty</code> 来在单个文件中启用此选项.</p></div></div>

<div class="footdef"><sup><a id="fn.65" class="footnum" href="#fnr.65">65</a></sup> <div class="footpara"><p class="footpara">该行为可以使用 <code>-</code> 导出设
置来禁用,参见 <a href="#org53ffc01">导出设置(Export Settings)</a> .</p></div></div>

<div class="footdef"><sup><a id="fn.66" class="footnum" href="#fnr.66">66</a></sup> <div class="footpara"><p class="footpara">LaTex 是一个基于 Donald E. Knuth 的 Tex 系统的宏系统.这里
描述的许多作为 <code>LaTex</code> 的功能实际上来自 <code>TeX</code> , 但是为了简化,这里模糊了两者的区
别.</p></div></div>

<div class="footdef"><sup><a id="fn.67" class="footnum" href="#fnr.67">67</a></sup> <div class="footpara"><p class="footpara">当使用 MathJax 时,只有 MathJax 能识别的环境会
  被处理. 当 dvipng, dvisvgm 或 ImageMagick 套件被用来创建图片时,任何 LaTeX
  环境都会被处理.</p></div></div>

<div class="footdef"><sup><a id="fn.68" class="footnum" href="#fnr.68">68</a></sup> <div class="footpara"><p class="footpara">这些分别可以在 <a href="http://sourceforge.net/projects/dvipng/">http://sourceforge.net/projects/dvipng/</a>
,<a href="http://dvisvgm.bplaced.net/">http://dvisvgm.bplaced.net/</a> 和 ImageMagic 套件里获取.通过相应地设置变量
<code>org-preview-latex-default-process</code> 来选择转换器.</p></div></div>

<div class="footdef"><sup><a id="fn.69" class="footnum" href="#fnr.69">69</a></sup> <div class="footpara"><p class="footpara">Org 模式有
一个方法来测试光标是否位于这样一个片段中,请查阅方法
<code>org-inside-LaTeX-fragment-p</code> 的文档.</p></div></div>

<div class="footdef"><sup><a id="fn.70" class="footnum" href="#fnr.70">70</a></sup> <div class="footpara"><p class="footpara">对于 HTML 后端,该行为自动
生效(需要1.34版本的 <code>htmlize.el</code> 包,你需要安装它).在 LaTeX 里美化代码块可以通过
listings 包(<a href="https://www.ctan.org/pkg/listings">https://www.ctan.org/pkg/listings</a>) 或者时 minted 包
(<a href="https://www.ctan.org/pkg/minted">https://www.ctan.org/pkg/minted</a>) 来实现. 更多细节请查阅 <code>org-latex-listings</code> 的
文档</p></div></div>

<div class="footdef"><sup><a id="fn.71" class="footnum" href="#fnr.71">71</a></sup> <div class="footpara"><p class="footpara">代码块里的源代码在交互和导出时也会被执行. 更多关于执行代码块的代
码请查看 <a href="#org1767335">处理源代码(Working with Source Code)</a>.</p></div></div>

<div class="footdef"><sup><a id="fn.72" class="footnum" href="#fnr.72">72</a></sup> <div class="footpara"><p class="footpara">添加 <code>-k</code> 到 <code>-n -r</code> 后
面会在为链接使用行号同时保留源代码里的标签,这在解释 Org mode 的示例代码时可能会
很有用.</p></div></div>

<div class="footdef"><sup><a id="fn.73" class="footnum" href="#fnr.73">73</a></sup> <div class="footpara"><p class="footpara">你也可以通过变量
<code>org-edit-fixed-width-region-mode</code> 来选择不同的模式</p></div></div>

<div class="footdef"><sup><a id="fn.74" class="footnum" href="#fnr.74">74</a></sup> <div class="footpara"><p class="footpara">Emacs 视什么为图片取决于
<code>image-file-name-extensions</code> 和 <code>image-file-name-regexps</code> 变量</p></div></div>

<div class="footdef"><sup><a id="fn.75" class="footnum" href="#fnr.75">75</a></sup> <div class="footpara"><p class="footpara">该变量可以在缓冲区里通过 <code>STARTUP</code> 选项
的 <code>inlineimages</code> 和 <code>noinlineimages</code> 来设置</p></div></div>

<div class="footdef"><sup><a id="fn.76" class="footnum" href="#fnr.76">76</a></sup> <div class="footpara"><p class="footpara">相应的缓冲区设置是: '#+STARTUP: fninline' 或
'#+STARTUP: nofninline'</p></div></div>

<div class="footdef"><sup><a id="fn.77" class="footnum" href="#fnr.77">77</a></sup> <div class="footpara"><p class="footpara">相应的缓冲区设置是 '#+STARTUP:
fninline' 或 '#+STARTUP: nofninline'</p></div></div>

<div class="footdef"><sup><a id="fn.78" class="footnum" href="#fnr.78">78</a></sup> <div class="footpara"><p class="footpara">因为逗号用来分隔参数,所以
参数里面的逗号必须要用反斜杠转义.所以,只有那些在逗号前面的反斜杠需要使用另一个反
斜杠转义.</p></div></div>

<div class="footdef"><sup><a id="fn.79" class="footnum" href="#fnr.79">79</a></sup> <div class="footpara"><p class="footpara">默认情
况下,Org 像 MathJax(<a href="https://www.mathjax.org">https://www.mathjax.org</a>) 推荐的一样从
cdnjs.com(<a href="https://cdnjs.com">https://cdnjs.com</a>) 里加载 MathJax.</p></div></div>

<div class="footdef"><sup><a id="fn.80" class="footnum" href="#fnr.80">80</a></sup> <div class="footpara"><p class="footpara">请注意,导出的公式是 HTML 文本
的一部分,并且如 <code>&lt;</code> <code>&gt;</code> 或 <code>&amp;</code> 这样的符号有特殊含义. 请查看 MathJax 和 LaTex 支持
(<a href="http://docs.mathjax.org/en/latest/tex.html#tex-and-latex-in-html-documents">http://docs.mathjax.org/en/latest/tex.html#tex-and-latex-in-html-documents</a>).</p></div></div>

<div class="footdef"><sup><a id="fn.81" class="footnum" href="#fnr.81">81</a></sup> <div class="footpara"><p class="footpara">请在 MathJax 手册(<a href="http://docs.mathjax.org">http://docs.mathjax.org</a>) 里查
看 Tex 和 LaTex 扩展(<a href="http://docs.mathjax.org/en/latest/tex.html#tex-extensions">http://docs.mathjax.org/en/latest/tex.html#tex-extensions</a>)
来了解扩展.</p></div></div>

<div class="footdef"><sup><a id="fn.82" class="footnum" href="#fnr.82">82</a></sup> <div class="footpara"><p class="footpara">如果
TODO 关键字和标签的类导致冲突,请使用变量 <code>org-html-todo-kwd-class-prefix</code> 和
<code>org-html-tag-class-prefix</code> 来让它们类名唯一.</p></div></div>

<div class="footdef"><sup><a id="fn.83" class="footnum" href="#fnr.83">83</a></sup> <div class="footpara"><p class="footpara">如果发布目录和源目录相同, <code>file.org</code> 会被导出为
<code>file.org.org</code> ,所以你可能不会想要这样做.</p></div></div>

<div class="footdef"><sup><a id="fn.84" class="footnum" href="#fnr.84">84</a></sup> <div class="footpara"><p class="footpara">选项
<code>org-babel-no-eval-on-ctrl-c-ctrl-c</code> 可以用来将代码执行从 <code>C-c C-c</code> 快捷键绑定中
移除</p></div></div>

<div class="footdef"><sup><a id="fn.85" class="footnum" href="#fnr.85">85</a></sup> <div class="footpara"><p class="footpara">实际上,当 <code>call_&lt;name&gt;()</code> 和 <code>src_&lt;lang&gt;{}</code> 结构出现在关键字里时,它们不会
被执行. 参见<a href="#org5c13de5">缓冲区内设置(In-buffer Settings)</a> .</p></div></div>

<div class="footdef"><sup><a id="fn.86" class="footnum" href="#fnr.86">86</a></sup> <div class="footpara"><p class="footpara">关于 noweb 文学化编程的
细节,请参阅 <a href="http://www.cs.tufts.edu/~nr/noweb/">http://www.cs.tufts.edu/~nr/noweb/</a>.</p></div></div>

<div class="footdef"><sup><a id="fn.87" class="footnum" href="#fnr.87">87</a></sup> <div class="footpara"><p class="footpara">更多信息,请查阅 <code>org-tempo.el</code> 文件的注释部分.</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: kamisama</p>
</div>
</body>
</html>
